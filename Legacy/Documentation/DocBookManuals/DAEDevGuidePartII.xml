<?xml version="1.0"?>
<part id="DDGPart2"> 
	 <partinfo> 
		  <date role="LastMod">Friday, April 02, 2004 10:47:18</date> 
		  <revhistory> 
				<revision> 
					 <revnumber>1</revnumber> 
					 <date>Friday, May 31, 2002 3:33:25 PM</date> 
					 <revdescription> 
						  <para>DXC to DocBook</para> 
					 </revdescription> 
				</revision> 
				<revision><revnumber>2</revnumber><date>5/31/2002</date> 
					 <revdescription> 
						  <para>extracted to an external entity. slf.</para> 
					 </revdescription> 
				</revision> 
		  </revhistory> 
	 </partinfo> 
	 <title><indexterm><primary>DAE Implementation
					 Architecture</primary></indexterm>Part II - Implementation Architecture</title>
	 
	 <partintro> 
		  <para>This part discusses the anatomy and mechanics of the Dataphor
				Data Access Engine (DAE) implementation. This part is of a more technical
				nature, and assumes a thorough understanding of the topics presented in Part
				I.</para></partintro> 
	 <chapter id="DDGP2ServerArchitecture"> 
		  <title><indexterm><primary>DAE Server
						  Architecture</primary></indexterm>Server Architecture</title> 
		  <para>This chapter provides an overview of the DAE server architecture.
				The functionality and services of the DAE are divided into five main
				categories: 
				<itemizedlist> 
					 <listitem> 
						  <para>Server</para> 
					 </listitem> 
					 <listitem> 
						  <para>Session</para> 
					 </listitem> 
					 <listitem> 
						  <para>Process</para> 
					 </listitem> 
					 <listitem> 
						  <para>Plan</para> 
					 </listitem> 
					 <listitem> 
						  <para>Cursor</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>Each of these categories are considered in detail in the sections
				of this chapter.</para> 
		  <sect1 id="DDGP2Server"> 
				<title><indexterm><primary>Server</primary></indexterm><indexterm><primary>DAE
								Server ArchitectureServer
								Architecture</primary><secondary>Server</secondary></indexterm>Server</title> 
				<para>The Server level of the DAE architecture provides the
					 framework for the rest of the functionality of the system. It provides system
					 level services and resource managers, and manages the state of the entire
					 server, as well as the user sessions running in the system. This level of the
					 architecture is implemented by the class
					 <symbol>Alphora.Dataphor.DAE.Server.Server</symbol>. Each DAE server has a
					 <symbol>Name</symbol> property which serves to uniquely identify the server
					 instance within a <symbol>ServerFactory</symbol>. The DAE server also has a
					 <symbol>State</symbol> property which describes the current running state of
					 the server: 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>State</entry><entry>Description</entry>
										  
									 </row></thead><tbody> 
									 <row><entry>Stopped</entry><entry>The server is
												stopped. Only external configuration actions can be performed against the
												server while in this state.</entry> 
									 </row> 
									 <row><entry>Starting</entry><entry>The server is
												performing startup processing. Only system processes can run while in this
												state. No external connection requests will be granted.</entry> 
									 </row> 
									 <row><entry>Started</entry><entry>The server is
												running normally.</entry> 
									 </row> 
									 <row><entry>Stopping</entry><entry>The server is
												performing shutdown processing. Only system processes can run while in this
												state.</entry> 
									 </row></tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>The DAE RDBMS is hosted in an instance of the class
					 <symbol>Alphora.Dataphor.DAE.Server</symbol>. This class has
					 <symbol>Start</symbol> and <symbol>Stop</symbol> methods that are used to
					 control the <symbol>State</symbol> of the instance. The class also has other
					 configuration properties such as <symbol>StartupScriptURI</symbol>, which
					 specifies the URI of a script to execute upon starting the instance, and
					 <symbol>CatalogFileName</symbol> which references a file that is used to
					 persist the system catalog.</para> 
				<para>The <symbol>ServerFactory</symbol> class has static methods
					 for managing DAE <symbol>Server</symbol> instances. For example, an instance of
					 the DAE <symbol>Server</symbol> is created through the
					 <symbol>RegisterServer</symbol> method of the <symbol>ServerFactory</symbol>.
					 Connections to DAE <symbol>Server</symbol> instances are also established via
					 the <symbol>ServerFactory</symbol>. The <symbol>ServerFactory</symbol>
					 transparently provides communications across process boundaries, or direct
					 in-process access to DAE <symbol>Server</symbol> instances.</para> 
				<para>For simplicity, the tasks of preparing a TCP communications
					 channel and creating an instance of the DAE <symbol>Server</symbol> using the
					 <symbol>ServerFactory</symbol> are wrapped in the
					 <symbol>ServerService</symbol> class. This class is used to easily host and
					 configure an instance of the DAE <symbol>Server</symbol>.</para> 
				<para>The DAE <symbol>Server</symbol>,
					 <symbol>ServerFactory</symbol>, and <symbol>ServerService</symbol> classes are
					 contained in the <symbol>Alphora.Dataphor.DAE</symbol> assembly. This assembly
					 contains the core elements of the Data Access Engine including the query
					 processor.</para> 
				<para>There are several other server level configuration properties
					 which are described in the appropriate sections. The following sections
					 describe the services and functionality implemented by the server layer of the
					 DAE architecture.</para> 
				<sect2 id="DDGP2SessionManager"> 
					 <title><indexterm><primary>Session
									 Manager</primary></indexterm>Session Manager</title> 
					 <para>The server layer manages communication with external
						  sources. Each DAE instance maintains a list of all currently active sessions
						  using an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Server.ServerSessions</symbol>. Connection
						  requests are made through the <symbol>Connect</symbol> method. Each connection
						  request provides an instance of the class
						  <symbol>Alphora.Dataphor.DAE.SessionInfo</symbol> describing the user
						  information, as well as requested configuration settings for the new
						  connection. Once the user requesting the connection has been authenticated, the
						  session is added to the list of active connections, and a handle is returned
						  for use in subsequent calls against the DAE. When the session is no longer
						  required, it must be closed with a call to the <symbol>Disconnect</symbol>
						  method. Closing a session cleans up any resources used by the session and
						  removes it from the list of active sessions. Attempting to use a closed session
						  is an error. A session will remain active as long as there is an active
						  reference to it in some client application. This is accomplished using the
						  lifetime services of .NET remoting. When a session is no longer required, the
						  server will close the session automatically, cleaning up any resources in the
						  process. When the server receives a shutdown request, the session manager
						  automatically closes all active sessions.</para> 
				</sect2> 
				<sect2 id="DDGP2StreamManager"> 
					 <title><indexterm><primary>Stream
									 Manager</primary></indexterm>Stream Manager</title> 
					 <para>The DAE abstracts all data storage into the concept of a
						  stream. This architecture is described in detail in the Runtime Architecture
						  chapter. A stream manager is used to handle stream allocation and manipulation
						  requests coming in from active processes within the DAE. The server layer
						  provides this stream manager for the rest of the system using an instance of
						  the class <symbol>Alphora.Dataphor.DAE.Streams.ServerStreamManager</symbol>.
						  This manager allows any process within the DAE to access data using the stream
						  identifier. Processes within the system coordinate with this manager for
						  in-process requests, as well as managing calls coming from remote access to the
						  server to ensure that stream transfer is handled as efficiently as
						  possible.</para> 
				</sect2> 
				<sect2 id="DDGP2LockManager"> 
					 <title><indexterm><primary>Lock
									 Manager</primary></indexterm>Lock Manager</title> 
					 <para>The server layer provides a lock manager to allow the
						  different resource managers in the system to coordinate access to their
						  respective resources. Each resource manager has an associated identifier which
						  is used to guarantee uniqueness of the locks provided by the lock manager. When
						  requesting protection for a resource in the form of a lock, the resource
						  manager names the resource with some unique name within the resource manager.
						  Each resource manager must follow correct locking protocols in order to ensure
						  that the resources are protected. The lock manager is implemented by an
						  instance of the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.LockManager</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2CatalogManager"> 
					 <title><indexterm><primary>Catalog
									 Manager</primary></indexterm>Catalog Manager</title> 
					 <para>The catalog manager provides access to the system catalog
						  including system users and system devices. The catalog manager communicates
						  with the lock manager to provide concurrency control on the catalog. The
						  catalog is implemented by an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Catalog</symbol>. </para> 
					 <para>The DAE can function strictly as a catalog repository,
						  meaning that no data is actually stored, and only the structural aspects of the
						  catalog are available. This behavior is controlled through the
						  <symbol>IsRepository</symbol> property of the <symbol>Server</symbol> instance.
						  A DAE running in this mode is used to enable remote evaluation of expressions
						  and statements, as well as a catalog cache point. </para> 
					 <para>The catalog manager also includes the system devices and
						  the system users, which are exposed as properties of the server
						  instance.</para> 
					 <sect3 id="DDGP2SystemDevices"> 
						  <title><indexterm><primary>System
										  Devices</primary></indexterm>System Devices</title> 
						  <para>A running DAE has three system devices which are
								created and maintained by the server itself: the catalog device, the heap
								device, and the temporary device.</para> 
						  <para>The catalog device provides the storage container for
								the catalog itself and allows the system catalog to be exposed as a set of
								tables accessible via the D4 language. These tables are materialized from the
								internal structures when they are requested. The catalog device is registered
								in the system catalog with the name <symbol>System.Catalog</symbol>. This
								device is read-only.</para> 
						  <para>The heap device provides the allocation space for
								table variables used by running processes in the DAE. The device is used by the
								compiler and processor to manage table values required by the evaluation of
								statements within the DAE. Each process is responsible for ensuring the
								uniqueness of table variables within the heap. The heap device is registered in
								the system catalog with the name <symbol>System.HeapDevice</symbol>. This
								device is only available for internal use.</para> 
						  <para>The temporary device provides users of the DAE with a
								temporary storage area for table values. Data in this device is not persisted,
								but structures created in the device are part of the regular catalog and will
								be persisted. Sessions provide a management feature to deallocate table
								variables created in the temporary device. For more details, see the discussion
								on the session layer of the server architecture. The temporary device is
								registered in the system catalog with the name <symbol>System.Temp</symbol>.
								This device serves as the default device when no device is specified in a table
								variable definition, and no default device name is given on the session
								configuration.</para> 
					 </sect3> 
					 <sect3 id="DDGP2SystemUsersandProcesses"> 
						  <title><indexterm><primary>System Users and
										  Processes</primary></indexterm>System Users and Processes</title> 
						  <para>The DAE maintains a system user, an administrative
								user, and a system process. The system user is only used by the system to
								perform internal tasks, and can only be used by the system process. The
								administrative user is the default user for the DAE, and is the only user that
								can perform administrative level tasks like user maintenance. The
								administrative user name is "Admin" and the default password is "", or the
								empty string.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2ClassLoadingServices"> 
					 <title><indexterm><primary>Class Loading
									 Services</primary></indexterm>Class Loading Services</title> 
					 <para>All host language integration in the DAE is accomplished
						  through the use of class definitions which describe .NET CLR classes which are
						  used to implement specific operations throughout the system. These class
						  definitions can name specific classes using fully qualified assembly names, or
						  they can use the class loading services provided by the DAE to use class name
						  aliases. This allows a single alias name in the definition of some peice of the
						  logical model to map to a specific version of the class which is implementing
						  it without binding the logical model to the version. This allows for greater
						  flexibility in the deployment of Dataphor applications, without sacrificing the
						  assembly management capabilities provided by the .NET runtime.</para> 
					 <para>In order to make use of the class loading services
						  provided by the DAE, an assembly must be registered with the DAE. The
						  registration process allows the assembly to provide a list of class aliases
						  available within the assembly, and their corresponding assembly qualified class
						  names. Assemblies can be registered using three methods: 
						  <orderedlist> 
								<listitem> 
									 <para>Set the
										  <symbol>DAERegisteredAssemblies</symbol> property of the
										  <symbol>Server</symbol> to an <symbol>ArrayList</symbol> of fully qualified
										  assembly names. On startup, the DAE will attempt to register each assembly in
										  this list. An error during this registration process prevents startup of the
										  DAE.</para> 
								</listitem> 
								<listitem> 
									 <para>Use the <symbol>RegisterAssembly</symbol>
										  method of the <symbol>Server</symbol>.</para> 
								</listitem> 
								<listitem> 
									 <para>Use the <symbol>RegisterAssembly</symbol>
										  operator available in the system library.</para> 
								</listitem> 
						  </orderedlist> The process of registering an assembly
						  consists of the following steps: 
						  <orderedlist> 
								<listitem> 
									 <para>Attempt to load the given assembly using a
										  call to <symbol>AppDomain.Load</symbol>.</para> 
								</listitem> 
								<listitem> 
									 <para>The assembly metadata is searched for an
										  instance of the
										  <symbol>Alphora.Dataphor.DAE.Server.DAERegisterAttribute</symbol>. If this
										  attribute is not found, or it does not contain the name of a registration class
										  in the <symbol>RegisterClassName</symbol> property, an error occurs.</para> 
								</listitem> 
								<listitem> 
									 <para>The <symbol>Type</symbol> instance for the
										  registration class specified by the
										  <symbol>DAERegisterAttribute.RegisterClassName</symbol> property is loaded from
										  the assembly. This class must contain a static method called
										  <symbol>GetClasses()</symbol> which returns an instance of the class
										  <symbol>Alphora.Dataphor.BOP.SettingsList</symbol>.</para> 
								</listitem> 
								<listitem> 
									 <para>The registration method is invoked, and each
										  name-value pair in the <symbol>SettingsList</symbol> that is returned is
										  registered with the
										  <symbol>Alphora.Dataphor.DAE.Language.D4.ClassLoader</symbol>.</para> 
								</listitem> 
						  </orderedlist></para> 
					 <para>Whenever a class definition in the DAE is used to create
						  an instance of a .NET CLR class, the <symbol>ClassLoader</symbol> is invoked to
						  perform the operation. If a class mapping is found for the class name, the
						  associated assembly qualified class name is used instead, otherwise the given
						  class name is used to create the instance.</para> 
					 <para>Assemblies can also be unregistered using the
						  <symbol>UnRegisterAssembly</symbol> method of the <symbol>Server</symbol>, or
						  the <symbol>UnRegisterAssembly</symbol> operator in the D4 language.
						  Unregistering an assembly follows the same steps as registration, except that
						  each name-value pair in the <symbol>SettingsList</symbol> returned from the
						  registration class is removed form the <symbol>ClassLoader</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2LogServices"> 
					 <title><indexterm><primary>Log
									 Services</primary></indexterm>Log Services</title> 
					 <para>The DAE provides two methods for logging events which
						  occur in the DAE server. The first is as a Windows Application Event Log, and
						  the second is as an internal table which logs trace events.</para> 
					 <sect3 id="DDGP2EventLog"> 
						  <title><indexterm><primary>Event
										  Log</primary></indexterm>Event Log</title> 
						  <para>The DAE registers an event log with the Windows
								operating system called "Dataphor". The source for this event log is called
								"Dataphor Server". It then registers an instance of the class
								<symbol>System.Diagnostics.EventLogTraceListener</symbol> with the
								<symbol>System.Diagnostics.Trace</symbol> class in the .NET Framework. This
								outputs any trace events coming through the .NET Framework to the Dataphor
								event log. The System Event Viewer can then be used to view these events.
								Tracing in this manner can be enabled or disabled at different levels of the
								system, but not for individual events. The <symbol>TracingEnabled</symbol>
								property of the <symbol>Server</symbol> instance controls this behavior at the
								server level. The <symbol>SessionTracingEnabled</symbol> property of the
								<symbol>SessionInfo</symbol> instance controls this behavior for each
								session.</para> 
					 </sect3> 
					 <sect3 id="DDGP2TraceEvents"> 
						  <title><indexterm><primary>Trace
										  Events</primary></indexterm>Trace Events</title> 
						  <para>The DAE also exposes a system table called
								<symbol>System.TraceEvents</symbol> which is created when necessary, and used
								to trace individual events occurring in the DAE. Each traceable event in the
								system is assigned a unique trace code. The <symbol>TraceOn(string
								ATraceCode)</symbol> method of the <symbol>Server</symbol> instance is used to
								start tracing for a particular trace code, and the <symbol>TraceOff(string
								ATraceCode)</symbol> method is used to stop tracing. These methods are also
								exposed as operators in the system library.</para> 
						  <para>The following table list the available trace codes in
								the DAE: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Trace
														  Code</entry><entry>Description</entry> 
												</row></thead><tbody> 
												<row><entry>000001</entry><entry>Occurs
														  whenever a parsing operation begins.</entry> 
												</row> 
												<row><entry>000002</entry><entry>Occurs
														  whenever a parsing operation completes.</entry> 
												</row> 
												<row><entry>000003</entry><entry>Occurs
														  whenever a compilation operation begins.</entry> 
												</row> 
												<row><entry>000004</entry><entry>Occurs
														  whenever a compilation operation ends.</entry> 
												</row> 
												<row><entry>000005</entry><entry>Occurs
														  whenever a prepare operation begins.</entry> 
												</row> 
												<row><entry>000006</entry><entry>Occurs
														  whenever a prepare operation completes.</entry> 
												</row> 
												<row><entry>000007</entry><entry>Occurs
														  whenever a begin transaction operation begins.</entry> 
												</row> 
												<row><entry>000008</entry><entry>Occurs
														  whenever a begin transaction operation completes.</entry> 
												</row> 
												<row><entry>000009</entry><entry>Occurs
														  whenever a prepare transcation operation begins.</entry> 
												</row> 
												<row><entry>000010</entry><entry>Occurs
														  whenever a prepare transaction operation completes.</entry> 
												</row> 
												<row><entry>000011</entry><entry>Occurs
														  whenever a commit transaction operation begins.</entry> 
												</row> 
												<row><entry>000012</entry><entry>Occurs
														  whenever a commit transaction operation ends.</entry> 
												</row> 
												<row><entry>000013</entry><entry>Occurs
														  whenever a rollback transaction operation begins.</entry> 
												</row> 
												<row><entry>000014</entry><entry>Occurs
														  whenever a rollback transaction operation ends.</entry> 
												</row> 
												<row><entry>000015</entry><entry>Occurs
														  whenever a begin application transaction operation begins.</entry> 
												</row> 
												<row><entry>000016</entry><entry>Occurs
														  whenever a begin application transaction operation ends.</entry> 
												</row> 
												<row><entry>000017</entry><entry>Occurs
														  whenever a join application transaction operation begins.</entry> 
												</row> 
												<row><entry>000018</entry><entry>Occurs
														  whenever a join application transaction operation ends.</entry> 
												</row> 
												<row><entry>000019</entry><entry>Occurs
														  whenever a prepare application transaction operation begins.</entry> 
												</row> 
												<row><entry>000020</entry><entry>Occurs
														  whenever a prepare application transaction operation ends.</entry> 
												</row> 
												<row><entry>000021</entry><entry>Occurs
														  whenever a commit application transaction operation begins.</entry> 
												</row> 
												<row><entry>000022</entry><entry>Occurs
														  whenever a commit application transaction operation ends.</entry> 
												</row> 
												<row><entry>000023</entry><entry>Occurs
														  whenever a rollback application transaction operation begins.</entry> 
												</row> 
												<row><entry>000024</entry><entry>Occurs
														  whenever a rollback application transaction operation ends.</entry> 
												</row> 
												<row><entry>000025</entry><entry>Occurs
														  whenever an execute operation begins.</entry> 
												</row> 
												<row><entry>000026</entry><entry>Occurs
														  whenever an execute operation ends.</entry> 
												</row> 
												<row><entry>000027</entry><entry>Occurs
														  whenever an open cursor operation begins.</entry> 
												</row> 
												<row><entry>000028</entry><entry>Occurs
														  whenever an open cursor operation ends.</entry> 
												</row> 
												<row><entry>000029</entry><entry>Occurs
														  whenever a node is unsupported by an associated device.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Sessions"> 
				<title><indexterm><primary>Sessions</primary></indexterm>Sessions</title>
				
				<para>The Session level of the DAE architecture manages
					 communications with the system, as well as session specific functionality such
					 as temporary tables and cursors. This level of the DAE architecture is
					 implemented by instances of the class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerSession</symbol>.</para> 
				<sect2 id="DDGP2SessionInformation"> 
					 <title><indexterm><primary>Session
									 Information</primary></indexterm>Session Information</title> 
					 <para>Each session in the DAE is assigned a unique session
						  identifier by the Session Manager. This identifier is exposed on the
						  <symbol>ServerSession</symbol> instance by the property
						  <symbol>SessionID</symbol>. Each session also has associated configuration
						  information which is available through the <symbol>SessionInfo</symbol>
						  property as an instance of the class
						  <symbol>Alphora.Dataphor.DAE.SessionInfo</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2ProcessManager"> 
					 <title><indexterm><primary>Process
									 Manager</primary></indexterm>Process Manager</title> 
					 <para>Each session manages all the processes running for a
						  specific user. The <symbol>StartProcess</symbol> method of the
						  <symbol>ServerSession</symbol> instance is used to start a new process for the
						  session, and the <symbol>StopProcess</symbol> method is used to stop an
						  existing process. Each session can have any number of active processes within
						  it.</para> 
				</sect2> 
				<sect2 id="DDGP2TemporaryTables"> 
					 <title><indexterm><primary>Temporary
									 Tables</primary></indexterm>Temporary Tables</title> 
					 <para>Each session manages a list of temporary table variables
						  to help facilitate session specific table variables for application usage. This
						  list is exposed through the <symbol>TempTables</symbol> property of the
						  <symbol>ServerSession</symbol> instance. All the table variables in this list
						  will be deallocated when the session is closed. A table variable is added to
						  this list when the associated metadata contains a tag of the form
						  <symbol>DAE.SessionCleanup = "true"</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2CursorManager"> 
					 <title><indexterm><primary>Cursor
									 Manager</primary></indexterm>Cursor Manager</title> 
					 <para>Each session manages a list of open cursors on the
						  session. These are cursors used to service cursor requests within the D4
						  language, not server level cursors as described in this section. For a complete
						  discussion of the cursor manager, refer to the values section of the Runtime
						  Architecture chapter.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Processes"> 
				<title><indexterm><primary>Processes</primary></indexterm>Processes</title>
				
				<para>The Process level of the DAE architecture manages running
					 processes in the system. Each process is a specific thread of execution within
					 the DAE. Processes manage transactions, run-time state, and device
					 communications. This level of the DAE architecture is implemented by instances
					 of the class <symbol>Alphora.Dataphor.DAE.ServerProcess</symbol>.</para> 
				<sect2 id="DDGP2ProcessInformation"> 
					 <title><indexterm><primary>Process
									 Information</primary></indexterm>Process Information</title> 
					 <para>Each process in a given session is assigned a unique
						  process identifier by the Process Manager. This identifier is exposed on the
						  <symbol>ServerProcess</symbol> instance by the property
						  <symbol>ProcessID</symbol>. Each process is logically associated with a system
						  thread running in the DAE, but processes are not guaranteed to run on the same
						  thread throughout the execution of the process. For this reason, state
						  associated with a process running in the DAE should be tied to the process
						  identifier.</para> 
					 <para>Each process also has a configuration option exposed
						  through the <symbol>DefaultIsolationLevel</symbol> property which determines
						  the default isolation level for transactions on the process. See the section on
						  transaction management for a complete discussion of the values that this
						  property can have, and how they affect the behavior of the process.</para> 
				</sect2> 
				<sect2 id="DDGP2PlanManager"> 
					 <title><indexterm><primary>Plan
									 Manager</primary></indexterm>Plan Manager</title> 
					 <para>Each process manages a list of prepared plans using an
						  instance of the class <symbol>Alphora.Dataphor.DAE.Server.ServerPlans</symbol>.
						  These plans are created in response to the various <symbol>Prepare</symbol>
						  commands exposed by the process, and include the executable code required to
						  carry out the requested operations. Because plans consume system resources such
						  as catalog locks and plan state, the prepared plan must be unprepared with a
						  call to the various <symbol>Unprepare</symbol> commands. Any plans not
						  unprepared explicitly will be implicitly unprepared by the plan manager when
						  the process is stopped.</para> 
				</sect2> 
				<sect2 id="DDGP2ScriptManager"> 
					 <title><indexterm><primary>Script
									 Manager</primary></indexterm>Script Manager</title> 
					 <para>Each process manages a list of prepared scripts using an
						  instance of the class
						  <symbol>Alphora.Dataphor.DAE.Server.ServerScripts</symbol>. These scripts are
						  created in response to the <symbol>PrepareScript</symbol> command exposed by
						  the process. Scripts are implemented as instances of the class
						  <symbol>Alphora.Dataphor.DAE.Server.ServerScript</symbol>. Each script is
						  completely parsed and each top-level statement in the script is broken down
						  into a batch represented by an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Server.ServerBatch</symbol>. The script manages
						  the list of these batches using an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Server.ServerBatches</symbol>. Each batch within
						  the script can then be executed individually, or opened, if applicable.
						  Alternatively, the entire script can be executed in a single command. In either
						  case, each batch is compiled and executed separately and sequentially, in the
						  order they appear in the script. This allows statements to reference catalog
						  objects created earlier in the script.</para> 
				</sect2> 
				<sect2 id="DDGP2Run-TimeStateManager"> 
					 <title><indexterm><primary>Run-Time State
									 Manager</primary></indexterm>Run-Time State Manager</title> 
					 <para>Each process manages its associated run-time state. Only
						  one prepared plan can be executing at any given time in a single process, and
						  that plan uses the context of the process for variable manipulation and
						  storage. This run-time state is exposed through the <symbol>Stack</symbol>
						  property of the <symbol>ServerProcess</symbol> instance. This property is an
						  instance of the class <symbol>Alphora.Dataphor.DAE.Runtime.Context</symbol>
						  which manages a run-time stack and heap for the process. This class exposes
						  methods for accessing and manipulating variables on the stack, and for managing
						  stack windows and frames.</para> 
				</sect2> 
				<sect2 id="DDGP2DeviceSessionManager"> 
					 <title><indexterm><primary>Device Session
									 Manager</primary></indexterm>Device Session Manager</title> 
					 <para>Each process manages a list of sessions it has opened
						  with the various devices available in the system using an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DeviceSessions</symbol>. This class is
						  exposed through the <symbol>DeviceSessions</symbol> property of the
						  <symbol>ServerProcess</symbol> instance. Each of these sessions is represented
						  using an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DeviceSession</symbol>. The
						  <symbol>DeviceConnect</symbol> method of the <symbol>ServerProcess</symbol>
						  instance initiates a connection to a given device. Each server process will
						  have at most one device session for each device in the system that it has
						  connected to. The <symbol>DeviceDisconnect</symbol> method is used to close the
						  communications session with a given device. Any device sessions that are not
						  explicitly closed will be implicitly closed when the process is stopped.</para>
					 
				</sect2> 
				<sect2 id="DDGP2TransactionManager"> 
					 <title><indexterm><primary>Transaction
									 Manager</primary></indexterm>Transaction Manager</title> 
					 <para>Each process manages a list of transactions that have
						  been started on the process. These transactions are tracked using an instance
						  of the class <symbol>Alphora.Dataphor.DAE.ServerTransactions</symbol>. Each
						  transaction is represented using an instance of the class
						  <symbol>Alphora.Dataphor.DAE.ServerTransaction</symbol>. The
						  <symbol>ServerProcess</symbol> instance exposes the following methods and
						  properties for managing transactions: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Method</entry><entry>Description</entry>
												
										  </row></thead><tbody> 
										  <row><entry><symbol>BeginTransaction</symbol></entry><entry>Starts
													 a new transaction on the process. If the process is already in a transaction,
													 the transaction is nested. Calling this method increases the
													 <symbol>TransactionCount</symbol> property by 1.</entry> 
										  </row> 
										  <row><entry><symbol>PrepareTransaction</symbol></entry><entry>Prepares
													 the current transaction for commit. This validates any integrity constraints
													 that may have been affected by the transaction, and ensures that a commit call
													 will be successful, without releasing any of the locks protecting the
													 transaction. This method has no affect on the <symbol>TransactionCount</symbol>
													 property.</entry> 
										  </row> 
										  <row><entry><symbol>CommitTransaction</symbol></entry><entry>Commits
													 the current transaction to the database, releasing any locks that were acquired
													 during the transaction. Calling this method descreases the
													 <symbol>TransactionCount</symbol> property by 1.</entry> 
										  </row> 
										  <row><entry><symbol>RollbackTransaction</symbol></entry><entry>Rolls
													 back all work done during the current transaction and releases any locks that
													 were acquired during the transaction. Calling this method descreases the
													 <symbol>TransactionCount</symbol> property by 1.</entry> 
										  </row> 
										  <row><entry><symbol>TransactionCount</symbol></entry><entry>Returns
													 the current nesting level of the process, or the number of times that
													 <symbol>BeginTransaction</symbol> has been called without an associated
													 <symbol>CommitTransaction</symbol> or
													 <symbol>RollbackTransaction</symbol>.</entry> 
										  </row> 
										  <row><entry><symbol>InTransaction</symbol></entry><entry>Returns
													 true if the process has any active transactions, and false otherwise. The value
													 of this property is equivalent to the expression <symbol>TransactionCount &gt;
													 0</symbol>.</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <sect3 id="DDGP2TransactionalCallProtocol"> 
						  <title><indexterm><primary>Transactional Call
										  Protocol</primary></indexterm>Transactional Call Protocol</title> 
						  <para>The DAE requires that all work done on a process be
								protected within a transaction. In order to ensure that this is the case the
								process enforces a transactional call protocol on the methods available in the
								process and the layers below it. This protocol ensures that any call made
								against the process is wrapped within a transaction by implicitly beginning a
								new transaction if there are no active transactions on the process. This
								implicit transaction will be committed when the call which required it
								completes without error. If any error occurs during the processing of the call,
								the implicit transaction will be rolled back. In addition, uncommitted
								transactions initiated during the call will be committed if the call completes
								without error, and rolled back otherwise. In this way, the nesting level of a
								process is guaranteed to be at least as shallow after a call as before
								it.</para> 
					 </sect3> 
					 <sect3 id="DDGP2IsolationLevels"> 
						  <title><indexterm><primary>Isoloation
										  Levels</primary></indexterm>Isolation Levels</title> 
						  <para>The isolation level for a transaction determines how
								it interacts with other transactions running in the system. The isolation level
								of a transaction is exposed by the <symbol>IsolationLevel</symbol> property of
								the <symbol>ServerTransaction</symbol> instance. The following table details
								the valid values for this property:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Isolation
														  Level</entry><entry>Description</entry> 
												</row></thead><tbody> 
												<row><entry>Browse</entry><entry>Indicates
														  that the transaction acquires exclusive locks to protect writes, but that it
														  may read uncommitted data from other transactions.</entry> 
												</row> 
												<row><entry>Cursor
														  Stability</entry><entry>Indicates that the transaction acquires exclusive locks
														  to protect writes, and that only committed data from other transactions can be
														  read.</entry> 
												</row> 
												<row><entry>Isolated</entry><entry>Indicates
														  that the transaction runs completely isolated from other transactions.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2DistributedTransactions"> 
						  <title><indexterm><primary>Distributed
										  Transactions</primary></indexterm>Distributed Transactions</title> 
						  <para>The server process also coordinates the involvement
								of device sessions in each transaction, in effect becoming a distributed
								transaction coordinator. However, most devices which the DAE connects to do not
								expose a mechanism for manual participation in distributed transactions through
								the data access layer used for communication with the device. When this is the
								case, the DAE can employ the services of the Microsoft Distributed Transaction
								Coordinator (MSDTC) to manage the distributed transaction. If a device cannot
								participate in a distributed transaction in one of these ways, it is
								optimistically included in the transaction.</para> 
						  <para>The server process exposes a configuration option to
								control the behavior of the distributed transaction manager through the
								property <symbol>UseDTC</symbol> of the <symbol>ServerProcess</symbol>
								instance. When this property is set to true, the process will use the MSDTC to
								coordinate distributed transactions. When this property is set to false, the
								process will function as an optimistic distributed transaction coordinator as
								described above.</para> 
						  <para>Because the MSDTC does not support nested distributed
								transactions, the transactional behavior in the server process is significantly
								different when running in this mode. The process simulates nested transactions
								by running all nested transactions in a single distributed transaction
								coordinated by the MSDTC. An instance of the class
								<symbol>Alphora.Dataphor.DAE.ServerDTCTransaction</symbol> is created to
								initiate a distributed transaction in the MSDTC through the enterprise services
								of the .NET Framework. This transaction then flows through the connectivity
								layers of the different devices. Only when all the nested transactions for a
								given process are committed is the supporting distributed transaction
								committed. However, if a rollback occurs, the distributed transaction is rolled
								back immediately, along with all nested transactions. This brings the
								<symbol>TransactionCount</symbol> property to 0. This asymmetry is required to
								ensure that the transaction processing occurs correctly on each device. These
								differences are summarized in the following table: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>BeginTransaction</symbol></entry><entry>Begins
														  a new distributed transaction if one is not already in progress, and increases
														  the <symbol>TransactionCount</symbol> property by 1.</entry> 
												</row> 
												<row><entry><symbol>PrepareTransaction</symbol></entry><entry>The
														  behavior of this property is unaffected by the distributed transaction mode of
														  the process.</entry> 
												</row> 
												<row><entry><symbol>CommitTransaction</symbol></entry><entry>Decreases
														  the <symbol>TransactionCount</symbol> property by 1. If this is the top-level
														  transaction, this call will also commit the distributed transaction.</entry> 
												</row> 
												<row><entry><symbol>RollbackTransaction</symbol></entry><entry>Rolls
														  back the distributed transaction and sets the <symbol>TransactionCount</symbol>
														  property to 0, regardless of the current nesting level of the process.</entry> 
												</row> 
												<row><entry><symbol>TransactionCount</symbol></entry><entry>The
														  behavior of this property is unaffected by the distributed transaction mode of
														  the process.</entry> 
												</row> 
												<row><entry><symbol>InTransaction</symbol></entry><entry>The
														  behavior of this property is unaffected by the distributed transaction mode of
														  the process.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2ApplicationTransactions"> 
					 <title><indexterm><primary>Application
									 Transactions</primary></indexterm>Application Transactions</title> 
					 <para>Each process exposes methods for participating in
						  application transactions, though the process itself is not the manager of these
						  transactions. For a complete discussion of application transactions, see the
						  Application Transactions section of the Application Targeted Features chapter.
						  The following table summarizes the application transaction methods available on
						  the <symbol>ServerProcess</symbol> instance: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Method</entry><entry>Description</entry>
												
										  </row></thead><tbody> 
										  <row><entry><symbol>BeginApplicationTransaction</symbol></entry><entry>Begins
													 a new application transaction, allocating space for it in the database. Returns
													 the application transaction identifier to be used in subsequent calls on the
													 application transaction.</entry> 
										  </row> 
										  <row><entry><symbol>JoinApplicationTransaction</symbol></entry><entry>Joins
													 an existing application transaction using the given expression and
													 parameterization information. Returns an equivalent expression to be used in
													 terms of the tables within the application transaction.</entry> 
										  </row> 
										  <row><entry><symbol>PrepareApplicationTransaction</symbol></entry><entry>Prepares
													 an existing application transaction for commit. If this method succeeds, a
													 subsequent call to <symbol>CommitApplicationTransaction</symbol> is guaranteed
													 to commit.</entry> 
										  </row> 
										  <row><entry><symbol>CommitApplicationTransaction</symbol></entry><entry>Prepares
													 if necessary, and commits an existing application transaction and deallocates
													 the resources it was using.</entry> 
										  </row> 
										  <row><entry><symbol>RollbackApplicationTransaction</symbol></entry><entry>Rolls
													 back an existing application transaction and deallocates the resources it was
													 using.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Plans"> 
				<title><indexterm><primary>Plans</primary></indexterm>Plans</title>
				
				<para>The Plan level of the DAE architecture manages prepared
					 statements and expressions. Each plan is a compiled statement of D4 ready for
					 execution in a process. There are several different types of plans created by
					 the DAE. All plans are represented using a hierarchy of classes which all
					 descend from <symbol>Alphora.Dataphor.DAE.Server.ServerPlanBase</symbol>. This
					 class implements the behavior common to all plans, including the plan
					 identifier, compile-time state, and the executable code for the plan.</para> 
				<sect2 id="DDGP2PlanInformation"> 
					 <title><indexterm><primary>Plan
									 Information</primary></indexterm>Plan Information</title> 
					 <para>Each plan in the DAE is identified by a guid and exposed
						  through the property <symbol>PlanID</symbol> of the
						  <symbol>ServerPlanBase</symbol> descendent instance. In addition to uniquely
						  identifying the plan, this identifier is used to generate a unique table
						  variable name to describe the structure of the result set of the plan.</para> 
				</sect2> 
				<sect2 id="DDGP2Compile-TimeStateManager"> 
					 <title><indexterm><primary>Compile-Time State
									 Manager</primary></indexterm>Compile-Time State Manager</title> 
					 <para>Each plan uses an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Server.Plan</symbol> exposed through the
						  <symbol>Plan</symbol> property of the <symbol>ServerPlanBase</symbol>
						  descendent instance to manage the compile-time state for the plan. See the
						  Runtime Architecture chapter for a detailed discussion of the compile time
						  state maintained for plans.</para> 
				</sect2> 
				<sect2 id="DDGP2Localvs.RemotePlans"> 
					 <title><indexterm><primary>Local versus Remote
									 Plans</primary></indexterm>Local vs. Remote Plans</title> 
					 <para>The server architecture is designed to be efficiently
						  accessed both in-process and out-of-process. To accomplish this, the
						  implementation hierarchy begins to split as the access patterns for the various
						  functionalities of the DAE diverge to support more efficient access remotely.
						  The first place this happens in the server classes is in the plan
						  implementations. There are two descendents of
						  <symbol>Alphora.Dataphor.DAE.ServerPlanBase</symbol>. The first,
						  <symbol>Alphora.Dataphor.DAE.Server.ServerPlan</symbol> is optimized for
						  normal, in-process usage. The second,
						  <symbol>Alphora.Dataphor.DAE.Server.RemoteServerPlan</symbol> is optimized for
						  use in remoting contexts when the types of values that can be exchanged as
						  parameters is limited, and the speed at which the interchange occurs is
						  critical to the performance of the overall system.</para> 
					 <para>The <symbol>ServerPlan</symbol> class simply provides a
						  base class for the in-process statement and expression plan descendents by
						  tying to a local process handle. The <symbol>RemoteServerPlan</symbol> class
						  plays the same role in the remote plan hierarchy by tying to a remote process
						  handle.</para> 
				</sect2> 
				<sect2 id="DDGP2Statementvs.ExpressionPlans"> 
					 <title><indexterm><primary>Statement versus Expression
									 Plans</primary></indexterm>Statement vs. Expression Plans</title> 
					 <para>The DAE exposes two different types of plans, statement
						  plans, and expression plans. Statement plans are used to execute commands which
						  do not return results, or where the results that are returned are not desired.
						  Expression plans are used to execute commands that return results.</para> 
					 <para>Statement plans simply expose an <symbol>Execute</symbol>
						  method which can be used to execute the prepared command. This method allows
						  parameters to be passed if desired, allowing for multiple executions of a
						  single prepared plan. The local version of the statement plan is implemented by
						  the class <symbol>Alphora.Dataphor.DAE.ServerStatementPlan</symbol>. The remote
						  version of the statement plan is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.RemoteServerStatementPlan</symbol>.</para> 
					 <para>Expression plans expose <symbol>Open</symbol> and
						  <symbol>Close</symbol> methods for managing the state of a cursor that ranges
						  over the result of evaluating the expression. The <symbol>Open</symbol> method
						  can be parameterized, just like the <symbol>Execute</symbol> method of the
						  statement plan, allowing for multiple executions of a single prepared plan. The
						  <symbol>Open</symbol> method returns a handle to the cursor level of the server
						  architecture. Because only a single plan can be executing at any given time on
						  a process, there is no need to track multiple cursors for a plan, only the
						  currently running cursor is tracked. The local version of the expression plan
						  is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.ServerExpressionPlan</symbol>. The remote version
						  of the expression plan is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.RemoteServerExpressionPlan</symbol>.</para> 
					 <para>Expression plans also expose all the information
						  necessary to describe the structure of the result set returned. This is made
						  available in different ways depending on whether a local or remote plan is
						  used. </para> 
					 <para>For a local plan, there is no need to transfer the
						  catalog descriptions over a remoting boundary, so the instances which represent
						  them can be accessed directly. As such, the
						  <symbol>ServerExpressionPlan</symbol> class simply exposes a
						  <symbol>DataType</symbol> property which describes the type of the result set
						  using an instance of some descendent of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DataType</symbol>, and a
						  <symbol>Catalog</symbol> property which contains the representations of catalog
						  structures which are referenced by the description of the result set.</para> 
					 <para>For a remote plan, the catalog descriptions must be
						  transported over a remoting boundary, so the instances which would normally be
						  exposed through the <symbol>DataType</symbol> and <symbol>Catalog</symbol>
						  properties are emitted as language scripts and transmitted over the remoting
						  boundary as strings. The process is initiated by a call to the
						  <symbol>GetCatalogObjectNames</symbol> method of the
						  <symbol>RemoteServerExpressionPlan</symbol> instance. This returns a string
						  array containing the names of the objects contained in the catalog describing
						  the structure of the result set. The remote process then determines which of
						  the objects listed are not already in its catalog, and uses the
						  <symbol>GetCatalog</symbol> method of the
						  <symbol>RemoteServerExpressionPlan</symbol> instance to request only those
						  objects that are necessary to complete the description of the result set,
						  allowing the remote process to maintain a cache of schema object descriptions.
						  The remote process then uses the <symbol>GetTableVarName</symbol> method to
						  request the name of the table variable that describes the actual result set
						  within the catalog that has been transmitted, or the value of the
						  <symbol>DataType</symbol> property.</para> 
				</sect2> 
				<sect2 id="DDGP2DevicePlans"> 
					 <title><indexterm><primary>Device
									 Plans</primary></indexterm>Device Plans</title> 
					 <para>Each plan also maintains a list of plans which have been
						  prepared for execution within each device referenced by the statement or
						  expression of the plan. As a plan is compiled, the devices involved each
						  prepare a device specific plan containing only the information necessary to
						  execute the 'chunk' of the query that will be processed by the device. This
						  list of plans is represented by an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DevicePlans</symbol>. The individual device
						  plans are represented as instances of some descendent of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DevicePlan</symbol>. For a complete
						  discussion of device plans and their implementation, refer to the Storage
						  Integration Architecture chapter.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Cursors"> 
				<title><indexterm><primary>Cursors</primary></indexterm>Cursors</title>
				
				<para>The Cursor level of the DAE architecture manages a running
					 cursor in the DAE. Cursors are obtained by opening prepared expression plans.
					 There are two different server cursor implementations in the DAE, depending on
					 whether the cursor is requested locally or remotely. Both cursors are
					 implemented by descendents of the class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerCursorBase</symbol>, which implements
					 the behavior that is common to both, including state management, internal
					 bookmark management, behavior description, and communication with the
					 underlying DAE cursor.</para> 
				<para>Internally, the DAE uses instances of some descendent of the
					 class <symbol>Alphora.Dataphor.DAE.Runtime.Data.Table</symbol> to implement
					 cursor behavior. The cursor layer that is actually exposing the cursor behavior
					 is simply a wrapper for these internal cursors which introduces some additional
					 functionality specific to participating in the server architecture.</para> 
				<sect2 id="DDGP2CursorInformation"> 
					 <title><indexterm><primary>Cursor
									 Information</primary></indexterm>Cursor Information</title> 
					 <para>Each cursor maintains state information about whether it
						  is active and exposes it through the property <symbol>Active</symbol> of the
						  <symbol>ServerCursorBase</symbol> descendent instance. The
						  <symbol>Open</symbol> and <symbol>Close</symbol> methods allow the state of a
						  cursor to be controlled manually if desired. The cursor instance returned from
						  the <symbol>Open</symbol> methods of the expression plans is already open,
						  however, and the <symbol>Close</symbol> methods of the expression plans will
						  close the cursor as well. Additionally, if a plan is unprepared while a cursor
						  is active, it will be implicitly closed to guarantee that the resources being
						  used are released to the system.</para> 
				</sect2> 
				<sect2 id="DDGP2CursorCapabilities"> 
					 <title><indexterm><primary>Cursor
									 Capabilities</primary></indexterm>Cursor Capabilities</title> 
					 <para>Cursor capabilities describe the behaviors that a cursor
						  supports. Cursor functionality is broken down into distinct categories of
						  behavior. Each of these categories will be supported completely, or not at all.
						  Cursor capabilities are exposed on the <symbol>ServerCursorBase</symbol>
						  descendent instance through the property <symbol>Capabilities</symbol>. Each of
						  the possible cursor capabilities is considered in detail in the following
						  sections.</para> 
					 <sect3 id="DDGP2Navigable"> 
						  <title><indexterm><primary>Navigable</primary></indexterm>Navigable</title>
						  
						  <para>Navigable indicates that the cursor supports basic
								navigational access. All cursors must support this level of
								functionality.</para> 
						  <para>The following methods are included in the Navigable
								category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>Select</symbol></entry><entry>Retrieves
														  the current row of the cursor. It is an error if either <symbol>BOF</symbol> or
														  <symbol>EOF</symbol> is true.</entry> 
												</row> 
												<row><entry><symbol>Next</symbol></entry><entry>Advances
														  the current position of the cursor by 1 row. If this moves past the last row in
														  the result set, <symbol>EOF</symbol> will be true.</entry> 
												</row> 
												<row><entry><symbol>Last</symbol></entry><entry>Moves
														  the current position of the cursor past the last row in the result set.
														  <symbol>EOF</symbol> will always be true after a call to
														  <symbol>Last</symbol></entry> 
												</row> 
												<row><entry><symbol>BOF</symbol></entry><entry>Returns
														  true if the current position of the cursor is before the first row in the
														  result set. <symbol>BOF</symbol> will always be true when the cursor is first
														  opened.</entry> 
												</row> 
												<row><entry><symbol>EOF</symbol></entry><entry>Returns
														  true if the current position of the cursor is after the last row in the result
														  set. <symbol>EOF</symbol> will only be true after the cursor is first opened if
														  the cursor is empty.</entry> 
												</row> 
												<row><entry><symbol>IsEmpty</symbol></entry><entry>Returns
														  true if there are no rows in the result set. This is equivalent to evaluating
														  the expression <symbol>BOF &amp;&amp; EOF</symbol>.</entry> 
												</row> 
												<row><entry><symbol>Reset</symbol></entry><entry>Resets
														  the cursor by requerying for the result set. This is equivalent to closing and
														  re-opening the cursor.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2BackwardsNavigable"> 
						  <title><indexterm><primary>Backwards
										  Navigable</primary></indexterm>Backwards Navigable</title> 
						  <para>Backwards Navigable indicates that the cursor
								supports backwards navigation.</para> 
						  <para>The following methods are included in the Backwards
								Navigable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>Prior</symbol></entry><entry>Moves
														  the current position of the cursor to the prior row. If this moves before the
														  first row in the result set, <symbol>BOF</symbol> will be true.</entry> 
												</row> 
												<row><entry><symbol>First</symbol></entry><entry>Moves
														  the current position of the cursor before the first row in the result set.
														  <symbol>BOF</symbol> will always be true after a call to
														  <symbol>First</symbol>.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Bookmarkable"> 
						  <title><indexterm><primary>Bookmarkable</primary></indexterm>Bookmarkable</title>
						  
						  <para>Bookmarkable indicates that the cursor supports
								navigation and location through the use of bookmarks. A bookmark is a system
								provided value which is like a handle to a specific position in the cursor. If
								a cursor supports bookmarks, these methods can be used to remember certain
								locations within a cursor, and return to them later. A bookmark is only valid
								for the cursor from which it was requested. All bookmarks are invalidated when
								the cursor closes. All bookmarks requested through the GetBookmark method must
								be disposed using the DisposeBookmark call.</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>GetBookmark</symbol></entry><entry>Retrieves
														  a bookmark for the current position of the cursor which can be used in
														  subsequent calls to other Bookmarkable methods for the same cursor. A bookmark
														  obtained with <symbol>GetBookmark</symbol> must be released with a call to one
														  of the <symbol>DisposeBookmark</symbol> methods.</entry> 
												</row> 
												<row><entry><symbol>GotoBookmark</symbol></entry><entry>Moves
														  the current position of the cursor to the row identified by the given bookmark.
														  The bookmark must have been obtained from a previous call to
														  <symbol>GetBookmark</symbol> for this cursor.</entry> 
												</row> 
												<row><entry><symbol>CompareBookmarks</symbol></entry><entry>Compares
														  two bookmarks and returns an integer value indicating the relative order of the
														  bookmarks. If the first bookmark is less than the second, a -1 is returned. If
														  the first bookmark is equal to the second, a 0 is returned. Otherwise, a 1 is
														  returned. Both bookmarks must have been obtained from previous calls to
														  <symbol>GetBookmark</symbol> for this cursor.</entry> 
												</row> 
												<row><entry><symbol>DisposeBookmark</symbol></entry><entry>Releases
														  the given bookmark. The bookmark must have been obtained from a previous call
														  to <symbol>GetBookmark</symbol> for this cursor.</entry> 
												</row> 
												<row><entry><symbol>DisposeBookmarks</symbol></entry><entry>Releases
														  each of the given bookmarks. All the bookmarks must have been obtained from
														  previous calls to <symbol>GetBookmark</symbol> for this cursor.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Searchable"> 
						  <title><indexterm><primary>Searchable</primary></indexterm>Searchable</title>
						  
						  <para>Searchable indicates that the cursor supports
								searching based on the order of the rows within the result set. Searching must
								be done on a subset (not necessarily proper) of the columns that were used to
								order the result set.</para> 
						  <para>The following methods are included in the Searchable
								category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>Order</symbol></entry><entry>Exposes
														  the <symbol>Alphora.Dataphor.DAE.Schema.Order</symbol> instance used to
														  describe the order of the rows in the result set.</entry> 
												</row> 
												<row><entry><symbol>GetKey</symbol></entry><entry>Returns
														  an instance of the class <symbol>Alphora.Dataphor.DAE.Runtime.Data.Row</symbol>
														  which contains values for each of the columns in the order key for the current
														  row in the cursor. It is an error to request a key if either
														  <symbol>BOF</symbol> or <symbol>EOF</symbol> is true.</entry> 
												</row> 
												<row><entry><symbol>FindKey</symbol></entry><entry>Attempts
														  to position the cursor on the row matching the values in the given
														  <symbol>Row</symbol>. Returns true if a matching row was found, and false
														  otherwise.</entry> 
												</row> 
												<row><entry><symbol>FindNearest</symbol></entry><entry>Positions
														  the cursor on the row most closely matching the values in the given
														  <symbol>Row</symbol>.</entry> 
												</row> 
												<row><entry><symbol>Refresh</symbol></entry><entry>Refreshes
														  the cursor by requerying for the underlying result set. If a row is given,
														  attempts to position the cursor on that row, otherwise, attempts to maintain
														  the current position of the cursor in the result set.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Updatable"> 
						  <title><indexterm><primary>Updatable</primary></indexterm>Updatable</title>
						  
						  <para>Updatable indicates that the cursor is not readonly,
								i.e. data can be updated through the cursor. Whether or not the updates are
								visible through the cursor, and the position of the cursor after the updates
								are performed, is determined by the Cursor Type behavior.</para> 
						  <para>The following methods are included in the Updateable
								category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>Insert</symbol></entry><entry>Inserts
														  the given row into the database through the cursor. This has the same effect as
														  attempting to insert the row into a view defined by the expression used to
														  generate the result set for the cursor.</entry> 
												</row> 
												<row><entry><symbol>Update</symbol></entry><entry>Updates
														  the columns in the current row of the cursor to the values in the given row
														  through the cursor. This has the same effect as attempting to update a view
														  defined by the expression used to generate the result set for the cursor and
														  restricted to the current row in the cursor.</entry> 
												</row> 
												<row><entry><symbol>Delete</symbol></entry><entry>Deletes
														  the current row of the cursor. This has the same effect as attempting to delete
														  the row from a view defined by the expression used to generate the result set
														  for the cursor and restricted to the current row in the cursor.</entry> 
												</row> 
												<row><entry><symbol>Default</symbol></entry><entry>Requests
														  the default values for columns in the result set for the cursor.</entry> 
												</row> 
												<row><entry><symbol>Change</symbol></entry><entry>Requests
														  the effect of the given change to the columns of the current row of the result
														  set for the cursor.</entry> 
												</row> 
												<row><entry><symbol>Validate</symbol></entry><entry>Validates
														  the values in columns of the given row based on the columns of the result set
														  for the cursor.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Truncatable"> 
						  <title><indexterm><primary>Truncatable</primary></indexterm>Truncatable</title>
						  
						  <para>Truncatable indicates that the result set may be
								completely deleted with a single call.</para> 
						  <para>The following methods are included in the
								Truncateable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>Truncate</symbol></entry><entry>Deletes
														  all the rows in the cursor.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Countable"> 
						  <title><indexterm><primary>Countable</primary></indexterm>Countable</title>
						  
						  <para>Countable indicates that the cursor supports counting
								of the rows in the result set. Note that the result of counting the rows in the
								result set depends on the type of the cursor. Repeated invocations may not
								return the same result.</para> 
						  <para>The following methods are included in the Countable
								category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>RowCount</symbol></entry><entry>Returns
														  the number of rows in the result set. The results of this method are not
														  guaranteed to be an accurate reflection of the current state of the database.
														  If an accurate count is desired, use an aggregate query.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Elaborable"> 
						  <title><indexterm><primary>Elaborable</primary></indexterm>Elaborable</title>
						  
						  <para>Elaborable indicates that the cursor descriptor
								contains enough information about how the table described by the cursor is
								related to the other tables in the catalog to perform query elaboration.</para>
						  
						  <para>The Elaborable category of behavior does not include
								any methods exposed on the cursor interfaces.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2CursorIsolation"> 
					 <title><indexterm><primary>Cursor
									 Isolation</primary></indexterm>Cursor Isolation</title> 
					 <para>The isolation of a cursor determines how the cursor runs
						  with respect to other active transactions in the system. The settings for this
						  behavior correspond roughly to the isolation levels available for transaction
						  processing.</para> 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Method</entry><entry>Description</entry>
										  
									 </row></thead><tbody> 
									 <row><entry>None</entry><entry>Indicates that the
												cursor runs at the isolation level of the current transaction.</entry> 
									 </row> 
									 <row><entry>Chaos</entry><entry>Indicates that the
												cursor does not lock data that it writes, and reads uncommitted data from other
												transactions. Only system processes are allowed to use this isolation
												level.</entry> 
									 </row> 
									 <row><entry>Browse</entry><entry>Indicates that the
												cursor locks data that it writes, but may read uncommitted data from other
												transactions.</entry> 
									 </row> 
									 <row><entry>Cursor
												Stability</entry><entry>Indicates that the cursor locks data that it writes,
												and reads only committed data from other transactions.</entry> 
									 </row> 
									 <row><entry>Isolated</entry><entry>Indicates that
												the cursor runs completely isolated from other transactions.</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable> 
				</sect2> 
				<sect2 id="DDGP2CursorType"> 
					 <title><indexterm><primary>Cursor
									 Type</primary></indexterm>Cursor Type</title> 
					 <para>The type of a cursor determines how the cursor is
						  materialized and how it behaves with respect to updates being made through the
						  cursor, and by other users of the system.</para> 
					 <sect3 id="DDGP2Static"> 
						  <title><indexterm><primary>Cusor Type
										  Static</primary></indexterm>Static</title> 
						  <para>Indicates that the cursor is insensitive to updates
								made to the result set after the cursor has been opened.</para> 
						  <para>In a static cursor, updates made to rows in the
								result set, either by the user of the cursor, or updates that become visible
								based on the isolation level of the cursor from other transactions, are not
								visible. The result set is fully materialized on open, and no changes are made
								to the this set. Of course, calling Reset or Refresh will repopulate the cursor
								with the current data in the system.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Dynamic"> 
						  <title><indexterm><primary>Cursor Type
										  Dynamic</primary></indexterm>Dynamic</title> 
						  <para>Indicates that the cursor is sensitive to updates
								made to rows in the result set after the cursor has been opened.</para> 
						  <para>In a dynamic cursor, updates made to rows in the
								result set, either by the user of the cursor, or from other transactions that
								become visible based on the isolation level of the cursor, are visible through
								the cursor. The result set is dynamically queried for as it is requested. Note
								that this is not a guarantee that updates made by other transactions will be
								visible, only that the system is not required to exclude them. Depending on how
								the query is processed, and how the devices performing the processing
								manipulate the rows in the result set, external updates may or may not be
								visible. However, a dynamic cursor does guarantee that updates made through the
								cursor are visible.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Localvs.RemoteCursors"> 
					 <title><indexterm><primary>Local versus Remote
									 Cursors</primary></indexterm>Local vs. Remote Cursors</title> 
					 <para>The divergence between local and remote functionality is
						  also apparent at the cursor level of the server architecture, and is
						  implemented by two separate classes. The local server cursor is implemented by
						  the class <symbol>Alphora.Dataphor.DAE.Server.ServerCursor</symbol>. The remote
						  server cursor is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Server.RemoteServerCursor</symbol>.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGP1CallLevelInterface"> 
		  <title><indexterm><primary>Call Level
						  Interface</primary></indexterm>Call Level Interface</title> 
		  <para>All access to the DAE is performed through the Call-Level
				Interface (CLI). This is a set of interfaces and data structures that provide
				access to all of the exposed functionality of the DAE. The CLI closely follows
				the layers described in the Server Architecture chapter, exposing the
				functionality at each layer through a set of interfaces. In general, each level
				has a base interface which describes the functionality common to both local and
				remote access, and an interface for exposing both the local and remote access
				functionality.</para> 
		  <para>When accessing the CLI out-of-process, a hierarchy of classes is
				used to wrap the remote access interfaces and expose them through the normal,
				in-process interfaces. This set of classes also implements several data access
				optimizations transparently to the user of the CLI. For this reason, the remote
				access interfaces should never be accessed directly, always use the in-process
				interfaces to access the DAE.</para> 
		  <sect1 id="DDGCLIServer"> 
				<title><indexterm><primary>CLI
								Server</primary></indexterm>Server</title> 
				<para>Communication with the DAE begins when a client establishes
					 connection with the DAE instance (or server). Once server-level communications
					 are established, the client can manipulate the server or retrieve a Session
					 object (or handle) under which other operations are performed.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServer</symbol> and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServer</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.Server</symbol> provides an implementation
					 for all three interfaces. The class
					 <symbol>Alphora.Dataphor.DAE.LocalServer</symbol> provides an implementation
					 for the <symbol>IServer</symbol> interface.</para> 
				<sect2 id="DDGCLIFactory"> 
					 <title><indexterm><primary>Server
									 Factory</primary></indexterm>Server Factory</title> 
					 <para>Connection to, and registration of, DAE servers is
						  performed through the
						  <symbol>Alphora.Dataphor.DAE.Server.ServerFactory</symbol> class. Connection is
						  performed by specifying a DAE server Uniform Resource Identifier (URI) string
						  as an argument to the <symbol>Connect</symbol> static method of the
						  <symbol>ServerFactory</symbol> class. The server URI is a string formatted as
						  follows: &lt;scheme&gt;://&lt;host&gt;[:&lt;port&gt;]/&lt;server name&gt; 
						  <informaltable> 
								<tgroup cols="2">
									 <colspec colwidth="*" colname="col1" colnum="1"/>
									 <colspec colwidth="*" colname="col2" colnum="2"/> 
									 <thead> 
										  <row> 
												<entry colname="col1"> 
													 <para>Part</para> </entry> 
												<entry colname="col2"> 
													 <para>Description</para> </entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1"> 
													 <para>scheme</para> </entry> 
												<entry colname="col2"> 
													 <para>Specifies the communication
														  mechanism used to establish connectivity with the DAE server. This can be a
														  .NET remoting channel name (e.g. "tcp") or it can be the reserved value
														  "factory". The "factory" identifies a server in the same process as the
														  <symbol>ServerFactory</symbol>.</para> </entry> 
										  </row> 
										  <row> 
												<entry colname="col1"> 
													 <para>host</para> </entry> 
												<entry colname="col2"> 
													 <para>A host name or address that is
														  appropriate for the given scheme. The <symbol>TcpChannel</symbol> ("tcp"
														  scheme) expects this to be a valid domain name or an IP address. The "factory"
														  scheme expects this to always be "localhost".</para> </entry> 
										  </row> 
										  <row> 
												<entry colname="col1"> 
													 <para>port</para> </entry> 
												<entry colname="col2"> 
													 <para>The port is an optional port
														  specifier for communications. This is used, for example, by the
														  <symbol>TcpChannel</symbol> ("tcp" scheme) to specify the TCP port.</para>
													 </entry> 
										  </row> 
										  <row> 
												<entry colname="col1"> 
													 <para>server name</para> </entry> 
												<entry colname="col2"> 
													 <para>Specifies the server name as it
														  was registered by the <symbol>ServerFactory</symbol>.</para> </entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable> </para> 
				</sect2> 
				<sect2 id="DDGCLIInProcess"> 
					 <title><indexterm><primary>In-process versus
									 out-of-process</primary></indexterm>In-process versus out-of-process
						  usage</title> 
					 <para> The root CLI object returned by the
						  <symbol>ServerFactory</symbol> is an <symbol>IServer</symbol> interface, which
						  is implemented by either the <symbol>LocalServer</symbol> or
						  <symbol>Server</symbol> class depending on whether access is being performed
						  remotely (cross-process) or locally (in-process). Either way, access to the DAE
						  is available through the same CLI interfaces.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGCLIProcessAndSession"> 
				<title><indexterm><primary>Session</primary></indexterm>Session</title>
				
				<para>This level of the CLI represents a channel for communication
					 with a DAE instance. User authentication and session level configuration is
					 performed at this level. A given DAE instance may have any number of active
					 sessions at a time, and a given user may connect any number of times. The
					 Session also provides functionality for starting and stopping processes in the
					 DAE.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerSessionBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerSession</symbol>, and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerSession</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerSession</symbol> provides an
					 implementation for all three interfaces. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalSession</symbol> provides an
					 implementation for the <symbol>IServerSession</symbol> interface.</para> 
		  </sect1> 
		  <sect1 id="DDGP2Process"> 
				<title><indexterm><primary>Process</primary></indexterm>Process</title>
				
				<para>This level of the CLI represents a running process in the
					 DAE. Transaction management is tied to this level, so while a session can have
					 any number of active processes, a process can only be executing one batch at a
					 time. The process manages all the state of a runtime execution thread in the
					 DAE. The process exposes functionality for managing database, distributed, and
					 application transactions, as well as for preparing and executing statements and
					 batches against the DAE.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerProcessBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerProcess</symbol>, and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerProcess</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerProcess</symbol> provides an
					 implementation for all three interfaces. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalProcess</symbol> provides an
					 implementation for the <symbol>IServerProcess</symbol> interface.</para> 
		  </sect1> 
		  <sect1 id="DDGCLIPlans"> 
				<title><indexterm><primary>Plan</primary></indexterm>Plan</title> 
				<para>This level of the CLI represents a compiled plan that is
					 ready for execution on a process in the DAE. The process exposes methods to
					 prepare scripts, statements, and expressions. Preparing a statement or
					 expression is accomplished in several steps which are described in detail
					 later. </para> 
				<para>There are two types of plans, Statement plans and Expression
					 plans. Statement plans represent the execution of a single statement where
					 there is no result, such as an Insert, Update, Delete, or statement block, or
					 where no result is desired. Expression plans represent the execution of a
					 single expression returning a result set. This may be a select statement, or
					 simply a table expression. The select keyword is used by the CLI when
					 processing scripts to determine whether a given batch is an expression, it is
					 not required to prepare an expression. For example, the expressions "select
					 Employee" and "Employee" would both be valid arguments to the PrepareExpression
					 methods.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerPlanBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerPlan</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerStatementPlan</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerExpressionPlan</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerPlan</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerStatementPlan</symbol>, and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerExpressionPlan</symbol> are the
					 interfaces implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerPlanBase</symbol> provides an
					 implementation for the <symbol>IServerPlanBase</symbol> interface. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerPlan</symbol> provides an
					 implementation for the <symbol>IServerPlan</symbol> interface. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerStatementPlan</symbol> provides an
					 implementation for the <symbol>IServerStatementPlan</symbol> interface. The
					 class <symbol>Alphora.Dataphor.DAE.Server.ServerExpressionPlan</symbol>
					 provides an implementation for the <symbol>IServerExpressionPlan</symbol>
					 interface. The class
					 <symbol>Alphora.Dataphor.DAE.Server.RemoteServerPlan</symbol> provides an
					 implementation for the interface <symbol>IRemoteServerPlan</symbol>. The class
					 <symbol>Alphora.Dataphor.DAE.Server.RemoteServerStatementPlan</symbol> provides
					 an interface for the interface <symbol>IRemoteServerStatementPlan</symbol>. The
					 class <symbol>Alphora.Dataphor.DAE.Server.RemoteServerExpressionPlan</symbol>
					 provides an implementation for the interface
					 <symbol>IRemoteServerExpressionPlan</symbol>. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalPlan</symbol> provides an
					 implementation for the interfaces <symbol>IServerPlanBase</symbol> and
					 <symbol>IServerPlan</symbol>. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalStatementPlan</symbol> provides an
					 implementation for the interface <symbol>IServerStatementPlan</symbol>. The
					 class <symbol>Alphora.Dataphor.DAE.Server.LocalExpressionPlan</symbol> provides
					 an implementation for the interface
					 <symbol>IServerExpressionPlan</symbol>.</para> 
		  </sect1> 
		  <sect1 id="DDGCLICursors"> 
				<title><indexterm><primary>Cursor</primary></indexterm>Cursor</title>
				
				<para>This level of the CLI represents an active cursor executing
					 in the DAE. The cursor provides functionality for navigation, manipulation, and
					 retrieval of data in the DAE. The Cursor also exposes functionality for
					 discovering the capabilities and behaviors of the cursor.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerCursorBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerCursor</symbol> and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerCursor</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerCursorBase</symbol> provides an
					 implementation for the interface <symbol>IServerCursorBase</symbol>. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerCursor</symbol> provides an
					 implementation for the interface <symbol>IServerCursor</symbol>. The class
					 <symbol>Alphora.Dataphor.DAE.Server.RemoteServerCursor</symbol> provides an
					 implementation for the interface <symbol>IRemoteServerCursor</symbol>. The
					 class <symbol>Alphora.Datpahor.DAE.Server.LocalCursor</symbol> provides an
					 implementation for the interface <symbol>IServerCursor</symbol>.</para> 
		  </sect1> 
		  <sect1 id="DDGCLIScripts"> 
				<title><indexterm><primary>Script</primary></indexterm>Script</title>
				
				<para>Represents a prepared script, ready for execution in the DAE.
					 A script consists of a set of batches, each of which may either be a statement
					 or expression. A script is parsed only, not compiled. Each batch of a script is
					 compiled separately and executed. In this way the effects of a batch on the DAE
					 will be visible in subsequent batches.</para> 
				<para>Scripts are processed by first parsing the entire script,
					 then returning each top-level statement as a batch. Each batch can then be
					 executed sequentially. If a batch contains a select statement, it may also be
					 opened as an expression.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerScriptBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerScript</symbol>, and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerScript</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerScript</symbol> provides an
					 implementation for all three interfaces. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalScript</symbol> provides an
					 implementation for the interface <symbol>IServerScript</symbol>.</para> 
		  </sect1> 
		  <sect1 id="DDGP2Batch"> 
				<title><indexterm><primary>Batch</primary></indexterm>Batch</title>
				
				<para>Represents a prepared statement or expression within a
					 prepared script. Provides functionality for executing the batch, or for opening
					 a cursor if it is an expression.</para> 
				<para><symbol>Alphora.Dataphor.DAE.IServerBatchBase</symbol>,
					 <symbol>Alphora.Dataphor.DAE.IServerBatch</symbol>, and
					 <symbol>Alphora.Dataphor.DAE.IRemoteServerBatch</symbol> are the interfaces
					 implementing this level of the CLI. The class
					 <symbol>Alphora.Dataphor.DAE.Server.ServerBatch</symbol> provides an
					 implementation for all three interfaces. The class
					 <symbol>Alphora.Dataphor.DAE.Server.LocalBatch</symbol> provides an
					 implementation for the interface <symbol>IServerBatch</symbol>.</para> 
		  </sect1> 
		  <sect1 id="DDGCLICaching"> 
				<title><indexterm><primary>Caching</primary></indexterm>Caching</title>
				
				<para>When connecting to a DAE instance in another process, the CLI
					 optimizes access by caching data and schema. These optimizations are
					 transparently implemented by the <symbol>LocalXXX</symbol> classes that consume
					 the remote CLI interfaces and expose the functionality through the normal,
					 in-process CLI interfaces.</para> 
				<sect2 id="DDGP2SchemaCaching"> 
					 <title><indexterm><primary>Schema
									 Caching</primary></indexterm>Schema Caching</title> 
					 <para>The description of the structure of a result set is
						  contained in the plan catalog of the prepared expression. When connecting to a
						  DAE in-process, the structures in the descriptor area can be directly accessed
						  by reference. When connecting to a DAE out-of-process, however, these
						  structures must be serialized, transported accross the remoting boundary, and
						  deserialized into the calling process. The CLI maintains a cache of these
						  objects as they are deserialized, and only requests the objects that are
						  required to describe the result set, thus minimizing the amount of schema
						  information that is sent over the wire during a session with the DAE.</para> 
					 <para>This cache is maintained transparently to the developer
						  using a catalog timestamp in the DAE. Whenever a change is made to a catalog
						  structure in the DAE that could affect existing cached structures, this
						  timestamp is reset by the DAE. When the session detects that it's cache is out
						  of date, it flushes it's cache and begins requesting new structure from that
						  point.</para> 
				</sect2> 
				<sect2 id="DDGP2DataCaching"> 
					 <title><indexterm><primary>Data
									 Caching</primary></indexterm>Data Caching</title> 
					 <para>When retrieving data from an out-of-process DAE, the CLI
						  uses data caching to ensure that the data is copied a minimal number of times.
						  </para> 
					 <para>One way this caching occurs is by fetching rows into a
						  prefetch buffer maintained in the CLI. When rows are requested by the user of
						  the CLI, the prefetch buffer is checked first, and only if the user has moved
						  outside the buffer is data actually requested from the out-of-process DAE.
						  Additionally, the rows are requested as a single batch to minimize network
						  traffic. The size of this prefetch buffer can be set using the FetchCount
						  property in the SessionInfo used to connect to the DAE.</para> 
					 <para>Another cache point for data in the CLI is in the
						  retrieval of overflow values. (For a complete discussion of how the DAE handles
						  overflow using streams, refer to the Streams Architecture section of the
						  Runtime Architecture chapter.) When overflow is requested by a user of the CLI
						  connected to an out-of-process DAE, the data is downloaded as it is read, and
						  cached locally to prevent re-reading the same information. When data in this
						  stream is changed, the changes are not transmitted to the out-of-process DAE
						  until the row is ready for updating. This allows for efficient access to large
						  overflow streams through the DAE.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGPhysicalCatalog"> 
		  <title><indexterm><primary>System Catalog</primary></indexterm>System
				Catalog</title> 
		  <para>The DAE catalog is implemented using a hierarchy of classes in
				the <symbol>Alphora.Dataphor.DAE.Schema</symbol> namespace.</para> 
		  <sect1 id="DDGSchemaObjects"> 
				<title><indexterm><primary>Schema
								Objects</primary></indexterm>Schema Objects</title> 
				<para>Schema objects all descend from the base class
					 <symbol>Alphora.Dataphor.DAE.Schema.Object</symbol>. This class provides
					 identity services, puts the foundation in place for dependency tracking, and
					 stores metadata.</para> 
				<sect2 id="DDGP2Identity"> 
					 <title><indexterm><primary>Identity</primary></indexterm>Identity</title>
					 
					 <para>Objects in the catalog are identified using two distinct
						  mechanisms. First, they all have a name, which is given to the object when it
						  is created. Second, they all have an ID, which is a GUID that is either
						  assigned or generated on creation. Neither of these identifiers can be changed
						  for the object.</para> 
					 <para>The name of an object in the catalog must be a valid
						  qualified identifier, defined by: 
						  <programlisting>&lt;identifier&gt; ::= 
	(_ | &lt;letter&gt;){_ | &lt;letter&gt; | &lt;digit&gt;}

&lt;name&gt; ::=
	{&lt;identifier&gt;.}&lt;identifier&gt;

&lt;qualified identifier&gt; ::=
	[.]&lt;name&gt;</programlisting></para> 
					 <para>In addition, a valid identifier must not be a reserved
						  word in the D4 language. A name can be qualified with any number of namespaces,
						  which are used to provide distinct identifier spaces within the same database.
						  The optional prefix dot is used to indicate that the specified name is
						  complete. This tells the compiler to use standard comparison, rather than name
						  equivalence, to determine equality, and also indicates that no default
						  namespacing should be used.</para> 
					 <sect3 id="DDGP2NameResolution"> 
						  <title><indexterm><primary>Name
										  Resolution</primary></indexterm>Name Resolution</title> 
						  <para>Name resolution is the process of using a name to
								look up an object in the catalog. This process uses the notion of equivalence
								among names to determine which object is being referenced. A given name is
								equivalent to another name if and only if it is equal, case-sensitively, to
								some unqualified version of the name. Thus: 
								<itemizedlist> 
									 <listitem> 
										  <para><symbol>A</symbol> is equivalent to
												<symbol>A</symbol></para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>A</symbol> is equivalent to
												<symbol>A.A</symbol> and <symbol>B.A</symbol>, but not
												<symbol>A.B</symbol></para> 
									 </listitem> 
									 <listitem> 
										  <para><symbol>A.A</symbol> is equivalent to
												<symbol>A.A</symbol>, but not <symbol>B.A</symbol></para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>When resolving a name reference against a list of
								names, the reference is compared with each name in the list. If the reference
								is equivalent to more than one name in the list, the reference is considered
								ambiguous, and no resolution can occur. In the second example, the reference
								identifier A is ambiguous, and would be considered unresolvable. In any given
								list of names, such as the catalog, no two names are allowed to be equivalent
								to each other. This prevents unresolvable names from appearing in the
								catalog.</para> 
					 </sect3> 
					 <sect3 id="DDGP2DefaultNamespace"> 
						  <title><indexterm><primary>Default
										  Namespace</primary></indexterm>Default Namespace</title> 
						  <para>Each session has a configuration option called
								<symbol>DefaultNamespace</symbol>. This namespace is used by the compiler
								during name resolution to disambiguate references to items in the catalog.
								First, the compiler attempts to resolve the identifier normally. If no match is
								found, or the reference is ambiguous, the compiler will prepend the reference
								with the default namespace for the session, if one is set, and attempt to
								resolve with the new name. This allows users to operate within a given
								namespace without having to qualify completely the names of the catalog objects
								they are referencing. The default namespace is also prepended to the names of
								any objects created in the session. Both of these behaviors can be circumvented
								by using the prefix dot notation in the name reference.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Dependency"> 
					 <title><indexterm><primary>Dependency</primary></indexterm>Dependency</title>
					 
					 <para>Every object in the catalog is capable of tracking
						  dependencies, or the objects it depends on, as well as dependents, or the
						  objects that depend on it. This information is used to ensure the consistency
						  of the catalog by restricting the changes that can be made to objects that have
						  dependents. Dependency information is also used when persisting the catalog to
						  ensure that objects are created in the correct order, and that all the
						  dependencies required for a particular object exist.</para> 
				</sect2> 
				<sect2 id="DDGP2Metadata"> 
					 <title><indexterm><primary>Metadata</primary></indexterm>Metadata</title>
					 
					 <para>Every object in the catalog is capable of storing
						  additional user-defined information called metadata. This information is an
						  inherent part of the object, and is inferred through expressions of D4.
						  Metadata consists of any number of tags, plus an optional comment string. A
						  metadata tag is a named string value. Tag names follow the rules for object
						  names in D4. Metadata is implemented using several classes in the
						  <symbol>Alphora.Dataphor.DAE.Language.D4</symbol> namespace. The main metadata
						  container is the <symbol>MetaData</symbol> class, which has a
						  <symbol>Comment</symbol> string, and a <symbol>Tags</symbol> list containing
						  <symbol>Tag</symbol> instances.</para> 
				</sect2> 
				<sect2 id="DDGP2Remotability"> 
					 <title><indexterm><primary>Remotability</primary></indexterm>Remotability</title>
					 
					 <para>Every object in the catalog is either remotable, or
						  non-remotable. This is exposed by the <symbol>IsRemotable</symbol> property on
						  the <symbol>Object</symbol> class and determines how the object should behave
						  with respect to out-of-process access through the CLI. If a given object is
						  remotable, it may be referenced in the remote process. Following is a list of
						  remotability rules for the different types of objects in the catalog:</para> 
					 <para> 
						  <itemizedlist> 
								<listitem> 
									 <para>Domains are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Constraints are remotable if all their
										  dependencies are remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Defaults are remotable if all their
										  dependencies are remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Columns are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>RowTypes are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>TableTypes are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>ListTypes are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>CursorTypes are not remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Representations are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Properties are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Specials are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Orders are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>OrderColumns are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>References are not remotable</para> 
								</listitem> 
								<listitem> 
									 <para>TableVars are not remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Operands are always remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Operators are remotable if all their
										  dependencies are remotable</para> 
								</listitem> 
								<listitem> 
									 <para>Devices are not remotable</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>These remotability rules allow the system to make
						  optimization decisions when handling proposable events in the CLI. For example,
						  if the default for a particular column is remotable, the default may be
						  evaluated remotely, preventing the need for a network round trip. In general,
						  any reference to the data in the database is not remotable.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2ClassDefinitions"> 
				<title><indexterm><primary>Class
								Definitions</primary></indexterm>Class Definitions</title> 
				<para>Class definitions provide the tie between the logical model
					 described in D4, and the actual implementation of that model in the DAE. A
					 class definition is a description of a host language class that is used to
					 implement some specific set of functionality in the physical model. For
					 example, the phsyical encoding for the values of a given scalar type is done
					 using some descendent of the class
					 <symbol>Alphora.Dataphor.DAE.Streams.Conveyor</symbol>. This class is described
					 by the <symbol>Conveyor</symbol> property of the scalar type.</para> 
				<para>A class definition is a simple form of object persistence.
					 Each class definition consists of the name of the class being described, and a
					 list of name-value pairs of strings called attributes. These attributes
					 correspond to properties of the class being described, and the value to which
					 the property should be set when an instance of the class is created.</para> 
				<para>Class definitions are represented by the class
					 <symbol>Alphora.Dataphor.DAE.Language.D4.ClassDefinition</symbol>. Attributes
					 are represented by the class
					 <symbol>Alphora.Dataphor.DAE.Language.D4.ClassAttributeDefinition</symbol>.</para>
				
		  </sect1> 
		  <sect1 id="DDGP2DataTypes"> 
				<title><indexterm><primary>Data Types</primary></indexterm>Data
					 Types</title> 
				<para>The classes which implement data type support in the DAE all
					 descend from the abstract base class
					 <symbol>Alphora.Dataphor.DAE.Schema.DataType</symbol>. This class introduces
					 the concepts of type equality, type testing, and type compatibility.</para> 
				<para> 
					 <variablelist> 
						  <varlistentry> 
								<term>Type Equality</term> 
								<listitem> 
									 <para>A given type T<subscript>1</subscript> is
										  equal to a type T<subscript>2</subscript> if and only if it is the same type.
										  </para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Type Testing</term> 
								<listitem> 
									 <para>A given type T<subscript>1</subscript>
										  <symbol>is</symbol> of type T<subscript>2</subscript> if and only if it is a
										  subtype, not necessarily proper, of type T<subscript>2</subscript>. </para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Type Compatibility</term> 
								<listitem> 
									 <para>A given type T<subscript>1</subscript> is
										  compatible with type T<subscript>2</subscript> if T<subscript>1</subscript>
										  <symbol>is</symbol> T<subscript>2</subscript> or T<subscript>2</subscript>
										  <symbol>is</symbol> T<subscript>1</subscript>. In other words, if there exists
										  a type T<subscript>3</subscript> that is a supertype of both
										  T<subscript>1</subscript> and T<subscript>2</subscript>.</para> 
								</listitem> 
						  </varlistentry> 
					 </variablelist></para> 
				<sect2 id="DDGP2GenericType"> 
					 <title><indexterm><primary>Generic
									 Types</primary></indexterm>Generic Type</title> 
					 <para>The generic type is represented in the DAE by an instance
						  of the class <symbol>Alphora.Dataphor.DAE.Schema.GenericType</symbol>. This
						  class also implements the functionality of the generic type.</para> 
				</sect2> 
				<sect2 id="DDGP2Domains"> 
					 <title><indexterm><primary>Domains</primary></indexterm>Domains</title>
					 
					 <para>All scalar types (domains) are represented in the DAE
						  using instances of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.ScalarType</symbol>. This class provides
						  all the properties and behaviors necessary to represent a scalar type in the
						  DAE.</para> 
					 <sect3 id="DDGP2Representations"> 
						  <title><indexterm><primary>Representations</primary></indexterm>Representations</title>
						  
						  <para>Each scalar type has exactly one physical
								representation, and any number of possible, or logical, representations. These
								representations provide different views of the same set of values. The physical
								representation is only available within the physical implementation of the DAE,
								there is no way to access the physical representation of a data type through
								D4. Each possible representation has an associated selector, and a read and
								write accessor for each property of the representation. These special purpose
								operators are required to be host-implemented, and are the only operators that
								can access the physical representation of the scalar type.</para> 
						  <sect4 id="DDGP2Conveyors"> 
								<title><indexterm><primary>Conveyors</primary></indexterm>Conveyors</title>
								
								<para>The physical representation of the scalar type is
									 the actual byte encoding for values of the type. This representation is
									 implemented using an instance of some descendent of the class
									 <symbol>Alphora.Dataphor.DAE.Streams.Conveyor</symbol>, which is described by
									 the <symbol>Conveyor</symbol> property of the <symbol>ScalarType</symbol>
									 class. Physical representations are discussed in detail in the values section
									 of the Runtime Architecture chapter.</para> 
								<para>If a conveyor is not specified as part of the
									 definition of the type, the following steps are taken to find an appropriate
									 conveyor. 
									 <orderedlist> 
										  <listitem> 
												<para>If the type has one immediate
													 supertype which has a conveyor defined, use that conveyor.</para> 
										  </listitem> 
										  <listitem> 
												<para>Select an arbitrary representation of
													 the type, and construct a conveyor to be used, if possible.</para> 
										  </listitem> 
									 </orderedlist></para> 
								<para>The system will select the best representation to
									 use to construct a conveyor. If the system cannot provide a conveyor for the
									 type, an error occurs.</para> 
						  </sect4> 
						  <sect4 id="DDGP2PossibleRepresentations"> 
								<title><indexterm><primary>Possible
												Representations</primary></indexterm>Possible Representations</title> 
								<para>Possible representations expose the components of
									 the type to the logical model. Each possible representation has a set of
									 properties, which are named, typed components, and an associated selector,
									 which is responsible for selecting values of the type in terms of the
									 components of the representation. Possible representations are implemented as
									 instances of the class
									 <symbol>Alphora.Dataphor.DAE.Schema.Representation</symbol>. </para> 
								<para>If no possible representations are specified in
									 the definition of the type, the system will attempt to provide a default
									 representation for the type. This representation will be named the unqualified
									 name of the type. It will have a single property named the unqualified name of
									 the type. This property will use the first system type in a single inheritance
									 type graph that uses the same conveyor as this type. This representation will
									 use the default selector and accessors as described in the following
									 sections.</para> 
						  </sect4> 
						  <sect4 id="DDGP2Selectors"> 
								<title><indexterm><primary>Selectors</primary></indexterm>Selectors</title>
								
								<para>Each possible representation has an associated
									 selector operator of the form: 
									 <programlisting>operator &lt;type name&gt;[.&lt;representation name&gt;]
	(const A&lt;property name&gt; : &lt;property type&gt;[, ...]) : &lt;type&gt;</programlisting> The representation name will only be included in the name of
									 the selector operator if it is different than the name of the type. The
									 representation which has the same name as the type is known as the default
									 representation. This operator is required to be host-implemented by a class
									 which descends from
									 <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.InstructionNode</symbol>.
									 This class is described by the property <symbol>Selector</symbol>. The operator
									 takes an argument for each property in the representation.</para> 
								<para>If a selector is not specified as part of the
									 definition of the representation, the system will attempt to provide a default
									 selector for the representation. This selector is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarSelectorNode</symbol>
									 and can only be used if the representation has a single scalar typed property.
									 If no default selector can be provided, an error occurs.</para> 
						  </sect4> 
						  <sect4 id="DDGP2Properties"> 
								<title><indexterm><primary>Properties</primary></indexterm>Properties</title>
								
								<para>Components of possible representations are
									 represented as instances of the class
									 <symbol>Alphora.Dataphor.DAE.Schema.Property</symbol>. Each component has a
									 name, a data type, not necessarily scalar, and two associated operators, a read
									 accessor, and a write accessor, which expose the component in the logical
									 model.</para> 
								<sect5 id="DDGP2ReadAccessors"> 
									 <title><indexterm><primary>Read
													 Accessors</primary></indexterm>Read Accessors</title> 
									 <para>The read accessor operator is of the form: 
										  <programlisting>operator &lt;type name&gt;.Read&lt;property name&gt;
	(const AValue : &lt;type&gt;) : &lt;property type&gt;</programlisting>The operator is required to be host-implemented by a class
										  which descends from
										  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.InstructionNode</symbol>.
										  This class is described by the property <symbol>ReadAccessor</symbol>. The
										  operator takes a single parameter which is a value of the scalar type, and
										  returns a value of the property type that is the value of the property for the
										  representation of the argument.</para> 
									 <para>If no read accessor is specified as part of
										  the definition of the property, the system will attempt to provide a default
										  read accessor. This read accessor is implemented by the class
										  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarReadAccessorNode</symbol>
										  and can only be used if the representation has a single scalar typed property.
										  If no default read accessor can be provided, an error occurs.</para> 
								</sect5> 
								<sect5 id="DDGP2WriteAccessors"> 
									 <title><indexterm><primary>Write
													 Accessors</primary></indexterm>Write Accessors</title> 
									 <para>The write accessor operator is of the form: 
										  <programlisting>operator &lt;type name&gt;.Write&lt;property name&gt;
	(const AValue : &lt;type&gt;, const A&lt;property name&gt; : &lt;property type&gt;) : &lt;type&gt;</programlisting>The operator is required to be host-implemented by a class
										  which descends from
										  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.InstructionNode</symbol>.
										  This class is described by the property <symbol>WriteAccessor</symbol>. The
										  operator takes two parameters, a value of the scalar type, and a value of the
										  property type, and returns a value of the scalar type with the property set to
										  the value of the second argument, and all other properties as currently
										  specified by the first argument.</para> 
									 <para>If no write accessor is specified as part of
										  the definition of the property, the system will attempt to provide a default
										  write accessor. This write accessor is implemented by the class
										  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarWriteAccessorNode</symbol>
										  and can only be used if the representation has a single scalar typed property.
										  If no default write accessor can be provided, an error occurs.</para> 
								</sect5> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2Defaults"> 
						  <title><indexterm><primary>Defaults</primary></indexterm>Defaults</title>
						  
						  <para>Defaults are expressions which return a value of the
								scalar type to be used as the initial value for variables of this type.
								Defaults are implemented by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Default</symbol>.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Constraints"> 
						  <title><indexterm><primary>Constraints</primary></indexterm>Constraints</title>
						  
						  <para>Constraints are named, boolean-valued expressions
								which evaluate to true for all legal values of the scalar type. Constraints are
								implemented by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Constraint</symbol>. The constraint
								expression is required to be both functional and deterministic. The system
								enforces the constraint, so no validation code must be provided by the type
								developer.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Specials"> 
						  <title><indexterm><primary>Specials</primary></indexterm>Specials</title>
						  
						  <para>Specials are named values of the scalar type which
								are singled out as a solution to the problem of missing information. Note that
								a special value is <emphasis>not</emphasis> a null. Special values are values
								of the scalar type for which they are defined. Specials are implemented by the
								class <symbol>Alphora.Dataphor.DAE.Schema.Special</symbol>. The expression
								which defines the scalar value is required to be functional and deterministic.
								Each special has two system supplied operators associated with it, a special
								selector, and a special comparer.</para> 
						  <para>The special selector is an operator of the form: 
								<programlisting>operator &lt;type name&gt;&lt;special name&gt;() : &lt;type&gt;</programlisting>This operator is provided by the system and returns the value
								of the special.</para> 
						  <para>The special comparer is an operator of the form: 
								<programlisting>operator Is&lt;special name&gt;(const AValue : &lt;type&gt;) : boolean</programlisting>This operator is provided by the system and returns true if
								the argument is equal to the value of the special.</para> 
						  <para>Additionally, an operator is provided for all scalar
								types of the form: 
								<programlisting>operator IsSpecial(const AValue : &lt;type&gt;) : boolean</programlisting>This operator is provided by the system and returns true if
								the argument is equal to any special defined for the scalar type. This operator
								is used in the definition of the reference constraint.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ExplicitCastOperators"> 
						  <title><indexterm><primary>Explicit Cast
										  Operators</primary></indexterm>Explicit Cast Operators</title> 
						  <para>Each scalar type is provided with a set of explicit
								cast operators for use in converting values of the supertype to values of the
								subtype. One such operator is provided for each immediate supertype which uses
								the same <symbol>Conveyor</symbol> class. This operator is of the form: 
								<programlisting>operator &lt;type name&gt;(const AValue : &lt;supertype name&gt;) : &lt;type&gt;</programlisting>This operator is provided by the system and is implemented by
								the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.ScalarSelectorNode</symbol>.</para>
						  
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2TableAndRowTypes"> 
					 <title><indexterm><primary>Table and Row
									 Types</primary></indexterm>Table And Row Types</title> 
					 <para>Table and row types are types that are based on a
						  heading, or set of name-type pairs which describe the columns, or user-visible
						  components, of the type. At the logical level, these columns are not ordered,
						  so the definition of equality for these types is based on the names of the
						  columns, rather than their position in the list that implements them. Similarly
						  for the <symbol>is</symbol> of these types, and therefore the compatibility as
						  well. Of course, the columns are in some left to right ordering in the
						  implementation, and this does have implications in the physical model, so the
						  columns list which manages the heading for these types introduces the notion of
						  equivalence, which is defined as equality among the columns in a left to right
						  ordering. This notion is used for optimization purposes in the DAE, and does
						  not affect the logical model.</para> 
					 <sect3 id="DDGP2Columns"> 
						  <title><indexterm><primary>Columns</primary></indexterm>Columns</title>
						  
						  <para>Columns are represented by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Column</symbol>. Columns have a name and a
								data type. Columns are contained by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Columns</symbol> which introduces several
								methods for managing lists of columns, including the notions of column list
								equivalence, and the methods for type testing used by the table and row
								types.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2ListTypes"> 
					 <title><indexterm><primary>List Types</primary></indexterm>List
						  Types</title> 
					 <para>List types are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.ListType</symbol> and simply have a data
						  type property to represent the type of elements the list can contain.</para> 
				</sect2> 
				<sect2 id="DDGP2CursorTypes"> 
					 <title><indexterm><primary>Cursor
									 Types</primary></indexterm>Cursor Types</title> 
					 <para>Cursor types are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.CursorType</symbol>. Cursor types and
						  values are discussed in detail in the section on values in the Runtime
						  Architecture chapter.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Operators"> 
				<title><indexterm><primary>Operators</primary></indexterm>Operators</title>
				
				<para>Operators are represented in the system catalog by instances
					 of the class <symbol>Alphora.Dataphor.DAE.Schema.Operator</symbol>. This class
					 introduces all the behavior and properties to support operator resolution in
					 the DAE.</para> 
				<sect2 id="DDGP2Operands"> 
					 <title><indexterm><primary>Operands</primary></indexterm>Operands</title>
					 
					 <para>Each operator can contain any number of operands.
						  Operands are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Operand</symbol>. An operand has a name, a
						  data type, and a modifier. The modifier is one of the values of the
						  <symbol>Alphora.Dataphor.DAE.Language.Modifier</symbol> enum, and is used to
						  determine how the argument is passed, as well as the updatability of the
						  parameter variable within the operator. 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Modifier</entry><entry>Affect</entry>
												
										  </row></thead><tbody> 
										  <row><entry><symbol>In</symbol></entry><entry>The
													 argument is passed by value.</entry> 
										  </row> 
										  <row><entry><symbol>Var</symbol></entry><entry>The
													 argument is passed by reference, updates are allowed to the parameter variable
													 within the operator body.</entry> 
										  </row> 
										  <row><entry><symbol>Const</symbol></entry><entry>The
													 argument is passed by reference, updates are not allowed to the parameter
													 variable within the operator body.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>If the compiler detects that no updates are made to the
						  parameter variable for a given operand within the body of the operator, it will
						  mark the operand with the <symbol>Const</symbol> modifier as an
						  optimization.</para> 
				</sect2> 
				<sect2 id="DDGP2OperatorBody"> 
					 <title><indexterm><primary>Operator
									 Body</primary></indexterm>Operator Body</title> 
					 <para>Each operator has an operator body which is represented
						  in the catalog by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.OperatorBlock</symbol>. This class will
						  contain either a class definition describing the host language class
						  responsible for implementation of the block, or a compiled plan tree which is
						  the actual instructions to be executed for the operator. An operator which is
						  implemented by a single class described using a class definition, rather than
						  by D4 statements in the operator definition, is called a host-implemented
						  operator. All the system library operators are host-implemented.</para> 
				</sect2> 
				<sect2 id="DDGP2Built-inOperators"> 
					 <title><indexterm><primary>Built-in
									 Operators</primary></indexterm>Built-in Operators</title> 
					 <para>Each operator has a property called
						  <symbol>IsBuiltin</symbol> which will be true if the operator is a symbol
						  recognized by the parser. The following symbols are used for the built-in
						  operators:</para> 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Operator
												Name</entry><entry>Symbol</entry> 
									 </row> 
								</thead> 
								<tbody> 
									 <row><entry><symbol>iAddition</symbol></entry><entry><symbol>+</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iAdorn</symbol></entry><entry><symbol>adorn</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iAggregate</symbol></entry><entry><symbol>group</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iAnd</symbol></entry><entry><symbol>and</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBetween</symbol></entry><entry><symbol>between</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBitwiseAnd</symbol></entry><entry><symbol>&amp;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBitwiseNot</symbol></entry><entry><symbol>~</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBitwiseOr</symbol></entry><entry><symbol>|</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBitwiseXor</symbol></entry><entry><symbol>^</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iBrowse</symbol></entry><entry><symbol>browse</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iCompare</symbol></entry><entry><symbol>?=</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iDifference</symbol></entry><entry><symbol>minus</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iDiv</symbol></entry><entry><symbol>div</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iDivision</symbol></entry><entry><symbol>/</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iEqual</symbol></entry><entry><symbol>=</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iExists</symbol></entry><entry><symbol>exists</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iExplode</symbol></entry><entry><symbol>explode</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iExtend</symbol></entry><entry><symbol>extend</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iGreater</symbol></entry><entry><symbol>&gt;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iIn</symbol></entry><entry><symbol>in</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iInclusiveGreater</symbol></entry><entry><symbol>&gt;=</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iInclusiveLess</symbol></entry><entry><symbol>&lt;=</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iIndexer</symbol></entry><entry><symbol>[]</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iJoin</symbol></entry><entry><symbol>join</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iLeftJoin</symbol></entry><entry><symbol>left
												join</symbol></entry> 
									 </row> 
									 <row><entry><symbol>iLess</symbol></entry><entry><symbol>&lt;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iLike</symbol></entry><entry><symbol>like</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iMatches</symbol></entry><entry><symbol>matches</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iMod</symbol></entry><entry><symbol>mod</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iMultiplication</symbol></entry><entry><symbol>*</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iNegate</symbol></entry><entry><symbol>-</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iNot</symbol></entry><entry><symbol>not</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iNotEqual</symbol></entry><entry><symbol>&lt;&gt;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iOr</symbol></entry><entry><symbol>or</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iOrder</symbol></entry><entry><symbol>order</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iPower</symbol></entry><entry><symbol>**</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iProject</symbol></entry><entry><symbol>over</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iQuota</symbol></entry><entry><symbol>return</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iRedefine</symbol></entry><entry><symbol>redefine</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iRemove</symbol></entry><entry><symbol>remove</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iRename</symbol></entry><entry><symbol>rename</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iRestrict</symbol></entry><entry><symbol>where</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iRightJoin</symbol></entry><entry><symbol>right
												join</symbol></entry> 
									 </row> 
									 <row><entry><symbol>iShiftLeft</symbol></entry><entry><symbol>&lt;&lt;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iShiftRight</symbol></entry><entry><symbol>&gt;&gt;</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iSubtraction</symbol></entry><entry><symbol>-</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iUnion</symbol></entry><entry><symbol>union</symbol></entry>
										  
									 </row> 
									 <row><entry><symbol>iXor</symbol></entry><entry><symbol>xor</symbol></entry>
										  
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable> 
				</sect2> 
				<sect2 id="DDGP2AggregateOperators"> 
					 <title><indexterm><primary>Aggregate
									 Operators</primary></indexterm>Aggregate Operators</title> 
					 <para>Aggregate operators are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.AggregateOperator</symbol>. In addition to
						  the properties and behaviors of a standard operator, the aggregate operator
						  introduces the properties necessary to support the aggregate calling convention
						  in the DAE. This calling convention is discussed in detail in the Runtime
						  Architecture chapter.</para> 
					 <para>Each aggregate operator has three distinct blocks of
						  executable code, each of which is represented by an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.OperatorBlock</symbol>. The three blocks
						  are called the initialization, aggregation, and finalization blocks, and are
						  represented by properties of the same name.</para> 
				</sect2> 
				<sect2 id="DDGP2Signatures"> 
					 <title><indexterm><primary>Signatures</primary></indexterm>Signatures</title>
					 
					 <para>Each operator has a signature which describes the data
						  type and modifier for each parameter of the operator. This signature is
						  implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Signature</symbol>. Signatures must be
						  unique for any given operator name. Each signature contains a list of instances
						  of the class <symbol>SignatureElement</symbol> which describe the properties of
						  each parameter of the signature. Signature equality and signature testing is
						  implemented by these classes according to the following definitions:</para> 
					 <variablelist> 
						  <varlistentry> 
								<term>Signature Element Equality</term> 
								<listitem> 
									 <para>A given signature element
										  E<subscript>1</subscript>, having data type D<subscript>1</subscript> and
										  modifier M<subscript>1</subscript>, is equal to a signature element
										  E<subscript>2</subscript> with data type D<subscript>2</subscript> and modifier
										  M<subscript>2</subscript> if and only if D<subscript>1</subscript> is equal to
										  D<subscript>2</subscript> by the definition of equality for data types, and
										  either M<subscript>1</subscript> and M<subscript>2</subscript> are both
										  <symbol>Var</symbol> or M<subscript>1</subscript> and M<subscript>2</subscript>
										  are both not <symbol>Var</symbol>.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Signature Element Type Testing</term> 
								<listitem> 
									 <para>A given signature element
										  E<subscript>1</subscript>, having data type D<subscript>1</subscript> and
										  modifier M<subscript>1</subscript>, <symbol>is</symbol> of an element
										  E<subscript>2</subscript> with data type D<subscript>2</subscript> and modifier
										  M<subscript>2</subscript> if and only if either M<subscript>1</subscript> and
										  M<subscript>2</subscript> are both <symbol>Var</symbol> and
										  D<subscript>1</subscript> is equal to D<subscript>2</subscript> by the
										  definition of equality for types, or M<subscript>1</subscript> and
										  M<subscript>2</subscript> are both not <symbol>Var</symbol> and
										  D<subscript>1</subscript> <symbol>is</symbol> D<subscript>2</subscript> by the
										  definition of type testing for data types.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Signature Equality</term> 
								<listitem> 
									 <para>A given signature S<subscript>1</subscript>
										  having elements E<subscript>11</subscript>...E<subscript>1n</subscript> is
										  equal to a signature S<subscript>2</subscript> with elements
										  E<subscript>21</subscript>...E<subscript>2n</subscript> if and only if for all
										  k where k = 1...n, E<subscript>1k</subscript> is equal to
										  E<subscript>2k</subscript> by the definition of equality for signature
										  elements.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Signature Type Testing</term> 
								<listitem> 
									 <para>A given signature S<subscript>1</subscript>
										  having elements E<subscript>11</subscript>...E<subscript>1n</subscript>
										  <symbol>is</symbol>of a signature S<subscript>2</subscript> having elements
										  E<subscript>21</subscript>...E<subscript>2n</subscript> if and only if for all
										  k where k = 1...n, E<subscript>1k</subscript> <symbol>is</symbol>
										  E<subscript>2k</subscript> by the definition of type testing for signature
										  elements.</para> 
								</listitem> 
						  </varlistentry> 
					 </variablelist> 
				</sect2> 
				<sect2 id="DDGP2OperatorMaps"> 
					 <title><indexterm><primary>Operator
									 Maps</primary></indexterm>Operator Maps</title> 
					 <para>Each operator name has an associated operator map
						  represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.OperatorMap</symbol> which contains all the
						  signatures for the operator name organized in a lattice based on the definition
						  of type testing for signatures. This structure is used to implement operator
						  resolution for the compiler.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2TableVariables"> 
				<title><indexterm><primary>Table
								Variables</primary></indexterm>Table Variables</title> 
				<para>Table variables in the DAE are represented by instances of
					 some descendent of the abstract base class
					 <symbol>Alphora.Dataphor.DAE.TableVar</symbol>. This class introduces the
					 properties and behaviors common to all table variables in the DAE. There are
					 three types of table variables in the DAE, base, derived, and local. A base
					 table variable is represented by the class
					 <symbol>Alphora.Dataphor.DAE.Schema.BaseTableVar</symbol> and represents base
					 table variables in the logical model. A derived table variable is represented
					 by the class <symbol>Alphora.Dataphor.DAE.Schema.DerivedTableVar</symbol> and
					 represents derived table variables in the logical model, as well as
					 intermediate results obtained from query evaluation. A local table variable is
					 represented by the class <symbol>Alphora.Dataphor.DAE.LocalTableVar</symbol>
					 and is used by the DAE internally to handle arguments of table types.</para> 
				<sect2 id="DDGP2Columns2"> 
					 <title><indexterm><primary>Columns</primary></indexterm>Columns</title>
					 
					 <para>All table variables have a list of columns which describe
						  the attributes which make up the table variable. These columns are represented
						  by the class <symbol>Alphora.Dataphor.DAE.Schema.Column</symbol>.</para> 
					 <sect3 id="DDGP2Defaults2"> 
						  <title><indexterm><primary>Defaults</primary></indexterm>Defaults</title>
						  
						  <para>Each column in a table variable can have an
								associated default. This default is represented by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Default</symbol>.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Constraints2"> 
						  <title><indexterm><primary>Constraints</primary></indexterm>Constraints</title>
						  
						  <para>Each column in a table variable can have any number
								of associated constraints. These constraints are represented by the class
								<symbol>Alphora.Dataphor.DAE.Schema.Constraint</symbol>. The expression for the
								constraint is required to be deterministic.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Keys"> 
					 <title><indexterm><primary>Keys</primary></indexterm>Keys</title>
					 
					 <para>Each table variable can have any number of keys
						  associated with it. These keys are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Key</symbol>. Each key can contain any
						  number of references to the <symbol>Column</symbol> instances in the table
						  variable.</para> 
				</sect2> 
				<sect2 id="DDGP2Orders"> 
					 <title><indexterm><primary>Orders</primary></indexterm>Orders</title>
					 
					 <para>Each table variable can have any number of orders
						  associated with it. These orders are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Order</symbol>. Each order is a list of
						  order columns, which are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.OrderColumn</symbol>. Each order column is
						  a reference to a column of the table variable, and an
						  <symbol>Ascending</symbol> property to indicate whether the order is ascending
						  for the column.</para> 
				</sect2> 
				<sect2 id="DDGP2Constraints3"> 
					 <title><indexterm><primary>Constraints</primary></indexterm>Constraints</title>
					 
					 <para>Each table variable can have any number of constraints
						  associated with it. These constraints are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Constraint</symbol>. The expression for the
						  constraint is required to be deterministic.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Constraints4"> 
				<title><indexterm><primary>Constraints</primary></indexterm>Constraints</title>
				
				<para>All constraints in the system catalog are represented by the
					 class <symbol>Alphora.Dataphor.DAE.Schema.Constraint</symbol>. Constraints have
					 a constraint type which is used to determine which level of constraint is being
					 represented.</para> 
				<para> 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Constraint
												Type</entry><entry>Description</entry> 
									 </row></thead><tbody> 
									 <row><entry>Domain</entry><entry>A constraint used
												to define the legal values for a scalar type.</entry> 
									 </row> 
									 <row><entry>Column</entry><entry>A constraint which
												can be evaluted in terms of the value for a single column.</entry> 
									 </row> 
									 <row><entry>Row</entry><entry>A constraint which
												can be evaluated in terms of the values for the columns of a single
												row.</entry> 
									 </row> 
									 <row><entry>Table</entry><entry>A constraint which
												can be evaluated in terms of the values for the rows of a single table.</entry>
										  
									 </row> 
									 <row><entry>Database</entry><entry>A constraint
												which can be evaluated in terms of the values for the tables in a
												database.</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>The expression for a constraint is required to be
					 deterministic.</para> 
				<sect2 id="DDGP2References"> 
					 <title><indexterm><primary>References</primary></indexterm>References</title>
					 
					 <para>References are implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.Reference</symbol>.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2EventHandlers"> 
				<title><indexterm><primary>Event
								Handlers</primary></indexterm>Event Handlers</title> 
				<para>Event handlers are implemented by the class
					 <symbol>Alphora.Dataphor.DAE.Schema.TriggerHandler</symbol>. Event handlers
					 associate an event taking place in the system with some operator. The specified
					 operator must have a signature that matches the signature of the event being
					 triggered using standard operator resolution.</para> 
				<sect2 id="DDGP2TableLevelEvents"> 
					 <title><indexterm><primary>Table Level
									 Events</primary></indexterm>Table Level Events</title> 
					 <para>Each table variable can have any number of associated
						  event handlers for the different event sources available for tables. These
						  event sources, and their associated signatures are described in the following
						  table: 
						  <informaltable> 
								<tgroup cols="3"><thead> 
										  <row><entry>Event
													 Type</entry><entry>Description</entry><entry>Signature</entry> 
										  </row></thead><tbody> 
										  <row><entry>Before Insert</entry><entry>Occurs
													 before the insert of a row in a table variable.</entry><entry><symbol>(const
													 row { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>After Insert</entry><entry>Occurs
													 after the insert of a row in a table variable.</entry><entry><symbol>(const row
													 { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>Before Update</entry><entry>Occurs
													 before the update of a row in a table variable.</entry><entry><symbol>(const
													 row { &lt;heading&gt; }, const row { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>After Update</entry><entry>Occurs
													 after the update of a row in a table variable.</entry><entry><symbol>(const row
													 { &lt;heading&gt; }, const row { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>Before Delete</entry><entry>Occurs
													 before the delete of a row in a table variable.</entry><entry><symbol>(const
													 row { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>After Delete</entry><entry>Occurs
													 after the delete of a row in a table variable.</entry><entry><symbol>(const row
													 { &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>Default</entry><entry>Occurs during
													 a default proposable call from the CLI.</entry><entry><symbol>(var row {
													 &lt;heading&gt; }, const string)</symbol></entry> 
										  </row> 
										  <row><entry>Change</entry><entry>Occurs during
													 a change proposable call from the CLI.</entry><entry><symbol>(var row {
													 &lt;heading&gt; }, const string)</symbol></entry> 
										  </row> 
										  <row><entry>Validate</entry><entry>Occurs
													 during a validate proposable call from the CLI.</entry><entry><symbol>(const
													 row { &lt;heading&gt; }, const string)</symbol></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGP2ColumnLevelEvents"> 
					 <title><indexterm><primary>Column Level
									 Events</primary></indexterm>Column Level Events</title> 
					 <para>Each column in each table variable can have any number of
						  associated event handlers for the different event sources available for
						  columns. These event sources, and their associated signatures are described in
						  the following table: 
						  <informaltable> 
								<tgroup cols="3"> 
									 <thead> 
										  <row><entry>Event
													 Type</entry><entry>Description</entry><entry>Signature</entry> 
										  </row></thead><tbody> 
										  <row><entry>Default</entry><entry>Occurs during
													 a default proposable call from the CLI.</entry><entry><symbol>(var &lt;column
													 data type&gt;)</symbol></entry> 
										  </row> 
										  <row><entry>Change</entry><entry>Occurs during
													 a change proposable call from the CLI.</entry><entry><symbol>(var entry {
													 &lt;heading&gt; })</symbol></entry> 
										  </row> 
										  <row><entry>Validate</entry><entry>Occurs
													 during a validate proposable call from the CLI.</entry><entry><symbol>(const
													 entry { &lt;heading&gt; })</symbol></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGP2DomainLevelEvents"> 
					 <title><indexterm><primary>Domain Level
									 Events</primary></indexterm>Domain Level Events</title> 
					 <para>Each domain can have any number of associated event
						  handlers for the different event sources available for domains. These event
						  sources, and their associated signatures are described in the following table: 
						  <informaltable> 
								<tgroup cols="3"> 
									 <thead> 
										  <row><entry>Event
													 Type</entry><entry>Description</entry><entry>Signature</entry> 
										  </row></thead><tbody> 
										  <row><entry>Default</entry><entry>Occurs during
													 a default proposable call from the CLI.</entry><entry><symbol>(var &lt;scalar
													 type&gt;)</symbol></entry> 
										  </row> 
										  <row><entry>Change</entry><entry>Occurs during
													 a change proposable call from the CLI.</entry><entry><symbol>(var &lt;scalar
													 type&gt;)</symbol></entry> 
										  </row> 
										  <row><entry>Validate</entry><entry>Occurs
													 during a validate proposable call from the CLI.</entry><entry><symbol>(const
													 &lt;scalar type&gt;)</symbol></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable> </para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Users"> 
				<title><indexterm><primary>Users</primary></indexterm>Users</title>
				
				<para>Users are represented in the catalog by the class
					 <symbol>Alphora.Dataphor.DAE.Schema.User</symbol>.</para> 
		  </sect1> 
		  <sect1 id="DDGP2Devices"> 
				<title><indexterm><primary>Devices</primary></indexterm>Devices</title>
				
				<para>Devices are represented in the catalog by the class
					 <symbol>Alphora.Dataphor.DAE.Schema.Device</symbol>. Refer to the Storage
					 Integration Architecture chapter for a complete discussion of this
					 class.</para> 
				<sect2 id="DDGP2DeviceSessions"> 
					 <title><indexterm><primary>Device
									 Sessions</primary></indexterm>Device Sessions</title> 
					 <para>Device sessions are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DeviceSession</symbol>. Each device session
						  represents an open communication session per process.</para> 
				</sect2> 
				<sect2 id="DDGP2DevicePlans2"> 
					 <title><indexterm><primary>Device
									 Plans</primary></indexterm>Device Plans</title> 
					 <para>Device plans are represented by the class
						  <symbol>Alphora.Datpahor.DAE.Schema.DevicePlan</symbol>. Each device plan
						  represents a prepared statement ready for execution within the device.</para> 
				</sect2> 
				<sect2 id="DDGP2DomainMaps"> 
					 <title><indexterm><primary>Domain
									 Maps</primary></indexterm>Domain Maps</title> 
					 <para>Domain maps are represented by some descendent of the
						  class <symbol>Alphora.Dataphor.DAE.Schema.DeviceScalarType</symbol>. Each
						  domain map represents a scalar type in the DAE that the device is capable of
						  providing storage for. The translation for this storage is handled by the
						  descendent class.</para> 
				</sect2> 
				<sect2 id="DDGP2OperatorMaps2"> 
					 <title><indexterm><primary>Operator
									 Maps</primary></indexterm>Operator Maps</title> 
					 <para>Operator maps are represented by some descendent of the
						  class <symbol>Alphora.Dataphor.DAE.Schema.DeviceOperator</symbol>. Each
						  operator map represents an operator that the device is capable of performing.
						  The translation for this execution is handled by the descendent class.</para> 
				</sect2> 
				<sect2 id="DDGP2DeviceUsers"> 
					 <title><indexterm><primary>Device
									 Users</primary></indexterm>Device Users</title> 
					 <para>User maps are represented by the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DeviceUser</symbol>. Each device user
						  associates a user with a set of credentials for use in connecting to the
						  device.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGCatalogPersistence"> 
				<title><indexterm><primary>Persistence</primary></indexterm>Persistence</title>
				
				<para>The DAE Catalog is persisted by emitting the entire catalog
					 as a creation script. The name of this file is given by the
					 <symbol>CatalogFileName</symbol> property of the <symbol>Server</symbol>
					 instance. If this file name is set, the catalog will be emitted on shutdown.
					 When the server starts, it will run the catalog file to re-create the
					 schema.</para> 
				<para>Each catalog object is capable of emitting the creation
					 statement for itself. This is done by the <symbol>EmitStatement</symbol> method
					 of the <symbol>Schema.Object</symbol> class. Each type of schema object
					 overrides this method to provide specific emission behavior. For operators,
					 this call is passed to the <symbol>EmitStatement</symbol> method of the
					 <symbol>PlanNode</symbol> for emission as D4 statements. These methods all
					 return descendents of the class <symbol>Statement</symbol>, and an
					 <symbol>Emitter</symbol> instance is then used to turn these structures into a
					 text string, which is written to file.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGQueryProcessor"> 
		  <title><indexterm><primary>DAE Runtime
						  Architecture</primary></indexterm><indexterm><primary>Runtime
						  Architecture</primary></indexterm>Runtime Architecture</title> 
		  <para>This chapter covers all the implementation details of the runtime
				architecture of the DAE. This chapter assumes a thorough understanding of the
				material presented in previous chapters.</para> 
		  <sect1 id="DDGP2Parser"> 
				<title><indexterm><primary>Parser</primary></indexterm>Parser</title>
				
				<para>A parser is responsible for transforming streams of tokens
					 into a syntactically correct representation of the user statement, suitable for
					 use in compilation. Essentially, parsing is the process of applying the
					 production rules of a grammar in reverse. In other words, figuring out which
					 production rules were used to generate the given token stream. In the process,
					 invalid syntax is detected, and this is the source of all
					 <symbol>SyntaxException</symbol>s thrown by the DAE.</para> 
				<sect2 id="DDGP2LexicalAnalyzer"> 
					 <title><indexterm><primary>Lexical
									 Analyzer</primary></indexterm>Lexical Analyzer</title> 
					 <para>In order to perform its task, a parser must be given a
						  token stream. The process of converting the textual representation of a command
						  into a token stream is called lexical analysis, and is performed by a lexical
						  analyzer.</para> 
					 <para>This task is performed by an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Language.Lexer</symbol>. The BNF used to describe
						  valid text files for lexical analysis is described in the language references.
						  The result of a lexical analysis is a stream of tokens. Each token can be one
						  of the following token types:</para> 
					 <para> 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Token
													 Type</entry><entry>Description</entry> 
										  </row></thead><tbody> 
										  <row><entry>Symbol</entry><entry>A valid symbol
													 of the language. This could be a keyword, an identifier, a built-in operator,
													 or a structure delimiter such as <symbol>(</symbol> or
													 <symbol>)</symbol>.</entry> 
										  </row> 
										  <row><entry>Boolean</entry><entry>A boolean
													 literal value, either <symbol>true</symbol> or <symbol>false</symbol>.</entry> 
										  </row> 
										  <row><entry>Integer</entry><entry>An integer
													 literal value. This could be either a simple integer, or an integer in
													 hexadecimal format, such as <symbol>0xFF</symbol>.</entry> 
										  </row> 
										  <row><entry>Decimal</entry><entry>A decimal
													 literal value.</entry> 
										  </row> 
										  <row><entry>Money</entry><entry>A money literal
													 value, which is a decimal preceded by <symbol>$</symbol>.</entry> 
										  </row> 
										  <row><entry>String</entry><entry>A string
													 literal value. Anything enclosed within single or double quotes is a string
													 literal.</entry> 
										  </row> 
										  <row><entry>EOF</entry><entry>A special token
													 used to denote the end of the token stream.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>At this point in processing, the parser is guaranteed to
						  have a correct set of symbols to work with. This step makes no attempt to
						  verify the syntax of language constructs, it simply handles the translation
						  from raw text data, into tokens with known meaning. It is the responsibility of
						  the parser to ensure that these tokens form a syntactically correct statement
						  of the language.</para> 
				</sect2> 
				<sect2 id="DDGP2Language"> 
					 <title><indexterm><primary>Language</primary></indexterm>Language</title>
					 
					 <para>The statements of any language described by a BNF can be
						  represented using a parse tree. This parse tree is a recipe for producing the
						  statement by invoking the production rule identified by each node of the tree.
						  For example, the statement 
						  <informalexample> 
								<para><symbol>x := x + 5;</symbol></para> 
						  </informalexample> can be represented using the parse tree:
						  
						  <informalexample> 
								<para>AssignmentStatement(IdentifierExpression("x"),
									 BinaryExpression(IdentifierExpression("x"), +, ValueExpression(5)))</para> 
						  </informalexample></para> 
					 <para>In this representation, each production rule of the
						  grammar becomes a node of the parse tree. To represent this in the DAE, a
						  hierarchy of classes all descending from
						  <symbol>Alphora.Dataphor.DAE.Language.Statement</symbol> is used. Each
						  production rule is represented using a different class, and the actual instance
						  of the parse tree is built using instances of the class for each production
						  rule.</para> 
					 <para>All the languages capable of being represented within the
						  DAE share a common set of basic production rules. These rules are represented
						  by the classes in the <symbol>Alphora.Dataphor.DAE.Language</symbol> namespace.
						  Each language extends the basic set of rules provided in this namespace by
						  adding classes to represent the specific rules of the language. The following
						  table lists the namespaces implementing different languages in the DAE:</para> 
					 <para> 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Language</entry><entry>Namespace</entry>
												
										  </row></thead><tbody> 
										  <row><entry>D4</entry><entry><symbol>Alphora.Dataphor.DAE.Language.D4</symbol></entry>
												
										  </row> 
										  <row><entry>Common
													 SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.SQL</symbol></entry> 
										  </row> 
										  <row><entry>T-SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.TSQL</symbol></entry>
												
										  </row> 
										  <row><entry>Oracle
													 SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.Oracle</symbol></entry>
												
										  </row> 
										  <row><entry>DB2
													 SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.DB2</symbol></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGP2Parser2"> 
					 <title><indexterm><primary>Parser</primary></indexterm>Parser</title>
					 
					 <para>Parsing is only done for two languages in the DAE, the D4
						  language, and the RealSQL language. Statements of D4 are produced by the parser
						  implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Language.D4.Parser</symbol>. Statements of RealSQL
						  are produced by the parser implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Language.RealSQL.Parser</symbol>. RealSQL parse
						  trees are then translated into D4 parse trees using the compiler implemented by
						  the class
						  <symbol>Alphora.Dataphor.DAE.Language.RealSQL.Compiler</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2Emitter"> 
					 <title><indexterm><primary>Emitter</primary></indexterm>Emitter</title>
					 
					 <para>Emitters are the opposite of parsers. Given a parsed
						  representation of some statement, an emitter is responsible for re-creating the
						  source text string for that statement. Emitters are implemented by some
						  descendent of the class
						  <symbol>Alphora.Dataphor.DAE.Language.TextEmitter</symbol>. Most languages used
						  by the DAE have an associated emitter class, as illustrated by the following
						  table:</para> 
					 <para> 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Language</entry><entry>Emitter
													 Class</entry> 
										  </row></thead><tbody> 
										  <row><entry>Common Language
													 Elements</entry><entry><symbol>Alphora.Dataphor.DAE.Language.BasicTextEmitter</symbol></entry>
												
										  </row> 
										  <row><entry>D4</entry><entry><symbol>Alphora.Dataphor.DAE.Language.D4.D4TextEmitter</symbol></entry>
												
										  </row> 
										  <row><entry>Common
													 SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.SQL.SQLTextEmitter</symbol></entry>
												
										  </row> 
										  <row><entry>T-SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.TSQL.TSQLTextEmitter</symbol></entry>
												
										  </row> 
										  <row><entry>Oracle
													 SQL</entry><entry><symbol>Alphora.Dataphor.DAE.Language.Oracle.OracleTextEmitter</symbol></entry>
												
										  </row> 
										  <row><entry>DB2
													 SQL</entry><entry><symbol>Alphora.Datpahor.DAE.Language.DB2.DB2TextEmitter</symbol></entry>
												
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2Compiler"> 
				<title><indexterm><primary>Compiler</primary></indexterm>Compiler</title>
				
				<para>A compiler is responsible for translating a syntactically
					 valid statement of some language into an equivalent set of statements in
					 another language. For the DAE, this involves translation from statements of D4,
					 to the actual implementation language of the DAE's query processor, also known
					 as D4 Assembly. There are several other compilers in the DAE as well, but this
					 chapter will only discuss the D4 compiler. The various D4 to SQL compilers are
					 discussed in the Storage Integration Architecture chapter, and the RealSQL
					 compiler will not be covered in this documentation.</para> 
				<para>Part of the process of compilation is verifying the semantic
					 correctness of a given statement. The semantics of a language are usually not
					 expressed in the BNF, and this is certainly the case with D4. These rules about
					 what statements are valid in D4 are enforced by the compiler. One such rule is
					 that D4 statements must be strongly typed. In other words, all values are of
					 some type that is known to the system, and the types of values that can appear
					 within statements and expressions of D4 are determined by context. For example,
					 an integer value cannot be assigned to a string variable.</para> 
				<para>In order to describe the process of compilation, the
					 framework in which it occurs must be understood. To that end, this section is
					 structured along the following outline: 
					 <itemizedlist> 
						  <listitem> 
								<para>Types</para> 
						  </listitem> 
						  <listitem> 
								<para>Values</para> 
						  </listitem> 
						  <listitem> 
								<para>Variables</para> 
						  </listitem> 
						  <listitem> 
								<para>Compile-time and Run-time State</para> 
						  </listitem> 
						  <listitem> 
								<para>Execution</para> 
						  </listitem> 
						  <listitem> 
								<para>Compilation</para> 
						  </listitem> 
						  <listitem> 
								<para>Optimization</para> 
						  </listitem> 
						  <listitem> 
								<para>Binding</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<sect2 id="DDGP2Types"> 
					 <title><indexterm><primary>Types</primary></indexterm>Types</title>
					 
					 <para>D4 is a strongly typed language, meaning that every value
						  is known to be of some type. Furthermore, the context in which values can
						  appear is verified by the compiler. Types in D4 are defined as follows:</para> 
					 <variablelist> 
						  <varlistentry> 
								<term>Type</term> 
								<listitem> 
									 <para>A set, possibly empty, of values. All values
										  are of some type.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Subtype</term> 
								<listitem> 
									 <para>A given type T<subscript>2</subscript> is a
										  subtype of type T<subscript>1</subscript> if and only if every value that is of
										  type T<subscript>2</subscript> is also of type
										  T<subscript>1</subscript>.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Supertype</term> 
								<listitem> 
									 <para>A given type T<subscript>1</subscript> is a
										  supertype of type T<subscript>2</subscript> if and only if every value that is
										  of type T<subscript>2</subscript> is also of type
										  T<subscript>1</subscript>.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Proper Subtype</term> 
								<listitem> 
									 <para>A given type T<subscript>2</subscript> is a
										  proper subtype of type T<subscript>1</subscript> if and only if
										  T<subscript>2</subscript> is a subtype of T<subscript>1</subscript> and there
										  is at least one value V such that V is of type T<subscript>1</subscript> and
										  not of type T<subscript>2</subscript>.</para> 
								</listitem> 
						  </varlistentry> 
						  <varlistentry> 
								<term>Proper Supertype</term> 
								<listitem> 
									 <para>A given type T<subscript>1</subscript> is a
										  proper supertype of type T<subscript>2</subscript> if and only if
										  T<subscript>1</subscript> is a supertype of T<subscript>2</subscript> and there
										  is at least one value V such that V is of type T<subscript>1</subscript> and
										  not of type T<subscript>2</subscript>.</para> 
								</listitem> 
						  </varlistentry> 
					 </variablelist> 
					 <para>Note that the definitions of subtype and supertype imply
						  that every type is a subtype and supertype of itself. In addition, this means
						  that every value is of some set of types, namely the set of types that are
						  supertypes of the type of the value. This has implications for values which
						  will be discussed in the Values section of this chapter.</para> 
					 <para>The notions of type equality, type testing, and type
						  compatibility are defined as follows: 
						  <variablelist> 
								<varlistentry> 
									 <term>Type Equality</term> 
									 <listitem> 
										  <para>A given type T<subscript>1</subscript> is
												equal to a type T<subscript>2</subscript> if and only if it is the same type.
												In other words, T<subscript>1</subscript> and T<subscript>2</subscript>
												describe the same set of values.</para> 
									 </listitem> 
								</varlistentry> 
								<varlistentry> 
									 <term>Type Testing</term> 
									 <listitem> 
										  <para>A given type T<subscript>1</subscript>
												<symbol>is</symbol> of type T<subscript>2</subscript> if and only if it is a
												subtype, not necessarily proper, of type T<subscript>2</subscript>. </para> 
									 </listitem> 
								</varlistentry> 
								<varlistentry> 
									 <term>Type Compatibility</term> 
									 <listitem> 
										  <para>A given type T<subscript>1</subscript> is
												compatible with type T<subscript>2</subscript> if T<subscript>1</subscript>
												<symbol>is</symbol> T<subscript>2</subscript> or T<subscript>2</subscript>
												<symbol>is</symbol> T<subscript>1</subscript>. </para> 
									 </listitem> 
								</varlistentry> 
						  </variablelist></para> 
					 <para>The DAE distinguishes several different categories of
						  types: 
						  <itemizedlist> 
								<listitem> 
									 <para>Generic</para> 
								</listitem> 
								<listitem> 
									 <para>Scalar</para> 
								</listitem> 
								<listitem> 
									 <para>Row</para> 
								</listitem> 
								<listitem> 
									 <para>Table</para> 
								</listitem> 
								<listitem> 
									 <para>List</para> 
								</listitem> 
								<listitem> 
									 <para>Cursor</para> 
								</listitem> 
						  </itemizedlist>Each of these types is described in detail
						  in the following sections.</para> 
					 <sect3 id="DDGP2TheGenericType"> 
						  <title><indexterm><primary>Generic
										  Type</primary></indexterm>The Generic Type</title> 
						  <para>The D4 language defines a type called
								<symbol>generic</symbol> which is the maximal supertype with respect to all
								types. In other words, the generic type is a supertype of all types. No value
								may be only a generic value. In other words, all values will be of some subtype
								of the generic type.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ScalarTypes"> 
						  <title><indexterm><primary>Scalar
										  Types</primary></indexterm>Scalar Types</title> 
						  <para>A scalar type is a named type with no user-visible
								components. In other words, all scalar values are atomic in the sense that they
								can be considered as a whole, and the structure of their internal
								representation is hidden. Scalar type equality is defined as follows: 
								<variablelist> 
									 <varlistentry> 
										  <term>Scalar Type Equality</term> 
										  <listitem> 
												<para>A given scalar type
													 T<subscript>1</subscript> having name N<subscript>1</subscript> is equal to
													 scalar type T<subscript>2</subscript> having name N<subscript>2</subscript> if
													 and only if N<subscript>1</subscript> is equal to
													 N<subscript>2</subscript>.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist>Note that the system has no way in
								general to guarantee that the type designer has indeed defined the types
								correctly with respect to this definition for equality of scalar types.</para> 
						  <para>The definitions for type testing and type
								compatibility for types in general apply without modification to scalar types
								in particular.</para> 
						  <para>A system type named <symbol>System.Alpha</symbol> is
								the maximal supertype with respect to all scalar types.</para> 
					 </sect3> 
					 <sect3 id="DDGP2TableandRowTypes"> 
						  <title><indexterm><primary>Table and Row
										  Types</primary></indexterm>Table and Row Types</title> 
						  <para>Table and row types are both defined in terms of a
								heading. A heading is the set of columns which the values of the row or table
								type must contain. A heading is defined as follows: 
								<variablelist> 
									 <varlistentry> 
										  <term>Heading</term> 
										  <listitem> 
												<para>A set of columns of the form
													 &lt;C<subscript>N</subscript> : C<subscript>T</subscript>&gt; where
													 C<subscript>N</subscript> denotes the name of the column, unique within the
													 set, and C<subscript>T</subscript> denotes the type of values which can appear
													 in the column.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
						  <para>Row types describe the set of row values which
								conform to the heading for the type. Similarly, table types define the set of
								table values which contain row values which conform to the heading for the
								type.</para> 
						  <para>The definitions of equality, type testing, and
								compatibility for table and row types are based on the equivalent definitions
								for columns: 
								<variablelist> 
									 <varlistentry> 
										  <term>Column Equality</term> 
										  <listitem> 
												<para>A given column
													 C<subscript>1</subscript> having name N<subscript>1</subscript> and type
													 T<subscript>1</subscript> is equal to column C<subscript>2</subscript> having
													 name N<subscript>2</subscript> and type T<subscript>2</subscript> if and only
													 if N<subscript>1</subscript> is equal to N<subscript>2</subscript>, and
													 T<subscript>1</subscript> is equal to T<subscript>2</subscript> by the
													 definition of equality for types.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Column Type Testing</term> 
										  <listitem> 
												<para>A given column
													 C<subscript>1</subscript> having name N<subscript>1</subscript> and type
													 T<subscript>1</subscript> <symbol>is</symbol> of column
													 C<subscript>2</subscript> having name N<subscript>2</subscript> and type
													 T<subscript>2</subscript> if and only if N<subscript>1</subscript> is equal to
													 N<subscript>2</subscript>, and T<subscript>1</subscript> <symbol>is</symbol> of
													 T<subscript>2</subscript> by the definition of type testing for types.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Column Compatibility</term> 
										  <listitem> 
												<para>A given column
													 C<subscript>1</subscript> is compatible with column C<subscript>2</subscript>
													 if and only if C<subscript>1</subscript> <symbol>is</symbol> of
													 C<subscript>2</subscript>, or C<subscript>2</subscript> <symbol>is</symbol> of
													 C<subscript>1</subscript>.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
						  <para>Now the definitions of equality, type testing and
								comaptibility for headings: 
								<variablelist> 
									 <varlistentry> 
										  <term>Heading Equality</term> 
										  <listitem> 
												<para>A given heading
													 H<subscript>1</subscript> having columns C<subscript>11</subscript> through
													 C<subscript>1n</subscript> is equal to heading H<subscript>2</subscript> having
													 columns C<subscript>21</subscript> through C<subscript>2n</subscript> if and
													 only if for all k, where k = 1 to n, there is some j such that column
													 C<subscript>1k</subscript> is equal to C<subscript>2j</subscript> by the
													 definition of equality for columns.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Heading Type Testing</term> 
										  <listitem> 
												<para>A given heading
													 H<subscript>1</subscript> having columns C<subscript>11</subscript> through
													 C<subscript>1n</subscript> <symbol>is</symbol> of heading
													 H<subscript>2</subscript> having columns C<subscript>21</subscript> through
													 C<subscript>2n</subscript> if and only if for all k, where k = 1 to n, there is
													 some j such that column C<subscript>1k</subscript> <symbol>is</symbol> of
													 column C<subscript>2j</subscript> by the definition of type testing for
													 columns.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Heading Compatibility</term> 
										  <listitem> 
												<para>A given heading
													 H<subscript>1</subscript> having columns C<subscript>11</subscript> through
													 C<subscript>1n</subscript> is compatible with heading H<subscript>2</subscript>
													 having columns C<subscript>21</subscript> through C<subscript>2n</subscript> if
													 and only if for all k, where k = 1 to n, there is some j such that column
													 C<subscript>1k</subscript> is compatible with C<subscript>2j</subscript> by the
													 definition of compatibility for columns.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
						  <para>Now the definitions of equality, type testing, and
								compatibility for row types can be given as: 
								<variablelist> 
									 <varlistentry> 
										  <term>Row Type Equality</term> 
										  <listitem> 
												<para>A given row type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>, is equal to
													 row type T<subscript>2</subscript> having heading H<subscript>2</subscript> if
													 and only if H<subscript>1</subscript> is equal to H<subscript>2</subscript> by
													 the definition of equality for headings.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Row Type Testing</term> 
										  <listitem> 
												<para>A given row type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>,
													 <symbol>is</symbol> of row type T<subscript>2</subscript> having heading
													 H<subscript>2</subscript> if and only if H<subscript>1</subscript>
													 <symbol>is</symbol> of H<subscript>2</subscript> by the definition of type
													 testing for headings.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Row Type Compatibility</term> 
										  <listitem> 
												<para>A given row type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>, is
													 compatible with row type T<subscript>2</subscript> having heading
													 H<subscript>2</subscript> if and only if H<subscript>1</subscript> is
													 compatible with H<subscript>2</subscript> by the definition of compatiblitiy
													 for headings.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
						  <para>And the corresponding definitions of equality, type
								testing, and compatibility for table types can be given as: 
								<variablelist> 
									 <varlistentry> 
										  <term>Table Type Equality</term> 
										  <listitem> 
												<para>A given table type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>, is equal to
													 table type T<subscript>2</subscript> having heading H<subscript>2</subscript>
													 if and only if H<subscript>1</subscript> is equal to H<subscript>2</subscript>
													 by the definition of equality for headings.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Table Type Testing</term> 
										  <listitem> 
												<para>A given table type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>,
													 <symbol>is</symbol> of table type T<subscript>2</subscript> having heading
													 H<subscript>2</subscript> if and only if H<subscript>1</subscript>
													 <symbol>is</symbol> of H<subscript>2</subscript> by the definition of type
													 testing for headings.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Table Type Compatibility</term> 
										  <listitem> 
												<para>A given table type
													 T<subscript>1</subscript> having heading H<subscript>1</subscript>, is
													 compatible with table type T<subscript>2</subscript> having heading
													 H<subscript>2</subscript> if and only if H<subscript>1</subscript> is
													 compatible with H<subscript>2</subscript> by the definition of compatibility
													 for headings.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
					 </sect3> 
					 <sect3 id="DDGP2ListTypes2"> 
						  <title><indexterm><primary>List
										  Types</primary></indexterm>List Types</title> 
						  <para>List types describe sets of values which are lists
								whose elements are all values of some type, known as the element type of the
								list. The definitions for type equality, type testing, and type compatibility
								for list types can then be given as: 
								<variablelist> 
									 <varlistentry> 
										  <term>List Type Equality</term> 
										  <listitem> 
												<para>A given list type
													 T<subscript>1</subscript> having element type E<subscript>1</subscript> is
													 equal to list type T<subscript>2</subscript> having element type
													 T<subscript>2</subscript> if and only if E<subscript>1</subscript> is equal to
													 E<subscript>2</subscript> by the definition of equality for types.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>List Type Testing</term> 
										  <listitem> 
												<para>A given list type
													 T<subscript>1</subscript> having element type E<subscript>1</subscript>
													 <symbol>is</symbol> of list type T<subscript>2</subscript> having element type
													 T<subscript>2</subscript> if and only if E<subscript>1</subscript>
													 <symbol>is</symbol> of E<subscript>2</subscript> by the definition of type
													 testing for types.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>List Type Compatibility</term> 
										  <listitem> 
												<para>A given list type
													 T<subscript>1</subscript> having element type E<subscript>1</subscript> is
													 compatible with list type T<subscript>2</subscript> having element type
													 T<subscript>2</subscript> if and only if E<subscript>1</subscript> is
													 compatible with E<subscript>2</subscript> by the definition of compatibility
													 for types.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
					 </sect3> 
					 <sect3 id="DDGP2CursorTypes2"> 
						  <title><indexterm><primary>Cursor
										  Types</primary></indexterm>Cursor Types</title> 
						  <para>Cursor types describe sets of values which represent
								cursors in the DAE. A cursor type has a table type which describes the type of
								the result set over which the cursor ranges. The definitions of type equality,
								type testing, and type compatibility can then be given as: 
								<variablelist> 
									 <varlistentry> 
										  <term>Cursor Type Equality</term> 
										  <listitem> 
												<para>A given cursor type
													 T<subscript>1</subscript> having result type R<subscript>1</subscript> is equal
													 to cursor type T<subscript>2</subscript> having result type
													 R<subscript>2</subscript> if and only if R<subscript>1</subscript> is equal to
													 R<subscript>2</subscript> by the definition of equality for table types.</para>
												
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Cursor Type Testing</term> 
										  <listitem> 
												<para>A given cursor type
													 T<subscript>1</subscript> having result type R<subscript>1</subscript>
													 <symbol>is</symbol> of cursor type T<subscript>2</subscript> having result type
													 R<subscript>2</subscript> if and only if R<subscript>1</subscript>
													 <symbol>is</symbol> of R<subscript>2</subscript> by the definition of type
													 testing for table types.</para> 
										  </listitem> 
									 </varlistentry> 
									 <varlistentry> 
										  <term>Cursor Type Compatibility</term> 
										  <listitem> 
												<para>A given cursor type
													 T<subscript>1</subscript> having result type R<subscript>1</subscript> is
													 compatible with cursor type T<subscript>2</subscript> having result type
													 R<subscript>2</subscript> if and only if R<subscript>1</subscript> is
													 compatible with R<subscript>2</subscript> by the definition of compatiblity for
													 table types.</para> 
										  </listitem> 
									 </varlistentry> 
								</variablelist></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Values"> 
					 <title><indexterm><primary>Values</primary></indexterm>Values</title>
					 
					 <para>This section covers the implementation of values in the
						  DAE. It covers the way that values are represented in the system, how they are
						  stored and transformed between the storage layer and the host language, and how
						  each of the different types of values are represented.</para> 
					 <sect3 id="DDGP2Representations2"> 
						  <title><indexterm><primary>Representations</primary></indexterm>Representations</title>
						  
						  <para>Every value in the DAE has at least five distinct
								representations, falling into five different categories of representations: 
								<orderedlist> 
									 <listitem> 
										  <para>Physical Representation</para> 
									 </listitem> 
									 <listitem> 
										  <para>Host Representation</para> 
									 </listitem> 
									 <listitem> 
										  <para>Logical Representation</para> 
									 </listitem> 
									 <listitem> 
										  <para>Device Representation</para> 
									 </listitem> 
									 <listitem> 
										  <para>Presentation Representation</para> 
									 </listitem> 
								</orderedlist></para> 
						  <para>The physical representation is the actual byte
								encoding for the value as it is persisted in the storage engine. Physical
								representations are extremely protected and accessible only through the host
								language. There is no way to access physical representations through D4. Great
								care has been taken in the design of the DAE to ensure that physical
								considerations do not compromise the logical model. One way in which this is
								accomplished is by limiting the access points to the physical representations
								of data. By limiting the number of times physical representation is accessed,
								we limit the impact of changing that physical representation. This is the
								reason that selector and accessor implementations for the scalar types are
								required to be host-implemented operators. It is highly recommended that the
								type designer limit host language access to the physical representation of a
								scalar type to these protected operators.</para> 
						  <para>The host representation is the representation of the
								value within the host system, namely the .NET run-time. As such, the host
								representation is a CLR value, which may be a ValueType value, or a
								ReferenceType. Care must be taken in the latter case to ensure that copies are
								made when required, and that any disposable resources allocated by the instance
								of the reference type are cleaned up properly when the value being represented
								is no longer needed.</para> 
						  <para>A logical representation of a value is the
								representation in D4. There may be many different representations for a single
								value, as in the case of scalar values. The logical representation of a value
								is a component of the logical model, and as such, the compiler has very little
								to do with them.</para> 
						  <para>The device representation of a value is the
								representation as it comes in from the connectivity layer of a device.
								Translation between device representation and host representation is handled by
								the device layer and discussed in the Storage Integration Architecture
								chapter.</para> 
						  <para>The presentation representation of a value determines
								how the value should appear in the user interface. These representations are
								largely handled by client applications, but the DAE also provides the ability
								to define possible presentation layer representations of types using the
								<symbol>Conveyor</symbol> architecture.</para> 
					 </sect3> 
					 <sect3 id="DDGP2StreamsArchitecture"> 
						  <title><indexterm><primary>Streams
										  Architecture</primary></indexterm>Streams Architecture</title> 
						  <para>All physical representations in the DAE are byte
								streams. Each data type has a specific format which it uses to read and write
								host representations to and from these byte streams. These byte streams are
								managed by the stream manager, a server level resource manager. All storage is
								abstracted at this layer, so the byte stream may be based on a buffer page in
								memory, or a file on disk. At this level, all that matters is that the stream
								is uniquely identifiable via the <symbol>StreamID</symbol> and that it is an
								implementation of the <symbol>System.IO.Stream</symbol> interface.</para> 
						  <para>A stream manager in the DAE is responsible for
								exposing the different storage systems as a single stream store. This is
								accomplished by using the stream manager as a list of known streams, and
								coordinating the efforts of various stream providers in the system to provide
								allocation and access services. A stream provider is responsible for actually
								acquiring the stream.</para> 
						  <para>The stream manager in the DAE is implemented by an
								instance of the class
								<symbol>Alphora.Dataphor.DAE.Streams.ServerStreamManager</symbol>. This class
								maintains a list of instances of the class
								<symbol>Alphora.Dataphor.DAE.Streams.StreamHeader</symbol> in a hash table.
								This list serves as the lookup for existing streams. A
								<symbol>StreamHeader</symbol> tracks the information associated with the
								stream, such as the number of times it has been opened, the
								<symbol>LockID</symbol> used to control concurrency for the stream, and which
								provider is servicing the stream.</para> 
						  <para>Stream providers in the DAE must implement the
								interface <symbol>Alphora.Dataphor.DAE.Streams.IStreamProvider</symbol>. The
								base implementation of a stream provider is described by the class
								<symbol>Alphora.Dataphor.DAE.Streams.StreamProvider</symbol>. The default
								stream provider for a DAE instance is the
								<symbol>Alphora.Datpahor.DAE.Streams.MemoryStreamProvider</symbol>, which uses
								system memory as the storage device. Each device registered with the system can
								also function as a stream provider. When an allocation request is made to the
								stream provider, the default stream provider for the stream manager is used to
								create a new stream. This stream is assigned a new <symbol>StreamID</symbol>
								and registered with the stream manager. A stream provider may also use the
								<symbol>Register</symbol> methods of the server stream manager to register an
								existing stream. This mechanism is used by the devices to support deferred read
								streams.</para> 
						  <para>The
								<symbol>Alphora.Dataphor.DAE.Streams.IStreamManager</symbol> interface exposes
								the calls necessary to access the stream management functionality, but does not
								include a parameter for identification of the process involved. The process
								level of the CLI implements this interface to provide stream management
								capabilities to running processes. The calls are passed on to the server stream
								manager, with the appropriate process identifier. This simplifies stream access
								for the processes in the DAE.</para> 
						  <para>The server stream manager uses copy-on-write
								semantics to optimize the copying of streams. Instead of copying a stream
								whenever a copy is requested, the stream manager simply references the stream.
								Only when a change is made to the referenced stream is a copy actually
								materialized. In this way the amount of data being copied in the DAE is
								dramatically reduced.</para> 
					 </sect3> 
					 <sect3 id="DDGP2TheDataValueClass"> 
						  <title><indexterm><primary>DataValue
										  Class</primary></indexterm>The DataValue Class</title> 
						  <para>Because there are many different types of values in
								D4, there are many different methods for dealing with them within the DAE. All
								values have certain common aspects, however, which form the basis for the
								values architecture of the DAE. All values have a type, all values have
								representations, and all values can be copied. These behaviors are introduced
								by the class <symbol>Alphora.Dataphor.DAE.Runtime.Data.DataValue</symbol>.
								Instances of this class are not the values themselves, rather they are
								implementation level place holders for the logical values they represent. Each
								different type of value is implemented by some descendent of the
								<symbol>DataValue</symbol> class. Each of these descendents introduces
								behaviors specific to the type of value being modeled.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ScalarValues"> 
						  <title><indexterm><primary>Scalar
										  Values</primary></indexterm>Scalar Values</title> 
						  <para>Scalar values within the DAE use conveyors to
								translate between the physical representation of the value, and the host
								representation. These conveyors are utilized by instances of the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Data.Scalar</symbol> to model the behavior
								of scalar values within the DAE. Conveyors are instances of some descendent of
								the class <symbol>Alphora.Dataphor.DAE.Streams.Conveyor</symbol>. Each native
								D4 type has a specific conveyor as the following table shows: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Scalar
														  Type</entry><entry>Conveyor Class</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>System.Error</symbol></entry><entry><symbol>ObjectConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Boolean</symbol></entry><entry><symbol>BooleanConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Decimal</symbol></entry><entry><symbol>DecimalConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Long</symbol></entry><entry><symbol>Int64Conveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Integer</symbol></entry><entry><symbol>Int32Conveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Short</symbol></entry><entry><symbol>Int16Conveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Byte</symbol></entry><entry><symbol>ByteConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.String</symbol></entry><entry><symbol>StringConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.IString</symbol></entry><entry><symbol>StringConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.TimeSpan</symbol></entry><entry><symbol>TimeSpanConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.DateTime</symbol></entry><entry><symbol>DateTimeConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Guid</symbol></entry><entry><symbol>GuidConveyor</symbol></entry>
													 
												</row> 
												<row><entry><symbol>System.Image</symbol></entry><entry><symbol>StreamConveyor</symbol></entry>
													 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <sect4 id="DDGP2NativeValuesOptimization"> 
								<title><indexterm><primary>Native Value
												Optimization</primary></indexterm>Native Values Optimization</title> 
								<para>When a scalar value is modeled in isolation, the
									 system can sometimes optimize processing by preventing the translation from the
									 host representation to the physical representation. This optimization is only
									 possible if the conveyor for the scalar type implements the
									 <symbol>IObjectConveyor</symbol> interface. The interface is used to improve
									 performance by preserving the value in its host representation.</para> 
						  </sect4> 
						  <sect4 id="DDGP2PresentationLayerRepresentations"> 
								<title><indexterm><primary>Presentation Layer
												Representations</primary></indexterm>Presentation Layer Representations</title>
								
								<para>In addition to providing translation services for
									 the DAE, conveyors provide translation services for the presentation layer.
									 This is accomplished through the <symbol>IXXXConveyor</symbol> interfaces. Each
									 conveyor implements one or more of these interfaces to provide presentation
									 layer representations for the values. The following conveyor interfaces are
									 defined in the namespace <symbol>Alphora.Dataphor.DAE.Streams</symbol>: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Interface</entry><entry>Description</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>IRawConveyor</symbol></entry><entry>Provides
																access to the data in byte form exposed as a .NET stream, byte array, or base
																64 string.</entry> 
													 </row> 
													 <row><entry><symbol>IDisplayConveyor</symbol></entry><entry>Provides
																access to the data as a .NET string suitable for display purposes in a
																presentation layer.</entry> 
													 </row> 
													 <row><entry><symbol>IEditConveyor</symbol></entry><entry>Provides
																access to the data as a .NET string suitable for edit purposes in a
																presentation layer.</entry> 
													 </row> 
													 <row><entry><symbol>INumberConveyor</symbol></entry><entry>Provides
																access to the data in a numeric representation, exposed as any of the .NET
																integer or decimal types.</entry> 
													 </row> 
													 <row><entry><symbol>IGuidConveyor</symbol></entry><entry>Provides
																access to the data as a .NET guid value.</entry> 
													 </row> 
													 <row><entry><symbol>IBooleanConveyor</symbol></entry><entry>Provides
																access to the data as a .NET boolean value.</entry> 
													 </row> 
													 <row><entry><symbol>IDateTimeConveyor</symbol></entry><entry>Provides
																access to the data as a .NET datetime value.</entry> 
													 </row> 
													 <row><entry><symbol>ITimeSpanConveyor</symbol></entry><entry>Provides
																access to the data as a .NET timespan value.</entry> 
													 </row> 
													 <row><entry><symbol>IObjectConveyor</symbol></entry><entry>Provides
																access to the data a s a .NET object value.</entry> 
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Each of the system conveyors implement a set of
									 these interfaces to allow the system scalar types to be exposed through the
									 presentation services of the Dataphor toolset.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2RowValues"> 
						  <title><indexterm><primary>Row
										  Values</primary></indexterm>Row Values</title> 
						  <para>Row values in the DAE are modeled by instances of the
								class <symbol>Alphora.Dataphor.DAE.Runtime.Data.Row</symbol>. Like all values
								in the DAE, row values use a formatted byte stream for physical representation.
								This byte stream contains a series of flags for tracking information about the
								values stored in the row, followed by the physical representation for the
								values in the order they appear in the type definition for the row
								value.</para> 
						  <sect4 id="DDGP2ScalarContainment"> 
								<title><indexterm><primary>Scalar
												Containment</primary></indexterm>Scalar Containment</title> 
								<para>Row values contain scalar values, and these
									 values are exposed through the indexer of the <symbol>Row</symbol> instance.
									 When accessed, a new <symbol>Scalar</symbol> instance is created to model the
									 scalar value represented within the row. Note that this scalar value is
									 actually using a subset of the physical representation of the row value, and is
									 therefore not a copy. Unlike the logical D4 row value it is modeling, the
									 <symbol>Row</symbol> instance allows for columns with no value.</para> 
						  </sect4> 
						  <sect4 id="DDGP2Overflow"> 
								<title><indexterm><primary>Overflow</primary></indexterm>Overflow</title>
								
								<para>In order to allow for fixed length byte streams
									 to be used for the encoding of rows, all data types have an associated static
									 byte size property. This property indicates the size in bytes of the physical
									 representation of the data type that should be co-located with the row value.
									 If the actual size of the physical representation of some value is larger than
									 the static byte size for the data type, the row handles the excess using a
									 technique called overflow. The row allocates a new byte stream to store the
									 overflow, and stores the stream identifier in the row instead. When required,
									 the row reconstructs the value stream by concatenating the remaining static
									 byte size in the row with the overflow stream.</para> 
								<para>Overflow management is completely handled by the
									 <symbol>Row</symbol> instance. Because the physical representation for a stream
									 identifier is eight bytes, this is the minimum static byte size required for a
									 data type to support overflow. In this way, values of any size can be stored in
									 any column of any row, without losing the advantages of fixed length rows for
									 the physical representation of table values.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2TableValues"> 
						  <title><indexterm><primary>Table
										  Values</primary></indexterm>Table Values</title> 
						  <para>Table values in the DAE are modeled by instances of
								the class <symbol>Alphora.Dataphor.DAE.Runtime.Data.Table</symbol>. This class
								describes the abstract behavior that all table values must implement. Unlike
								the other value classes, however, the table does not prescribe any physical
								representation behavior. The physical representation of table values may be
								handled by the DAE, in which case it is modeled using a set of classes which
								implement a classic B+ tree, or it may be handled by some device connected to
								the DAE. This section will discuss the modeling of table values within the DAE.
								For a discussion of table values within devices, refer to the Storage
								Integration Architecture chapter.</para> 
						  <sect4 id="DDGP2RowContainment"> 
								<title><indexterm><primary>Row
												Containment</primary></indexterm>Row Containment</title> 
								<para>Logically, table values are sets of row values.
									 The physical representation of table values makes use of this logical
									 relationship, and stores table values as a list of rows in some well defined
									 order. The basic structure used to accomplish this ordering is a B+ tree. This
									 structure allows for very fast retrieval and manipulation of row values without
									 the need for updating master index tables. The structure itself forms the
									 index, and is thus an ideal structure for mapping logical tables to
									 disk.</para> 
						  </sect4> 
						  <sect4 id="DDGP2Indexes"> 
								<title><indexterm><primary>Indexes</primary></indexterm>Indexes</title>
								
								<para>B+ tree indexes in the DAE are implemented by
									 instances of the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Data.Index</symbol>. This class manages
									 the index level information necessary to maintain the index, and allows for
									 access to the data within the index by creating instances of the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Data.IndexNode</symbol> which represents a
									 single node in the B+ tree. There are two types of nodes in a B+ tree, a
									 routing node, which contains only key information necessary to traverse the
									 structure, and a data node, which contains both key and data information. The
									 leaf nodes of a B+ tree are always data nodes, non-leaf nodes are always
									 routing nodes. All the nodes are bi-directionally linked to each other so that
									 the structure can be traversed along leaf nodes.</para> 
								<para>Each node is a list of entries, where an entry is
									 a key-data pair. For routing nodes, the data is a stream identifier which
									 points to the stream containing the indicated node of the structure. For data
									 nodes, the data is the non-key portion of the row. The number of entries for a
									 routing node is called the fanout of the structure, and determines how quickly
									 the B+ tree grows in depth. Higher fanout values mean less depth. The number of
									 entries for a data node is called the capacity of the B+ tree and determines
									 how quickly individual page maintenance occurs. Higher values mean slower page
									 maintenance, but too low a value, and the index will be too spread out. The
									 default values for these properties are 100 for fanout, and 100 for capacity.
									 These values provide a good balance between growth and maintenance for a
									 typical table value.</para> 
						  </sect4> 
						  <sect4 id="DDGP2TableBuffers"> 
								<title><indexterm><primary>Table
												Buffers</primary></indexterm>Table Buffers</title> 
								<para>The DAE organizes indexes into the concept of a
									 table buffer. A table buffer is a collection of indexes used to represent a
									 single table value. One index is considered the clustered index and stores the
									 data in a primary ordering, usually some key of the table. This is the primary
									 index for the table value, and is the only one that stores all the data for the
									 table. The secondary indexes, known as non-clustered indexes, represent
									 different access paths to the rows of the table value. These indexes store as
									 data the key of the row being indexed in the primary index. This allows for
									 efficient access paths to be described and persisted for the table value. The
									 query processor can then make use of these access paths to improve the
									 performance of various queries.</para> 
								<para>Table buffers are implemented in the DAE by
									 instances of the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableBuffer</symbol>. This class
									 manages a collection of instances of the class
									 <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableBufferIndex</symbol>, which
									 represent the various indexes involved in the table buffer and their
									 relationship to each other. The <symbol>TableBuffer</symbol> instance manages
									 data maintenance when rows are inserted, updated, or deleted from the physical
									 representation.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2ListValues"> 
						  <title><indexterm><primary>List
										  Values</primary></indexterm>List Values</title> 
						  <para>List values are implemented as instances of the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Data.ListValue</symbol>. The host
								representation of a list value in the DAE is a .NET <symbol>ArrayList</symbol>
								instance.</para> 
					 </sect3> 
					 <sect3 id="DDGP2CursorValues"> 
						  <title><indexterm><primary>Cursor
										  Values</primary></indexterm>Cursor Values</title> 
						  <para>Cursor values are implemented as instances of the
								class <symbol>Alphora.Dataphor.DAE.Runtime.Data.Cursor</symbol>. A cursor value
								is a handle to an open table value in the cursor manager for the session. This
								cursor manager is implemented as an instance of the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Data.CursorManager</symbol>, and simply
								tracks a list of <symbol>Cursor</symbol> instances. Each cursor is assigned an
								integer identifier, and exposes a table value through the
								<symbol>Table</symbol> property of the <symbol>Cursor</symbol> instance. When
								modeled as a value in the DAE, only the cursor identifier is used. Access to
								the cursor it represents is obtained through the <symbol>GetCursor</symbol>
								method of the <symbol>CursorManager</symbol> instance.</para> 
						  <para>Note that the cursors managed on the session are
								specific to cursor values of D4, they are not the same as the server cursors
								exposed through the CLI.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Variables"> 
					 <title><indexterm><primary>Variables</primary></indexterm>Variables</title>
					 
					 <para>Variables in the DAE are represented by instances of the
						  class <symbol>Alphora.Dataphor.DAE.Runtime.DataVar</symbol>. A variable in the
						  DAE has a name, a data type, and a current value. The same variable class is
						  used to model variables of all types in the processor. Table variables have an
						  additional representation in the system catalog as instances of some descendent
						  of the class <symbol>Alphora.Dataphor.DAE.Schema.TableVar</symbol>.</para> 
				</sect2> 
				<sect2 id="DDGP2Compile-timeandRun-timeState"> 
					 <title><indexterm><primary>Compile-time and Run-time
									 State</primary></indexterm>Compile-time and Run-time State</title> 
					 <para>The DAE tracks both compile-time and run-time state for
						  processes. Compile-time state is used to perform the translation between parsed
						  representations of statements in D4 and D4 assembly. Run-time state is used to
						  perform the actual operations required by D4 assembly instructions.</para> 
					 <sect3 id="DDGP2Plan"> 
						  <title><indexterm><primary>Plan</primary></indexterm>Plan</title>
						  
						  <para>Compile-time state is managed by an instance of the
								class <symbol>Alphora.Dataphor.DAE.Server.Plan</symbol>. This instance is
								passed as a handle for the compilation process, and provides access to all the
								required state, as well as the rest of the system. Compile-time processes use a
								symbol table to track the variables that are available in the current context.
								Additionally, the plan manages looping contexts, cursor contexts, and
								dependency tracking and concurrency control for schema objects.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Process2"> 
						  <title><indexterm><primary>Process</primary></indexterm>Process</title>
						  
						  <para>Run-time state is managed by an instance of the class
								<symbol>Alphora.Dataphor.DAE.Server.ServerProcess</symbol>. This instance is
								passed as a handle for the execution process, and provides access to all the
								required state, as well as the rest of the system.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Context"> 
						  <title><indexterm><primary>Context</primary></indexterm>Context</title>
						  
						  <para>Both compile-time and run-time state use an instance
								of the class <symbol>Alphora.Dataphor.DAE.Runtime.Context</symbol> to provide
								stack and heap management services. At compile-time this context is exposed by
								the property <symbol>Symbols</symbol> of the <symbol>Plan</symbol> instance. At
								run-time this context is exposed by the property <symbol>Stack</symbol> of the
								<symbol>ServerProcess</symbol> instance. In either case, this context manages
								the variables that are available in the current context. It manages stack
								windows and frames, and performs heap resolution and deallocation.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Catalog"> 
						  <title><indexterm><primary>Catalog</primary></indexterm>Catalog</title>
						  
						  <para>Both compile-time and run-time state require access
								to the system catalog, and this is made available through the
								<symbol>Catalog</symbol> property of the <symbol>Plan</symbol> and
								<symbol>ServerProcess</symbol> instances. This property is simply pass-through
								to the <symbol>Catalog</symbol> property of the <symbol>Server</symbol>
								instance. It is exposed at this level for simplicity.</para> 
					 </sect3> 
					 <sect3 id="DDGP2PlanCatalog"> 
						  <title><indexterm><primary>Plan
										  Catalog</primary></indexterm>Plan Catalog</title> 
						  <para>Compile-time state uses a plan catalog to describe
								the structure of the results of evaluation. This catalog is exposed as the
								<symbol>PlanCatalog</symbol> property of the <symbol>Plan</symbol> instance.
								The plan catalog provides the descriptor area for the result set of
								expressions, and is exposed directly through the CLI for use in
								applications.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Execution"> 
					 <title><indexterm><primary>Execution</primary></indexterm>Execution</title>
					 
					 <para>Execution in the DAE is the path taken through the
						  <symbol>Execute</symbol> method of the instances of descendents of the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.PlanNode</symbol>. Each
						  descendent class implements the behavior specific to the instruction being
						  modeled. For example, an <symbol>AssignmentNode</symbol> handles the assignment
						  of a new value to an existing variable on the stack. These instances of
						  <symbol>PlanNode</symbol> descendents are the instructions of D4 assembly. The
						  following sections describe the base nodes which provide the framework for
						  execution in the DAE.</para> 
					 <sect3 id="DDGP2PlanNode"> 
						  <title><indexterm><primary>PlanNode</primary></indexterm>PlanNode</title>
						  
						  <para>The class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.PlanNode</symbol> is the base
								node for all instructions in the DAE. It introduces the properties and
								behaviors common to all instructions. Most of the imperative statements of the
								D4 language are performed using direct <symbol>PlanNode</symbol> descendents. A
								direct <symbol>PlanNode</symbol> descendent does not usually return a value
								from its <symbol>Execute</symbol> method.</para> 
						  <sect4 id="DDGP2QueryChunking"> 
								<title><indexterm><primary>Query
												Chunking</primary></indexterm>Query Chunking</title> 
								<para>The <symbol>PlanNode</symbol> introduces the
									 behaviors necessary to support query "chunking." This is the process of
									 selecting peices, or chunks, of a query to be processed on devices, and is
									 described in detail in the chapter on Storage Integration Architecture. The
									 <symbol>DetermineDevice</symbol> method of the <symbol>PlanNode</symbol>
									 instance implements the chunking algorithm. Each <symbol>PlanNode</symbol> has
									 a <symbol>Device</symbol> property which indicates the device responsible for
									 execution of the node. The <symbol>DeviceSupported</symbol> property indicates
									 whether the node is supported by the device indicated.</para> 
						  </sect4> 
						  <sect4 id="DDGP2TypeDetermination"> 
								<title><indexterm><primary>Type
												Determination</primary></indexterm>Type Determination</title> 
								<para>One function the compiler performs is type
									 determination. This is accomplished by the individual nodes and introduced at
									 the <symbol>PlanNode</symbol> level. Each node overrides the
									 <symbol>DetermineDataType</symbol> method, and sets the value of the
									 <symbol>DataType</symbol> property to an instance of some descendent of the
									 class <symbol>Alphora.Dataphor.DAE.Schema.DataType</symbol> to represent the
									 result type of the node. If the node does not return a result, this property
									 will be null.</para> 
						  </sect4> 
						  <sect4 id="DDGP2ChildNodes"> 
								<title><indexterm><primary>Child
												Nodes</primary></indexterm>Child Nodes</title> 
								<para>Each plan node has a list of plan nodes,
									 represented by an instance of the class <symbol>PlanNodes</symbol>. This list
									 contains a <symbol>PlanNode</symbol> instance for each child of the current
									 node. For example, a <symbol>BlockNode</symbol> will have a node for each
									 statement to be executed within the block.</para> 
						  </sect4> 
						  <sect4 id="DDGP2Execution2"> 
								<title><indexterm><primary>Execution</primary></indexterm>Execution</title>
								
								<para>The <symbol>PlanNode</symbol> introduces the
									 basic level of execution in the processor through the method
									 <symbol>Execute</symbol>. At this level, this method decides whether execution
									 should be performed by a device, or the node itself. If the value of the
									 <symbol>DeviceSupported</symbol> property is true, the <symbol>Execute</symbol>
									 method calls the <symbol>Execute</symbol> method of the appropriate device.
									 Otherwise, execution is passed to the <symbol>InternalExecute</symbol> method.
									 Descendent nodes then override this method to implement the actual behavior
									 required in the node.</para> 
						  </sect4> 
						  <sect4 id="DDGP2StatementEmission"> 
								<title><indexterm><primary>Statement
												Emission</primary></indexterm>Statement Emission</title> 
								<para>The <symbol>PlanNode</symbol> also introduces the
									 ability to perform statement emission, or de-compilation. Each plan node
									 overrides the <symbol>EmitStatement</symbol> method to return a parse tree
									 representation of itself. In this way, compiled code can be emitted for
									 serialization across the remoting boundary, or for persistence as part of the
									 system catalog.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2InstructionNode"> 
						  <title><indexterm><primary>InstructionNode</primary></indexterm>InstructionNode</title>
						  
						  <para>The class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.InstructionNode</symbol>
								introduces the behaviors common to all instructions. All operators in the D4
								language are implemented by some descendent of an instruction node.</para> 
						  <para>The instruction node introduces a new execute method
								which takes as parameters not only the current process, but also the arguments
								to the instruction. The <symbol>InternalExecute</symbol> method is overridden
								by <symbol>InstructionNode</symbol> to perform stack processing for the
								instruction. Each child node of the instruction is considered an argument and
								evaluated in order from left to right. The results of these evaluations are
								passed to the new <symbol>InternalExecute</symbol> overload as an array of
								<symbol>DataVar</symbol> instances. When execution returns from the
								<symbol>InternalExecute</symbol> overload, the instruction node performs post
								call cleanup of the stack. In this way, the calling convention is ensured by
								the <symbol>InstructionNode</symbol>, and direct descendents of this class only
								need override the new <symbol>InternalExecute</symbol> overload to perform
								their processing.</para> 
						  <para><symbol>InstructionNode</symbol> also overrides the
								<symbol>DetermineDataType</symbol> method to perform the compile-time
								processing necessary to ensure calling convention is correctly handled.
								Parameter modifiers are examined at this point to determine whether any cleanup
								processing is necessary. If required, these extra steps are taken by the
								execute step at run-time.</para> 
						  <para>Each instruction node is providing the implementation
								for some operator in the DAE. This operator is represented by the
								<symbol>Operator</symbol> property of the <symbol>InstructionNode</symbol>
								instance. The value of this property is set by the compiler.</para> 
						  <para><symbol>InstructionNode</symbol> also provides a
								generic implementation of <symbol>EmitStatement</symbol> so that descendents do
								not have to provide this functionality, when possible.</para> 
					 </sect3> 
					 <sect3 id="DDGP2CallNode"> 
						  <title><indexterm><primary>CallNode</primary></indexterm>CallNode</title>
						  
						  <para>The class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.CallNode</symbol> descends
								from <symbol>InstructionNode</symbol> to provide the behaviors necessary to
								implement a call in the DAE. This involves stack preparation and cleanup, and
								management of the <symbol>Result</symbol> variable for operators returning a
								value. All non-aggregate, non-host-implemented operators are invoked using an
								instance of <symbol>CallNode</symbol>.</para> 
						  <para>The <symbol>InternalExecute</symbol> overload from
								<symbol>InstructionNode</symbol> is overriden. First, a new stack window is
								pushed, then each argument passed to the method is pushed onto the stack. If
								necessary, a result variable is also pushed onto the stack. Execution is then
								passed to the compiled code for the operator. Following execution, the stack is
								cleaned up, and the stack window is popped. If the operator returns a result,
								the result variable is returned from this method.</para> 
					 </sect3> 
					 <sect3 id="DDGP2AggregateCallNode"> 
						  <title><indexterm><primary>AggregateCallNode</primary></indexterm>AggregateCallNode</title>
						  
						  <para>Aggregate operators use a special calling convention
								in the DAE. As such, a special call node is used for their invocation. This
								node is implemented by the class
								<symbol>Alphora.Dataphor.DAE.Runtime.Instructions.AggregateCallNode</symbol>.
								All aggregate operators are invoked using an instance of this node.</para> 
						  <para>The child nodes of an aggregate call node have
								special significance. The first node, <symbol>Nodes[0]</symbol>, is the source
								node for the operation, and represents a table-valued expression. The property
								<symbol>AggregateColumnIndex</symbol> of the <symbol>AggregateCallNode</symbol>
								instance indicates which column in the result set of this table expression is
								to be used for the aggregation. The value of this property will be -1 if this
								is an aggregate operator which does not involve any particular column, such as
								<symbol>Count</symbol>. </para> 
						  <para>The second node, <symbol>Nodes[1]</symbol>, is called
								the initialization node. This node is executed once prior to iterating through
								the rows of the result set being aggregated. The affects of this node on the
								stack will be preserved for the remainder of the execution of the aggregate
								operator.</para> 
						  <para>The third node, <symbol>Nodes[2]</symbol>, is called
								the aggregation node. This node is executed once for each row in the result set
								being aggregated. Because it is a loop, this node is provided with a new stack
								frame for each iteration.</para> 
						  <para>The fourth node, <symbol>Nodes[3]</symbol>, is called
								the finalization node. This node is executed once after iterating through the
								rows of the result set being aggregated. This allows a final calculation to be
								made, if necessary.</para> 
						  <para>This calling convention allows for aggregate
								operations to be implemented as efficiently as possible, eliminating the need
								to materialize the result set entirely as an argument to some operator. The
								arguments in question are passed one at a time to the aggregation block of the
								operator. Each block within an aggregate operator may be either
								host-implemented, or written in the D4 language.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Compilation"> 
					 <title><indexterm><primary>Compilation</primary></indexterm>Compilation</title>
					 
					 <para>The actual process of compilation involves building a
						  tree of <symbol>PlanNode</symbol> descendent instances to perform the
						  processing required by the given parse tree. For each
						  <symbol>Statement</symbol> descendent encountered, the compiler invokes a
						  specific set of code for handling that statement type. For example, a
						  <symbol>Block</symbol> statement, causes the compiler to invoke the
						  <symbol>CompileBlock</symbol> method. Each specific section of code
						  manufactures the necessary <symbol>PlanNode</symbol> descendent to implement
						  the required operation, and guarantees that the semantics of its use are
						  correct. The effects of each operation on the compile-time state are managed by
						  the <symbol>Plan</symbol> and passed along as the compiler traverses the parse
						  tree. </para> 
					 <para>As each node is built, key methods are called to allow
						  the nodes to participate in the compilation process. First the node is created.
						  Which <symbol>PlanNode</symbol> descendent is created is determined by the type
						  of <symbol>Statement</symbol> being compiled. When a call expression is
						  encountered, the system catalog is used to resolve the signature and determine
						  the specific operator being invoked. This operator determines the type of node
						  to be created, depending on whether the node is host-implemented, or a D4
						  compiled operator.</para> 
					 <para>Once the node is created, the
						  <symbol>DetermineDataType</symbol> method of the node is invoked. This allows
						  the node to build the result type for itself, and is the key to the type
						  inference mechanism for table types described later. The node then exposes this
						  as the <symbol>DataType</symbol> property, which the compiler uses to perform
						  type checking and signature resolution.</para> 
					 <para>Once the type of the node is determined, and the
						  semantics have been verified, the completed node is placed in context by adding
						  it to the node hierarchy being constructed. The result of this phase of the
						  compilation process is a semantically correct tree of D4 instructions.</para> 
				</sect2> 
				<sect2 id="DDGP2Optimization"> 
					 <title><indexterm><primary>Optimization</primary></indexterm>Optimization</title>
					 
					 <para>Optimization is the process of performing transformations
						  on the D4 instruction tree which are known to preserve the semantics of the
						  operation being performed with the goal of achieving a more optimal execution
						  plan. For instance, if a given instruction tree contains two consecutive
						  restriction nodes, the two nodes can be combined together by and-ing the
						  conditions for each node into a single restrict.</para> 
					 <para>This phase of compilation is accomplished by passing the
						  instruction tree to the <symbol>Optimize</symbol> method of the compiler. Once
						  the process of optimization is complete, the compiler passes the optimized
						  instruction tree to the binding phase.</para> 
				</sect2> 
				<sect2 id="DDGP2Binding"> 
					 <title><indexterm><primary>Binding</primary></indexterm>Binding</title>
					 
					 <para>Binding involves determining where each instruction will
						  actually execute, and binding instructions to the stack and heap locations
						  where the data can be found.</para> 
					 <para>This phase of compilation is accomplished by passing the
						  instruction tree to the <symbol>Bind</symbol> method of the compiler. This
						  method in turns calls the <symbol>DetermineBinding</symbol> method of the root
						  node, which performs a depth-first traversal of the instruction tree. On the
						  return trip back up the tree, the <symbol>DetermineDevice</symbol> method of
						  each node is called to invoke the chunking algorithm. This is described in
						  detail in the Storage Integration Architecture chapter.</para> 
					 <para>The result of this final compilation phase is an
						  executable instruction block which performs the action requested by the user.
						  This executable block is returned from the compiler and saved as part of the
						  prepared plan.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2QueryProcessor"> 
				<title><indexterm><primary>Query
								Processor</primary></indexterm>Query Processor</title> 
				<para>The query processor functions within the execution framework
					 provided by the DAE. Different node types and table value implementations are
					 used to model the behavior of each table operator. The query processor
					 implements evaluation of table valued expressions, as well as updatability of
					 these same expressions. The table type inference mechanism is also implemented
					 at this level, as well as reference and metadata inference.</para> 
				<sect2 id="DDGP2TableNode"> 
					 <title><indexterm><primary>TableNode</primary></indexterm>TableNode</title>
					 
					 <para>A new type of node is introduced to handle the evaluation
						  of table valued expressions. This node is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.Instructions.TableNode</symbol>. All
						  host-implemented table operators are represented using instances of some
						  descendent of this class. This class also introduces the behaviors necessary to
						  allow descendent classes to implement specific updatability semantics for each
						  table operator.</para> 
					 <sect3 id="DDGP2Behaviors"> 
						  <title><indexterm><primary>Behaviors</primary></indexterm>Behaviors</title>
						  
						  <para>The TableNode overrides the
								<symbol>DetermineDevice</symbol> method to provide support for specific
								functionality that must be determined for table nodes. It first calls the base
								<symbol>DetermineDevice</symbol> method to determine whether the node is
								supported by a device. If the node is not supported by a device,
								<symbol>DetermineCursorBehavior</symbol> is called to allow the node to set the
								capabilities that will be available when execution occurs. If the updateable
								cursor capability is requested, the <symbol>DetermineModifySupported</symbol>
								method is called.</para> 
						  <para><symbol>DetermineModifySupported</symbol> is
								introduced to determine the modification binding for the node. This method
								queries the device to determine whether or not it would support a modification
								to the table expression at this level. This information is used at run-time to
								determine how update propogation should take place.</para> 
						  <para>The <symbol>TableNode</symbol> class introduces
								properties for representing the characteristics of a cursor as described in the
								cursor section of the Server Architecture chapter. These characteristics are
								represented by the three properties <symbol>CursorType</symbol>,
								<symbol>CursorCapabilities</symbol>, and <symbol>CursorIsolation</symbol>. The
								<symbol>TableNode</symbol> class introduces a method called
								<symbol>DetermineCursorBehavior</symbol> which can be overridden by descendent
								table nodes to provide for the determination of properties specific to each
								table node. The default implementation of this method sets cursor type to
								<symbol>CursorType.Dynamic</symbol>, cursor capabilities to
								<symbol>CursorCapability.Navigable</symbol>, and cursor isolation to the
								isolation of the current cursor context as indicated by the compile-time
								state.</para> 
					 </sect3> 
					 <sect3 id="DDGP2TypeInference"> 
						  <title><indexterm><primary>Type
										  Inference</primary></indexterm>Type Inference</title> 
						  <para>The <symbol>TableNode</symbol> class introduces
								several methods which handle core elements of the type inference process for
								table operators. These methods are used by descendent nodes to describe the
								result set of the operation being modeled. Type inference is discussed in
								detail in the Type Inference Mechanism section of this chapter.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2Execution3"> 
					 <title><indexterm><primary>Execution</primary></indexterm>Execution</title>
					 
					 <para>Execution for table operators is slightly different than
						  for other instructions. Both overloads of <symbol>InternalExecute</symbol> are
						  overridden by the <symbol>TableNode</symbol> class to throw exceptions.
						  Descendent nodes must override the desired <symbol>InternalExecute</symbol> to
						  perform the actual processing for the node. For all of the system table
						  operators, this execution is actually provided by some descendent of the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.Table</symbol>, which is created and
						  returned as the result of evaluating the expression. This architecture allows
						  all processing to be pipelined wherever possible, because the actual evaluation
						  of the expression is deferred until it is absolutely necessary. For example,
						  when evaluating a restrict, instead of computing the entire result set on open,
						  only a cursor is returned from the actual evaluation of the expression. This
						  cursor must be stepped through to retrieve the rows of the result set. Each
						  time the <symbol>Next</symbol> method is called for the cursor, the next row
						  matching the restriction condition is found and returned, and the underlying
						  cursor supplying the result set for the restrict operation is left on the
						  matching row. As nodes are chained together in this fashion, the query
						  processor architecture emerges as a set of cursors capable of performing table
						  operations, where the arguments to those operations are themselves
						  cursors.</para> 
				</sect2> 
				<sect2 id="DDGP2UpdateSemantics"> 
					 <title><indexterm><primary>Update
									 Semantics</primary></indexterm>Update Semantics</title> 
					 <para>The update semantics for any given table operator are
						  implemented by overloading key methods of the <symbol>TableNode</symbol> class.
						  Each node provides update behavior specific to the operation it is modeling.
						  This section details the methods introduced by the <symbol>TableNode</symbol>
						  class to support the description of these update semantics.</para> 
					 <sect3 id="DDGP2ModificationSupport"> 
						  <title><indexterm><primary>Modification
										  Support</primary></indexterm>Modification Support</title> 
						  <para>Modification of table variables is accomplished
								through one of three mechanisms: 
								<orderedlist> 
									 <listitem> 
										  <para>Through the actual cursor, if the cursor
												is updateable.</para> 
									 </listitem> 
									 <listitem> 
										  <para>As a DML statement executed against the
												device, if the device supports the statement.</para> 
									 </listitem> 
									 <listitem> 
										  <para>Propogated through the nodes in the
												expression tree.</para> 
									 </listitem> 
								</orderedlist></para> 
						  <para>In the first case, the cursor is reponsible for
								performing the update. Whenever a system table operator is processed by the
								DAE, the update is accopmlished through the <symbol>TableNode</symbol>
								describing the operation. The <symbol>TableNode</symbol> then decides whether
								the update can be translated into a statement and executed against the device,
								or must be propogated to the source nodes of the expression based on the value
								of the <symbol>ModifySupported</symbol> property. If the table operator is
								processed by the device, the cursor returned may support modification directly,
								in which case the DAE does not perform any of the modification steps, but does
								perform the validation required.</para> 
						  <para>In the second case, the value of the
								<symbol>ModifySupported</symbol> property is true, and the node hands the
								update to the device for processing as a single modification statement. The DAE
								is still responsible for performing validation processing, however.</para> 
						  <para>In the third case, the update is propogated to the
								source nodes for the operation. This is the mechanism which makes view
								updatability possible in the DAE.</para> 
						  <para>In all cases, the DAE performs pre- and
								post-modification processing as described in the following section.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ModificationPhases"> 
						  <title><indexterm><primary>Modification
										  Phases</primary></indexterm>Modification Phases</title> 
						  <para>All the modifications follow the same basic pattern
								of execution through the node. These steps fall into five basic phases: 
								<orderedlist> 
									 <listitem> 
										  <para>Prepare</para> 
									 </listitem> 
									 <listitem> 
										  <para>Before</para> 
									 </listitem> 
									 <listitem> 
										  <para>Execute</para> 
									 </listitem> 
									 <listitem> 
										  <para>After</para> 
									 </listitem> 
									 <listitem> 
										  <para>Unprepare</para> 
									 </listitem> 
								</orderedlist></para> 
						  <para>The prepare step is responsible for setting up the
								row values involved in the modification. The before step is responsible for
								performing validation and defaults, as well as executing any handlers tied to
								the before modification event. The execution step is responsible for actually
								performing the modification, whether in the device, or propogated through the
								node. The after step is responsible for performing post modification
								validation, as well as executing any handlers tied to the after modification
								event.</para> 
						  <sect4 id="DDGP2PreparePhase"> 
								<title><indexterm><primary>Prepare
												Phase</primary></indexterm>Prepare Phase</title> 
								<para>The prepare phase is implemented by the methods
									 <symbol>PrepareNewRow</symbol>, and <symbol>PrepareOldRow</symbol>. These
									 methods take the row which is given as the argument to the modification, and
									 ensure that it is in the correct format for the rest of the modification
									 steps.</para> 
								<para><symbol>PrepareNewRow</symbol> ensures that the
									 given row is <emphasis>equivalent</emphasis> to the data type for the table
									 node. If it is not, a new row is created based on the data type of the table
									 node, and the values from the given row are used to fill the new row. If the
									 method is given an old row parameter, this row will be used to fill in any
									 missing values in the new row. This allows a partial update to use the values
									 from the old version of the row.</para> 
								<para><symbol>PrepareOldRow</symbol> ensures that the
									 given row is <emphasis>equivalent</emphasis> to the data type for the table
									 node. If it is not, a new row is created based on the data type of the table
									 node, and the values from the given row are used to fill the new row. This new
									 row is then used to select the original row from the database. If it is not
									 found, an optimistic concurrency check exception is thrown, otherwise, the old
									 row from the database is used to fill in any missing values in the new
									 row.</para> 
						  </sect4> 
						  <sect4 id="DDGP2BeforePhase"> 
								<title><indexterm><primary>Before
												Phase</primary></indexterm>Before Phase</title> 
								<para>The before phase is implemented by different
									 methods, depending on the type of modification being performed. The basic
									 execution steps are as follows: 
									 <orderedlist> 
										  <listitem> 
												<para>Validate</para> 
										  </listitem> 
										  <listitem> 
												<para>InternalBefore</para> 
										  </listitem> 
										  <listitem> 
												<para>ValidateConstraints</para> 
										  </listitem> 
										  <listitem> 
												<para>ExecuteHandlers</para> 
										  </listitem> 
									 </orderedlist></para> 
								<para>The first step is only taken in the insert and
									 update cases, and performs row level validation of the new row value. This step
									 is implemented by the <symbol>Validate</symbol> method of the
									 <symbol>TableNode</symbol> class. In the insert case, this step also includes a
									 call to the <symbol>Default</symbol> method to provide any default values for
									 the row. This step is executed just prior to the row level validation to allow
									 defaults to be set for any missing values.</para> 
								<para>The second step is a virtual method which allows
									 descendent table nodes to perform processing during the before phase of the
									 modification.</para> 
								<para>The third step is used to perform the validation
									 of table level constraints. These are system generated constraints used to
									 enforce keys and references.</para> 
								<para>The fourth step is used to execute any handlers
									 associated with the before modification events for table variables.</para> 
								<sect5 id="DDGP2Insert"> 
									 <title><indexterm><primary>Insert</primary></indexterm><indexterm><primary>Before
													 PhaseBefore
													 Phase</primary><secondary>Insert</secondary></indexterm>Insert</title> 
									 <para>For insert modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>Default</symbol></para> 
												</listitem> 
												<listitem> 
													 <para><symbol>Validate</symbol></para> 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalBeforeInsert</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ValidateInsertConstraints</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteHandlers</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
								<sect5 id="DDGP2Update"> 
									 <title><indexterm><primary>Update</primary></indexterm><indexterm><primary>Before
													 PhaseBefore
													 Phase</primary><secondary>Update</secondary></indexterm>Update</title> 
									 <para>For update modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>Validate</symbol></para> 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalBeforeUpdate</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ValidateUpdateConstraints</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteHandlers</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
								<sect5 id="DDGP2Delete"> 
									 <title><indexterm><primary>Delete</primary></indexterm><indexterm><primary>Before
													 PhaseBefore
													 Phase</primary><secondary>Delete</secondary></indexterm>Delete</title> 
									 <para>For delete modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>InternalBeforeDelete</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ValidateDeleteConstraints</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteHandlers</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
						  </sect4> 
						  <sect4 id="DDGP2ExecutePhase"> 
								<title><indexterm><primary>Execute
												Phase</primary></indexterm>Execute Phase</title> 
								<para>The execute phase is implemented by different
									 methods, depending on the type of modification being performed. If the
									 modfication is not supported by the device, the execution is simply handed to
									 the <symbol>InternalExecuteXXX</symbol> method for propogation depending on the
									 type of node. Otherwise, the following steps are taken: 
									 <orderedlist> 
										  <listitem> 
												<para>InternalPrepareValidate</para> 
										  </listitem> 
										  <listitem> 
												<para>InternalValidateBefore</para> 
										  </listitem> 
										  <listitem> 
												<para>ExecuteDevice</para> 
										  </listitem> 
										  <listitem> 
												<para>InternalValidateAfter</para> 
										  </listitem> 
										  <listitem> 
												<para>InternalUnprepareValidate</para> 
										  </listitem> 
									 </orderedlist></para> 
								<para>These steps are used to allow descendent devices
									 to propogate the validation of a modification, without actually propogating the
									 modification itself.</para> 
								<sect5 id="DDGP2Insert2"> 
									 <title><indexterm><primary>Insert</primary></indexterm><indexterm><primary>Execute
													 PhaseExecute
													 Phase</primary><secondary>Insert</secondary></indexterm>Insert</title> 
									 <para>For insert modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>InternalPrepareValidateInsert</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateBeforeInsert</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteDeviceInsert</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateAfterInsert</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalUnprepareValidateInsert</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
								<sect5 id="DDGP2Update2"> 
									 <title><indexterm><primary>Update</primary></indexterm><indexterm><primary>Execute
													 PhaseExecute
													 Phase</primary><secondary>Update</secondary></indexterm>Update</title> 
									 <para>For update modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>InternalPrepareValidateUpdate</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateBeforeUpdate</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteDeviceUpdate</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateAfterUpdate</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalUnprepareValidateUpdate</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
								<sect5 id="DDGP2Delete2"> 
									 <title><indexterm><primary>Delete</primary></indexterm><indexterm><primary>Execute
													 PhaseExecute
													 Phase</primary><secondary>Delete</secondary></indexterm>Delete</title> 
									 <para>For delete modifications the actual steps
										  taken are: 
										  <orderedlist> 
												<listitem> 
													 <para><symbol>InternalPrepareValidateDelete</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateBeforeDelete</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>ExecuteDeviceDelete</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalValidateAfterDelete</symbol></para>
													 
												</listitem> 
												<listitem> 
													 <para><symbol>InternalUnprepareValidateDelete</symbol></para>
													 
												</listitem> 
										  </orderedlist></para> 
								</sect5> 
						  </sect4> 
						  <sect4 id="DDGP2AfterPhase"> 
								<title><indexterm><primary>After
												Phase</primary></indexterm>After Phase</title> 
								<para>The after phase is implemented by different
									 methods, depending on the type of modification being performed. The basic
									 execution steps are as follows: 
									 <orderedlist> 
										  <listitem> 
												<para>ExecuteHandlers</para> 
										  </listitem> 
										  <listitem> 
												<para>ValidateCatalogConstraints</para> 
										  </listitem> 
										  <listitem> 
												<para>InternalAfter</para> 
										  </listitem> 
									 </orderedlist></para> 
								<para>The first step is used to execute any handlers
									 associated with the after modification events for table variables.</para> 
								<para>The second step is used to validate any catalog
									 constraints that may have been affected by the modification.</para> 
								<para>The third step is a virtual method which allows
									 descendent table nodes to perform processing during the after phase of the
									 modification.</para> 
								<para>For insert modifications the actual steps taken
									 are: 
									 <orderedlist> 
										  <listitem> 
												<para><symbol>ExecuteHandlers</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>ValidateCatalogConstraints</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>InternalAfterInsert</symbol></para>
												
										  </listitem> 
									 </orderedlist></para> 
								<para>For update modifications the actual steps taken
									 are: 
									 <orderedlist> 
										  <listitem> 
												<para><symbol>ExecuteHandlers</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>ValidateCatalogConstraints</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>InternalAfterUpdate</symbol></para>
												
										  </listitem> 
									 </orderedlist></para> 
								<para>For delete modifications the actual steps taken
									 are: 
									 <orderedlist> 
										  <listitem> 
												<para><symbol>ExecuteHandlers</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>ValidateCatalogConstraints</symbol></para>
												
										  </listitem> 
										  <listitem> 
												<para><symbol>InternalAfterDelete</symbol></para>
												
										  </listitem> 
									 </orderedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2UnpreparePhase"> 
								<title><indexterm><primary>Unprepare
												Phase</primary></indexterm>Unprepare Phase</title> 
								<para>The unprepare step is implemented by simply
									 disposing any rows that were created by the prepare step.</para> 
						  </sect4> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2TypeInferenceMechanism"> 
					 <title><indexterm><primary>Type Inference
									 Mechanism</primary></indexterm>Type Inference Mechanism</title> 
					 <para>The process of determining the type of the result of an
						  expression is called type inference. For simple scalar expressions, this
						  process is simply a matter of determining the result type of the operation.
						  Because table operators are generic operators (meaning they operate on values
						  of any table type), the determination of a result type is much more involved.
						  The process can be broken down into five main steps: 
						  <orderedlist> 
								<listitem> 
									 <para>Table Type Determination</para> 
								</listitem> 
								<listitem> 
									 <para>Key Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Order Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Metadata Inference</para> 
								</listitem> 
								<listitem> 
									 <para>Reference Inference</para> 
								</listitem> 
						  </orderedlist></para> 
					 <sect3 id="DDGP2TableTypeDetermination"> 
						  <title><indexterm><primary>Table Type
										  Determination</primary></indexterm>Table Type Determination</title> 
						  <para>The table type determination step involves
								determining the set of columns in the result set. For simple table operations
								such as restrict, the set of columns is the same as the set of columns in the
								input. For natural join, it is the union of the columns in the inputs. These
								behaviors are implemented in each <symbol>TableNode</symbol> descendent by
								overriding the <symbol>DetermineDataType</symbol> method, and making use of the
								<symbol>InheritColumn</symbol> and <symbol>InheritColumns</symbol>
								methods.</para> 
					 </sect3> 
					 <sect3 id="DDGP2KeyInference"> 
						  <title><indexterm><primary>Key
										  Inference</primary></indexterm>Key Inference</title> 
						  <para>Determining the effects of a given table operation on
								the keys of the result set is called key inference, and plays a major role in
								query updatability and optimization. Each table operator determines the keys of
								the result set based on the key inference algorithms of the relational algebra.
								This processing is implemented within the <symbol>DetermineDataType</symbol>
								method of each node, and will usually make use of the
								<symbol>InheritKey</symbol>, <symbol>InheritKeys</symbol>, and
								<symbol>InheritPreservedKeys</symbol> methods of the
								<symbol>TableNode</symbol>.</para> 
					 </sect3> 
					 <sect3 id="DDGP2OrderInference"> 
						  <title><indexterm><primary>Order
										  Inference</primary></indexterm>Order Inference</title> 
						  <para>Just like inference for keys, the effects of a given
								table operation on the orders available for the result set can be determined.
								This processing is implemented by making use of the
								<symbol>InheritOrder</symbol>, <symbol>InheritOrders</symbol>, and
								<symbol>InheritPreservedOrders</symbol> methods of the
								<symbol>TableNode</symbol> instance.</para> 
					 </sect3> 
					 <sect3 id="DDGP2MetadataInference"> 
						  <title><indexterm><primary>Metadata
										  Inference</primary></indexterm>Metadata Inference</title> 
						  <para>Metadata is associated with each object in the system
								catalog. This metadata is carried along with the objects as they are inferred
								through expressions. For example, the meta data associated with a column in a
								base table, is also associated with the column of the same name in the result
								set of a restriction on that base table. This process is capable of inferring
								metadata through expressions of arbitrary complexity, so the result set of any
								table operation will always have the associated metadata defined in the logical
								model.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ReferenceInference"> 
						  <title><indexterm><primary>Reference
										  Inference</primary></indexterm>Reference Inference</title> 
						  <para>References are defined in the logical model to
								enforce certain common integrity constraints. Just like keys and orders that
								are associated with table variables, the effect of table operations on these
								references can be inferred. This means that not only the columns, keys, and
								orders of the result set are known, but how that result set is related to the
								rest of the table variables in the logical model. This processing is
								implemented by making use of the <symbol>CopySourceReference</symbol>,
								<symbol>CopySourceReferences</symbol>, <symbol>CopyTargetReference</symbol>,
								and <symbol>CopyTargetReferences</symbol> methods of the
								<symbol>TableNode</symbol> instance.</para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGSIA"> 
		  <title><indexterm><primary>Storage Integration
						  Architecture</primary></indexterm>Storage Integration Architecture</title> 
		  <para>The DAE abstracts all data access into the concept of a
				<emphasis>device</emphasis>. The base device describes all the functionality
				necessary to store, manipulate, and retrieve data from any source. The DAE
				communicates with all devices at this level, providing a framework for data
				management which can be extended to support communication with any existing
				data store. Specific devices manage the interchange between the DAE and
				existing storage systems.</para> 
		  <para>This chapter describes the various aspects of the Storage
				Integration Architecture in the DAE. The chapter will cover the following main
				areas: 
				<orderedlist> 
					 <listitem> 
						  <para>Device Architecture</para> 
					 </listitem> 
					 <listitem> 
						  <para>Processor Integration</para> 
					 </listitem> 
					 <listitem> 
						  <para>Schema Reconciliation</para> 
					 </listitem> 
					 <listitem> 
						  <para>System Devices</para> 
					 </listitem> 
					 <listitem> 
						  <para>Custom Devices</para> 
					 </listitem> 
				</orderedlist></para> 
		  <sect1 id="DDGP2DeviceArchitecture"> 
				<title><indexterm><primary>Device
								Architecture</primary></indexterm>Device Architecture</title> 
				<para>Overall, the device architecture closely mirrors the server
					 architecture of the DAE, with four main categories of functionality: 
					 <itemizedlist> 
						  <listitem> 
								<para>Device</para> 
						  </listitem> 
						  <listitem> 
								<para>Device Session</para> 
						  </listitem> 
						  <listitem> 
								<para>Device Plan</para> 
						  </listitem> 
						  <listitem> 
								<para>Device Cursor</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The device layer of the device architecture provides all the
					 services which correspond directly with an instance of the data store being
					 modeled. This includes descriptions of the types of operations which can be
					 supported by the device, as well as mappings between the device and the system
					 catalog.</para> 
				<para>The session layer of the architecture manages all the details
					 corresponding to a communication session with the device. Device sessions are
					 directly associated with the process layer of the server architecture. Only one
					 device session will exist for a given process and device. Device sessions also
					 manage transaction coordination between the DAE and the data store.</para> 
				<para>The plan layer of the device architecture is associated
					 directly with the plan layer of the server architecture. Only one device plan
					 will exist for a given server plan and device. Device plans manage any device
					 specific state associated with the prepared statement in the DAE. For example,
					 the SQL devices use device plans to store prepared versions of the translated
					 SQL commands to be invoked when processing occurs.</para> 
				<para>The cursor layer of the architecture plays the same role for
					 devices that cursors do in the server architecture, namely retrival and
					 manipulation services for the data store.</para> 
				<para>Each of these layers will be considered in detail in the
					 following sections.</para> 
				<sect2 id="DDGP2Device"> 
					 <title><indexterm><primary>Device</primary></indexterm>Device</title>
					 
					 <para>This layer of the device architecture is implemented by
						  an instance of some descendent of the abstract class
						  <symbol>Alphora.Dataphor.DAE.Schema.Device</symbol>. This class introduces the
						  functionality and behavior common to all devices.</para> 
					 <sect3 id="DDGP2DeviceState"> 
						  <title><indexterm><primary>Device
										  State</primary></indexterm>Device State</title> 
						  <para>The <symbol>Device</symbol> instance manages the
								state of the device, which is either running, or stopped. This state is exposed
								by the value of the property <symbol>Running</symbol>. State management
								services are exposed to the DAE through the methods <symbol>Start</symbol> and
								<symbol>Stop</symbol>. The system catalog manages the state of all devices
								running in the DAE. All devices are started automatically as part of system
								startup processing. When a new device is created, it is started when it is
								added to the catalog. When an existing device is destroyed, it is stopped when
								it is removed from the catalog. All devices are stopped automatically as part
								of system shutdown processing.</para> 
					 </sect3> 
					 <sect3 id="DDGP2DeviceCapabilities"> 
						  <title><indexterm><primary>Device
										  Capabilities</primary></indexterm>Device Capabilities</title> 
						  <para>The <symbol>Device</symbol> instance describes
								general behavior characteristics through the value of the
								<symbol>Capabilities</symbol> property. This property may be any combination of
								the following values: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Device
														  Capability</entry><entry>Description</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>RowLevelInsert</symbol></entry><entry>The
														  device supports inserting single rows through the <symbol>InsertRow</symbol>
														  method of the <symbol>DeviceSession</symbol> instance.</entry> 
												</row> 
												<row><entry><symbol>RowLevelUpdate</symbol></entry><entry>The
														  device supports updating single rows through the <symbol>UpdateRow</symbol>
														  method of the <symbol>DeviceSession</symbol> instance.</entry> 
												</row> 
												<row><entry><symbol>RowLevelDelete</symbol></entry><entry>The
														  device supports deleting single rows through the <symbol>DeleteRow</symbol>
														  method of the <symbol>DeviceSession</symbol> instance.</entry> 
												</row> 
												<row><entry><symbol>NonLoggedOperations</symbol></entry><entry>The
														  device supports the performance of non-logged operations. This property is only
														  used in conjunction with the non-logged context tracking mechanism of the
														  <symbol>ServerProcess</symbol>.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2SessionManagement"> 
						  <title><indexterm><primary>Session
										  Management</primary></indexterm>Session Management</title> 
						  <para>The <symbol>Device</symbol> performs session
								management, tracking all active sessions against the device using an instance
								of the class <symbol>Alphora.Dataphor.DAE.Schema.DeviceSessions</symbol>. The
								methods <symbol>Connect</symbol> and <symbol>Disconnect</symbol> expose the
								session management services to the DAE.</para> 
					 </sect3> 
					 <sect3 id="DDGP2CatalogMapping"> 
						  <title><indexterm><primary>Catalog
										  Mapping</primary></indexterm>Catalog Mapping</title> 
						  <para>Each device functions as a mapping layer between the
								system catalog of the DAE, and the device catalog of the data store. This
								mapping layer provides the translation services between the DAE and the data
								store, and contains several different types of mapping objects.</para> 
						  <sect4 id="DDGP2DataTypeMapping"> 
								<title><indexterm><primary>Data Type
												Mapping</primary></indexterm>Data Type Mapping</title> 
								<para>Each device provides translation services for the
									 types of values it supports. The <symbol>Device</symbol> instance exposes the
									 set of data types it supports through the <symbol>DeviceScalarTypes</symbol>
									 property. This property is an instance of the class
									 <symbol>Alphora.Dataphor.DAE.Schema.DeviceScalarTypes</symbol>, and contains a
									 list of instances of some descendent of the abstract class
									 <symbol>Alphora.Dataphor.DAE.Schema.DeviceScalarType</symbol>.</para> 
								<para>The <symbol>DeviceScalarType</symbol> class
									 introduces the functionality necessary to translate to and from values in the
									 device. The <symbol>ToScalar</symbol> method takes a value from the device in
									 terms of a .NET <symbol>object</symbol> value, and returns an instance of the
									 class <symbol>Scalar</symbol>. <symbol>FromScalar</symbol> performs the reverse
									 processing, taking an instance of the class <symbol>Scalar</symbol> and
									 returning a device value in terms of a .NET <symbol>object</symbol> value. The
									 <symbol>GetStreamAdapter</symbol> method provides a stream adapter capable of
									 transforming byte streams from the device to byte streams formatted for use by
									 the DAE, and vice versa.</para> 
						  </sect4> 
						  <sect4 id="DDGP2OperatorMapping"> 
								<title><indexterm><primary>Operator
												Mapping</primary></indexterm>Operator Mapping</title> 
								<para>Each device tracks the operators it is capable of
									 performing. The <symbol>Device</symbol> instance exposes the set of operators
									 it supports through the <symbol>DeviceOperators</symbol> property. This
									 property is an instance of the class
									 <symbol>Alphora.Datpahor.DAE.Schema.DeviceOperators</symbol>, and contains a
									 list of instances of some descendent of the abstract class
									 <symbol>Alphora.Dataphor.DAE.Schema.DeviceOperator</symbol>. The existence of
									 an operator mapping for a given DAE operator does not guarantee that the
									 operator is supported. This question is answered by the device during the
									 process of query chunking initiated by the compiler. This process is discussed
									 in detail in the section on query chunking.</para> 
								<para>The <symbol>DeviceOperator</symbol> class
									 provides translation services for the operator it is supporting. This
									 functionality is introduced through the method <symbol>Translate</symbol> which
									 takes an executable <symbol>PlanNode</symbol> tree as input, and returns a
									 parse tree in the language of the device. Not all devices make use of this
									 functionality, as some devices do not have a "language".</para> 
						  </sect4> 
						  <sect4 id="DDGP2UserMapping"> 
								<title><indexterm><primary>User
												Mapping</primary></indexterm>User Mapping</title> 
								<para>Each device tracks authentication information
									 specific to the data store for each user. The <symbol>Device</symbol> instance
									 exposes this user list through the <symbol>DeviceUsers</symbol> property. This
									 property is an instance of the class
									 <symbol>Alphora.Dataphor.DAE.Schema.DeviceUsers</symbol>, and contains a list
									 of intances of the class
									 <symbol>Alphora.Dataphor.DAE.Schema.DeviceUser</symbol>.</para> 
								<para>The <symbol>DeviceUser</symbol> class maintains
									 authentication information for the user being mapped that is specific to the
									 device in question. This information is exposed through the
									 <symbol>UserID</symbol> and <symbol>Password</symbol> properties. As with all
									 passwords in the DAE, the actual data of the password is stored as an encrypted
									 string, and decrypted by the system when required for authentication with the
									 data store.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2SchemaReconciliation"> 
						  <title><indexterm><primary>Schema
										  Reconciliation</primary></indexterm>Schema Reconciliation</title> 
						  <para>The <symbol>Device</symbol> class introduces the
								behavior necessary to support schema reconciliation. This process is described
								in detail later in this chapter.</para> 
					 </sect3> 
					 <sect3 id="DDGP2QueryChunking2"> 
						  <title><indexterm><primary>Query
										  Chunking</primary></indexterm>Query Chunking</title> 
						  <para>The <symbol>Device</symbol> class introduces the
								behavior necessary to support query chunking, or the process of deciding which
								device will support the various processing requirements of a given query. This
								process is described in detail later in this chapter.</para> 
						  <para>Chunking services are provided to the DAE through the
								method <symbol>Prepare</symbol>. This method takes a compiled
								<symbol>PlanNode</symbol> tree and determines whether the device supports the
								operation. If supported, this method returns an instance of the class
								<symbol>Alphora.Dataphor.DAE.Schema.DevicePlan</symbol> ready for execution
								within the device. Otherwise, a null reference is returned.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ExtendingtheDeviceClass"> 
						  <title><indexterm><primary>Extending the Device
										  Class</primary></indexterm>Extending the Device Class</title> 
						  <para>The following extensibility points are introduced by
								the device class: 
								<informaltable> 
									 <tgroup cols="2">
										  <colspec colwidth="*" colname="col1" colnum="1"/>
										  <colspec colwidth="*" colname="col2" colnum="2"/> 
										  <thead> 
												<row> 
													 <entry colname="col1"> Member </entry> 
													 <entry colname="col2"> Description
														  </entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalStart</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to perform Device initialization tasks. The base implementation of
														  this method must be called when overriding this method. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalStop</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to perform Device cleanup tasks. The base implementation of this
														  method must be called when overriding this method. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalConnect</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden and should return an instance of a <symbol>DeviceSession</symbol>
														  descendant class that will handle processing for the given user Process.
														  </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>Prepare</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to return an instance of the class, or some descendent of the class,
														  <symbol>DevicePlan</symbol> with the appropriate information necessary to
														  represent the given D4 instructions in the device. The device can return null
														  to indicate that the given query is not supported. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>CreateDevicePlan</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to return an instance of some descendent of the class
														  <symbol>DevicePlan</symbol> as appropriate for the device. The base
														  implementation of this method constructs a default instance of the class
														  <symbol>DevicePlan</symbol>. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>Reconcile</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to provide schema structure reconciliation between the devices
														  catalog and the DAE catalog. <symbol>GetDeviceCatalog</symbol> should also be
														  overridden if the Device supports reconciliation.
														  <symbol>GetDeviceCatalog</symbol> returns the entire schema structure of the
														  device for use by catalog-wide reconciliation. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>Capabilities</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to return the extended capabilities supported by the Device. These
														  are general Device capabilities not to be confused with the statements that are
														  <emphasis>supported</emphasis> by the Device. These capabilites allow the
														  Device to specify whether it support row-level updates, and whether the Device
														  is capable of non-(transaction)logged operations. </entry> 
												</row> 
												<row><entry
													 colname="col1"><symbol>GetDeviceCatalog</symbol></entry><entry
													 colname="col2">Can be overridden to provide the description of the device
														  catalog in terms of <symbol>Schema.Object</symbol> descendents. The default
														  implementation of this method returns a new instance of the class
														  <symbol>Schema.Catalog</symbol>.</entry> 
												</row> 
												<row><entry
													 colname="col1"><symbol>CreateTable</symbol></entry><entry colname="col2">Can be
														  overridden to actually perform the table creation in the device. This method
														  will be called by the reconciliation process whenever it is determined that a
														  table in the DAE's catalog should be created in the target system.</entry> 
												</row> 
												<row><entry
													 colname="col1"><symbol>ReconcileTable</symbol></entry><entry colname="col2">Can
														  be overridden to actually perform the table reconciliation in the device. This
														  method will be called by the reconiliation process whenever it is determined
														  that a table in the DAE's catalog must be reconciled with an existing table in
														  the target system.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable> </para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2DeviceSession"> 
					 <title><indexterm><primary>Device
									 Session</primary></indexterm>Device Session</title> 
					 <para>The session layer of the device architecture is
						  implemented by instances of some descendent of the abstract base class
						  <symbol>Alphora.Dataphor.DAE.Schema.DeviceSession</symbol>. Instances of this
						  class represent communication channels with devices in the DAE, and manage the
						  associated state. Each device descendent implements a specific device session
						  to handle this layer of the architecture. Each device session is associated
						  with exactly one <symbol>ServerProcess</symbol> instance.</para> 
					 <sect3 id="DDGP2SessionInformation2"> 
						  <title><indexterm><primary>Session
										  Information</primary></indexterm>Session Information</title> 
						  <para>Each device session has associated session
								information which contains authentication information for the session. This
								information is represented by an instance of the class
								<symbol>DeviceSessionInfo</symbol> and exposed through the property
								<symbol>DeviceSessionInfo</symbol> of the <symbol>DeviceSession</symbol>
								instance. Device session information may also contain connection parameters
								specific to the user or device in question. For example, connection parameters
								may be specified for a given user of an MSSQL device to indicate that
								integrated security should be used to connect to the SQL Server.</para> 
					 </sect3> 
					 <sect3 id="DDGP2TransactionManagement"> 
						  <title><indexterm><primary>Transaction
										  Management</primary></indexterm>Transaction Management</title> 
						  <para>The <symbol>DeviceSession</symbol> class exposes
								transaction management services to the DAE. The transaction manager in the
								server process coordinates transactions among the different devices using these
								methods. 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Method</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>BeginTransaction</symbol></entry><entry>Begins
														  a new transaction in the device session and increments the value of
														  <symbol>TransactionCount</symbol> by 1.</entry> 
												</row> 
												<row><entry><symbol>PrepareTransaction</symbol></entry><entry>Prepares
														  the current transaction for commit.</entry> 
												</row> 
												<row><entry><symbol>CommitTransaction</symbol></entry><entry>Commits
														  the current transaction in the device session and decrements the value of
														  <symbol>TransactionCount</symbol> by 1.</entry> 
												</row> 
												<row><entry><symbol>RollbackTransaction</symbol></entry><entry>Rolls
														  back the current transaction in the device session and decrements the value of
														  <symbol>TransactionCount</symbol> by 1.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The <symbol>TransactionCount</symbol> property
								indicates the transaction nesting level of the current device session. The
								<symbol>InTransaction</symbol> property indicates whether the device session is
								currently involved in any transaction, and is equivalent to evaluating the
								expression <symbol>TransactionCount &gt; 0</symbol>.</para> 
						  <para>The abstract device only tracks the transaction
								nesting level. No transaction management is actually performed. Each descendent
								device must implement transaction management as appropriate for the data store
								being modeled.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Execution4"> 
						  <title><indexterm><primary>Execution</primary></indexterm>Execution</title>
						  
						  <para>The <symbol>DeviceSession</symbol> class provides
								execution services to the DAE by introducing the <symbol>Execute</symbol>
								method. This method takes an instance of the class
								<symbol>Alphora.Dataphor.DAE.Schema.DevicePlan</symbol>, and is responsible for
								performing the operation it describes.</para> 
					 </sect3> 
					 <sect3 id="DDGP2Modification"> 
						  <title><indexterm><primary>Modification</primary></indexterm>Modification</title>
						  
						  <para>Modification to the data in a given device can occur
								through the <symbol>Execute</symbol> method using a DML modification statement
								as the code to be executed, or it can occur through the row-level methods
								exposed by the <symbol>DeviceSession</symbol> class. If the capabilities of a
								given device indicate that row-level modifications are supported, the
								<symbol>DeviceSession</symbol> is responsible for implementing the behavior
								using the <symbol>InsertRow</symbol>, <symbol>UpdateRow</symbol>, and
								<symbol>DeleteRow</symbol> methods.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ExtendingtheDeviceSessionClass"> 
						  <title><indexterm><primary>Extending the DeviceSession
										  Class</primary></indexterm>Extending the DeviceSession Class</title> 
						  <para>The following is a list of virtual members that are
								of interest when descending from a <symbol>DeviceSession</symbol> class. 
								<informaltable> 
									 <tgroup cols="2">
										  <colspec colwidth="*" colname="col1" colnum="1"/>
										  <colspec colwidth="*" colname="col2" colnum="2"/> 
										  <thead> 
												<row> 
													 <entry colname="col1"> Member </entry> 
													 <entry colname="col2"> Description
														  </entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalBeginTransaction</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to begin a new or nested transaction within the device session. If
														  the data source does not support nested transactions (as most don't) the device
														  should simulate the behavior using some type of transaction counting mechanism.
														  </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalPrepareTransaction</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to prepare the currently active transaction. Prepare is part of two
														  phase commit protocol (2PC) used to ensure that if the transaction were to be
														  committed, it would succeed. Two phase commit is used to perform distributed
														  transaction coordination. 2PC works by preparing the transaction on each device
														  before committing it, which ensures that the cumulative transaction will commit
														  successfully. If a device supports 2PC, it should perform the necessary prepare
														  step in this override. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalCommitTransaction</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to commit the currently active transaction. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalRollbackTransaction</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to roll back the currently active transaction. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalExecute</symbol> </entry> 
													 <entry colname="col2"> Must be
														  overridden to execute the given plan against the device. This method is called
														  at run-time if the device indicated at compile-time that it could execute the
														  specified chunk of the query. This method must return the result of evaluating
														  the specified chunk of the query in a form suitable for consumption by the DAE,
														  namely as an instance of some descendent of the class
														  <symbol>DataValue</symbol> wrapped in an instance of the class
														  <symbol>DataVar</symbol>. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalInsertRow</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to perform a row-level insert against the device. This will only be
														  called if the device supports row level insert. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalUpdateRow</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to perform a row-level update against the device. This will only be
														  called if the device supports row level update. </entry> 
												</row> 
												<row> 
													 <entry colname="col1">
														  <symbol>InternalDeleteRow</symbol> </entry> 
													 <entry colname="col2"> Can be
														  overridden to perform a row-level delete against the device. This will only be
														  called if the device supports row level delete. </entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2DevicePlan"> 
					 <title><indexterm><primary>Device
									 Plan</primary></indexterm>Device Plan</title> 
					 <para>The plan layer of the device architecture is implemented
						  by instances of the class
						  <symbol>Alphora.Dataphor.DAE.Schema.DevicePlan</symbol>. The plan layer
						  provides a compile-time state manager for the devices and provides a device
						  specific extension to the plan layer of the server architecture. Each device
						  plan is associated with exactly one <symbol>ServerPlanBase</symbol>
						  instance.</para> 
					 <para><symbol>DevicePlan</symbol> instances are manufactured by
						  the <symbol>Prepare</symbol> method exposed on the <symbol>Device</symbol>
						  instances. Each device builds a <symbol>DevicePlan</symbol> that contains the
						  appropriate information to execute the D4 assembly in the device. This
						  <symbol>DevicePlan</symbol> instance is passed directly to the
						  <symbol>Execute</symbol> method of the <symbol>DeviceSession</symbol> instance
						  for execution.</para> 
				</sect2> 
				<sect2 id="DDGP2DeviceCursor"> 
					 <title><indexterm><primary>Device
									 Cursor</primary></indexterm>Device Cursor</title> 
					 <para>The cursor layer of the device architecture is
						  implemented by each specific device as necessary. This layer is described by
						  the same mechanism as any other cursor in the system, namely the
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.Table</symbol> class. Each device
						  uses a specific descendent of this class to implement device cursors.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2ProcessorIntegration"> 
				<title><indexterm><primary>Processor
								Integration</primary></indexterm>Processor Integration</title> 
				<para>When an operation of D4 assembly is processed by some device,
					 it is the responsibility of that device to provide the results of the operation
					 in terms the DAE can understand. Conversely, when modification to the data
					 contained in a particular device is required, it is the responsibility of the
					 device to translate the request for modification from the DAE into a form that
					 can be consumed by the data store being modeled. The Storage Integration
					 Architecture provides the framework for the solution to this problem.</para> 
				<para>Processor integration occurs whenever the DAE requires data
					 from some device, or whenever a device needs to be updated to reflect the
					 changes made by some statement in the DAE. The query chunking process
					 determines where both of these integration points occur.</para> 
				<para>This section first describes the retrieval integration, then
					 the modification integration, and concludes with a description of how these
					 integration points are determined by the compiler.</para> 
				<sect2 id="DDGP2DataRetrieval"> 
					 <title><indexterm><primary>Data
									 Retrieval</primary></indexterm>Data Retrieval</title> 
					 <para>The <symbol>Execute</symbol> method of the
						  <symbol>DeviceSession</symbol> instance provides an alternative execution path
						  for the query processor to follow. The execution path can be thought of as
						  leaving the query processor at the device execute, and re-entering when the
						  device processing has completed. The results of the processing are returned as
						  a <symbol>DataVar</symbol>, just like any other execution in the query
						  processor. This allows device execution to completely replace query processing
						  at any point in the code. This means that devices are not only capable of
						  delivering data in the form of tables, but also scalar values, row values,
						  etc.,.</para> 
					 <para>When non-table values are returned, device processing has
						  generally completed, and the value returned is autonomous in the sense that the
						  device session could be closed, without affecting the availability of the
						  value. For table values, this is generally not the case. Just as in the DAE,
						  device supported table values are materialized on demand using cursors. For
						  this reason, a typical device will provide a <symbol>Table</symbol> descendent
						  to implement the device cursor behavior.</para> 
					 <para>As a result, whatever operation is performed on the
						  device is completely hidden from the DAE. The DAE only consumes the resulting
						  cursor. This allows device cursors to participate in the query processor of the
						  DAE just like any other table value. This has important implications for query
						  optimization.</para> 
				</sect2> 
				<sect2 id="DDGP2DataModification"> 
					 <title><indexterm><primary>Data
									 Modification</primary></indexterm>Data Modification</title> 
					 <para>In general, data modification can be supported by a given
						  device at a different level than retrieval. This allows the query updatability
						  capabilities of the DAE to be mapped onto devices which may not support the
						  same functionality, without compromising the retrieval characteristics of the
						  device.</para> 
					 <para>There are three mechanisms by which a device may perform
						  data modifications: 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para>Modification Statements</para> 
									 <para>Devices may execute complete insert, update,
										  and delete instructions. Devices supporting this form of update handling must
										  implement the appropriate behavior in the <symbol>InternalPrepare</symbol> and
										  <symbol>InternalExecute</symbol> methods.</para> 
								</listitem> 
								<listitem> 
									 <para>Cursor Updates</para> 
									 <para>Devices may provide updatability through
										  cursors. This is indicated using the <symbol>Updatable</symbol> cursor
										  capability.</para> 
								</listitem> 
								<listitem> 
									 <para>Row Level Updates</para> 
									 <para> Devices may provide updatability through row
										  level commands. This is indicated by the <symbol>RowLevelInsert</symbol>,
										  <symbol>RowLevelUpdate</symbol>, and <symbol>RowLevelDelete</symbol> device
										  capabilities. Devices supporting this form of update handling must implement
										  the appropriate behavior in the <symbol>InternalInsertRow</symbol>,
										  <symbol>InternalUpdateRow</symbol>, and <symbol>InternalDeleteRow</symbol>
										  methods.</para> 
								</listitem> 
						  </itemizedlist></para> 
				</sect2> 
				<sect2 id="DDGP2QueryChunking3"> 
					 <title><indexterm><primary>Query
									 Chunking</primary></indexterm>Query Chunking</title> 
					 <para>Query chunking is the process of determining exactly
						  where a processor integration point will occur during the processing of a
						  specific query. This process is implemented by the <symbol>PlanNode</symbol>
						  method <symbol>DetermineDevice</symbol>. This method is called as part of the
						  compilation process as described in the Runtime Architecture chapter.</para> 
					 <para>Basically, the process involves ensuring that a given
						  branch of the executable tree can be entirely contained within a device, and
						  then requesting that the device prepare this portion of the code. At this
						  point, the device will either provide a prepared plan ready for execution in
						  the device, or return a null reference, indicating that the requested operation
						  cannot be performed by the device.</para> 
					 <para>The query chunking algorithm begins at the leaf nodes of
						  the tree. A leaf node is either a <symbol>BaseTableVarNode</symbol> indicating
						  the retrieval of some table variable, or some other node such as a literal
						  value. For the base table variable retrieval, the node is assigned to be
						  processed on the device responsible for storage of the base table variable. The
						  device in question is required to support this operation. For other types of
						  leaf nodes, no device is assigned, indicating the node is device associative.
						  </para> 
					 <para>A device associative node is one for which the device can
						  only be determined in the context of some other operation. For example,
						  supporting an arbitrary scalar operation depends on which device, if any, is
						  requested to support the operation. At the level of the operation itself, no
						  device association is made, and only when the operation is requested within the
						  context of some other operation that is associated with a given device can the
						  device determination be made.</para> 
					 <para>As the compiler builds the tree, the devices are asked
						  whether they support the operations involved at a higher and higher level until
						  either the devices no longer support the operations involved, or the operation
						  spans multiple devices. In either of these cases, the <symbol>NoDevice</symbol>
						  flag is set for the node, and processing is handled by the DAE.</para> 
					 <para>The supports question is asked by calling the
						  <symbol>Prepare</symbol> method of the device passing the current branch of the
						  instruction tree. This prepare step invokes the device compiler for translating
						  the D4 instructions into equivalent instructions in the device. If the device
						  compilation step is successful, the result of this call is an instance of some
						  descendent of the class <symbol>DevicePlan</symbol> which can then be passed to
						  the <symbol>Execute</symbol> method of the device session at run-time. If the
						  device compilation step fails, the result of this call is a null reference,
						  indicating that the device cannot support the given instructions.</para> 
					 <para>This algorithm naturally produces an expression tree
						  which is optimized to offload as much processing as possible to the devices
						  involved. If only a single device is involved and all the operations are
						  supported by that device, the entire tree is processed externally. Only when
						  the multiple devices are involved, or some operation is requested which a
						  device cannot perform, does the DAE perform processing.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2SchemaReconciliation2"> 
				<title><indexterm><primary>Schema
								Reconciliation</primary></indexterm>Schema Reconciliation</title> 
				<para>Reconciliation is the process of synchronizing the catalog of
					 the data store represented by a device, with all or part of the catalog of the
					 DAE. The state of a storage device includes two properties that control
					 reconciliation: 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Property</entry><entry>Description</entry>
										  
									 </row></thead><tbody> 
									 <row><entry><symbol>Master</symbol></entry><entry>Specifies
												which catalog is used as the master for schema reconciliation. Valid values for
												this property are <symbol>Server</symbol>, <symbol>Device</symbol>, or
												<symbol>Both</symbol>.</entry> 
									 </row> 
									 <row><entry>
												<symbol>Mode</symbol></entry><entry>Specifies when schema reconciliation
												occurs. Valid values are <symbol>None</symbol> or any combination of
												<symbol>Startup</symbol>, <symbol>Command</symbol>, and
												<symbol>Automatic</symbol>.</entry> 
									 </row></tbody> 
						  </tgroup> 
					 </informaltable> </para> 
				<para><symbol>Startup</symbol> indicates that the device should be
					 reconciled as part of system startup processing. <symbol>Command</symbol>
					 indicates that DDL commands executed against the DAE should be executed against
					 the device as well. <symbol>Automatic</symbol> indicates that catalog should be
					 verified as it is encountered in data manipulation statements executed against
					 the DAE.</para> 
				<para>The <symbol>Master</symbol> and <symbol>Mode</symbol>
					 properties are set as part of device creation, and can be altered using the
					 appropriate DDL statement.</para> 
				<para>In addition to any reconciliation performed as indicated by
					 the value of the <symbol>Mode</symbol> property, the <symbol>Reconcile</symbol>
					 operator can be used to manually initiate the process. The
					 <symbol>Reconcile</symbol> operator takes the name of the device as an argument
					 and uses the <symbol>Master</symbol> property specified for that device.</para>
				
				<para>Devices may support reconciliation uni-directionally,
					 bi-directionally, or not at all. A device may also support some reconciliation
					 settings, but not others. Catalog reconciliation for a device proceeds as
					 follows. Beyond this basic specification, each device may provide additional
					 reconciliation support. 
					 <orderedlist> 
						  <listitem> 
								<para>If the value of the <symbol>Master</symbol>
									 property for a device is <symbol>Server</symbol> or <symbol>Both</symbol>, each
									 table variable in the system catalog which is supported by the device is
									 reconciled against the device. If the table variable does not exist in the
									 device, it is created, otherwise, it is reconciled with the DAE as
									 master.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the <symbol>Master</symbol> setting for a
									 device is <symbol>Device</symbol> or <symbol>Both</symbol>, each table variable
									 in the device catalog is reconciled against the DAE. If the table variable does
									 not exist in the DAE, it is created, otherwise, it is reconciled with the
									 device as master.</para> 
						  </listitem> 
					 </orderedlist> Catalog reconciliation for a single table
					 variable proceeds as follows 
					 <orderedlist> 
						  <listitem> 
								<para>If the DAE table variable is master, the columns
									 in the Device table variable must be a superset of the columns in the DAE table
									 variable.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the device table is master, the columns in the
									 DAE table variable must be a superset of the columns in the Device table
									 variable.</para> 
						  </listitem> 
					 </orderedlist> </para> 
		  </sect1> 
		  <sect1 id="DDGP2SystemDevices2"> 
				<title><indexterm><primary>System
								Devices</primary></indexterm>System Devices</title> 
				<para>The DAE uses several system devices to provide basic query
					 processing and data manipulation services. These devices include a memory
					 device, which functions as a temporary storage area, a catalog device which is
					 used to facilitate system catalog queries, and an application transaction
					 device which supports the application transactions feature of the DAE.</para> 
				<para>Each of these devices is described in detail in the following
					 sections.</para> 
				<sect2 id="DDGP2MemoryDevice"> 
					 <title><indexterm><primary>Memory
									 Device</primary></indexterm>Memory Device</title> 
					 <para>The memory device uses system memory as its data store.
						  The <symbol>System.Temp</symbol> and <symbol>System.Heap</symbol> devices are
						  memory devices. This device is implemented as an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Device.Memory.MemoryDevice</symbol>. The session
						  layer of this device is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Device.Memory.MemoryDeviceSession</symbol>. The
						  device has no compile-time state to track, and so does not make use of the plan
						  layer of the device architecture.</para> 
					 <para>This device only supports table variable retrieval, and
						  row-level modification. Table variables are stored using an instance of the
						  class <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableBuffers</symbol> which
						  contains an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableBuffer</symbol> for every table
						  variable stored in the device.</para> 
					 <para>The device cursor is implemented as an instance of the
						  class <symbol>Alphora.Dataphor.DAE.Device.Memory.MemoryScan</symbol>. This
						  class descends from
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableScan</symbol> which provides a
						  cursor interface to the data in a <symbol>TableBuffer</symbol>. The
						  <symbol>Execute</symbol> method of the device for a
						  <symbol>BaseTableVarNode</symbol> simply returns a new
						  <symbol>MemoryScan</symbol> instance ranging over the data in the
						  <symbol>TableBuffer</symbol> for the table variable referenced by the retrieve
						  node.</para> 
					 <para>Modification for table variables in the memory device is
						  allowed to propogate through the expression tree back to the
						  <symbol>BaseTableVarNode</symbol> which hands the modifications to the
						  row-level methods of the <symbol>DeviceSession</symbol>.</para> 
					 <para>The memory device implements transaction management by
						  tracking a list of instances of the class
						  <symbol>Alphora.Dataphor.DAE.Device.Memory.MemoryTransaction</symbol> for each
						  active transaction in the device. This instance tracks which operations have
						  occurred against the device, and is used by the device session in response to a
						  rollback to undo the affects of the transaction.</para> 
				</sect2> 
				<sect2 id="DDGP2CatalogDevice"> 
					 <title><indexterm><primary>Catalog
									 Device</primary></indexterm>Catalog Device</title> 
					 <para>The catalog device provides access to the system catalog
						  as a set of table variables. This device is very similar in architecture to the
						  memory device. The catalog device is read only, so no transaction management is
						  required. This device is implemented as an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Device.Catalog.CatalogDevice</symbol>. The session
						  layer is implemented by the class
						  <symbol>Alphora.Dataphor.DAE.Device.Catalog.CatalogDeviceSession</symbol>. No
						  compile-time state is required so the device does not make use of the plan
						  layer of the device architecture.</para> 
					 <para>This device only supports table variable retrieval. Table
						  variables are materialized on demand as instances of the class
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableBuffer</symbol>. The class
						  <symbol>Alphora.Dataphor.DAE.Device.Catalog.CatalogTypes</symbol> describes the
						  types of the table variables in the system catalog.</para> 
					 <para>The device cursor is implemented as an instance of the
						  class <symbol>Alphora.Dataphor.DAE.Device.Catalog.CatalogScan</symbol>. Like
						  the memory device cursor, this class also descends from
						  <symbol>Alphora.Dataphor.DAE.Runtime.Data.TableScan</symbol>. The
						  <symbol>Execute</symbol> method of the device for a
						  <symbol>BaseTableVarNode</symbol> simply generates a
						  <symbol>TableBuffer</symbol> instance, populates it with the requested data
						  based on the internal structures in the system catalog, and returns an instance
						  of the <symbol>CatalogScan</symbol> class.</para> 
				</sect2> 
				<sect2 id="DDGP2ApplicationTransactionDevice"> 
					 <title><indexterm><primary>Application Transaction
									 Device</primary></indexterm>Application Transaction Device</title> 
					 <para>The application transaction device provides the data
						  store in which application transaction occur. This device is much more involved
						  than the other two system devices, and only the basic implementation aspects
						  are discussed here. For a complete discussion of application transactions, see
						  the chapter on Application Targeted Features.</para> 
					 <para>The application transaction device is implemented as an
						  instance of the class
						  <symbol>Alphora.Dataphor.DAE.Device.ApplicationTransaction.ApplicationTransactionDevice</symbol>.
						  The session layer of the device is implemented as an instance of the class
						  <symbol>Alphora.Dataphor.DAE.Device.ApplicationTransaction.ApplicationTransactionDeviceSession</symbol>.
						  Transaction management is implemented for this device using instances of the
						  class
						  <symbol>Alphora.Dataphor.DAE.Device.ApplicationTransaction.ApplicationTransactionDeviceTransaction</symbol>.</para>
					 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGP2SQLDevices"> 
				<title><indexterm><primary>SQL Devices</primary></indexterm>SQL
					 Devices</title> 
				<para>The Dataphor toolset includes several DAE devices designed to
					 support various commercial SQL-based DBMSs. The common aspects of supporting
					 these systems are abstracted into a base device from which the others descend.
					 Most of the functionality for these systems is provided by this base device,
					 with support for each specific system implementing only those peices that
					 differ from Common SQL.</para> 
				<para>Note that while this device could be said to support the ANSI
					 standard version of SQL, this is not entirely correct. No system implements the
					 standard completely, and each system deviates from the standard enough to
					 prevent a single device from being built to support all SQL systems. As a
					 result, the SQL that is common among the different systems is only the peices
					 that they all implement the same way. For this reason, we choose to call the
					 SQL support implemented by the base device "Common" SQL.</para> 
				<para>Common SQL support is provided by extending the
					 infrastructure of the DAE to support the different aspects of an SQL-based
					 DBMS. This involves extending language support, providing data type and
					 language translation services, and providing a connectivity layer which the DAE
					 can use to communicate with these systems. The actual base SQL device then
					 coordinates the use of these layers to provide the framework for supporting
					 specific SQL-based systems.</para> 
				<sect2 id="DDGP2SQLLanguage"> 
					 <title><indexterm><primary>SQL
									 Language</primary></indexterm>SQL Language</title> 
					 <para>The namespace
						  <symbol>Alphora.Dataphor.DAE.Language.SQL</symbol> extends the basic language
						  elements described in the DAE to provide a mechanism for describing parsed
						  statements of Common SQL. The class
						  <symbol>Alphora.Dataphor.DAE.Language.SQL.SQLTextEmitter</symbol> provides an
						  emitter for Common SQL. Each device specializes both the language elements, and
						  the emitter to describe the specific dialect of SQL used by a given system. For
						  example, the Microsoft SQL Server Device extends the language elements using
						  the classes in the namespace
						  <symbol>Alphora.Dataphor.DAE.Language.TSQL</symbol>, and descends a new
						  emitter, <symbol>Alphora.Dataphor.DAE.Language.TSQL.TSQLTextEmitter</symbol> to
						  provide statement emission services.</para> 
					 <para>In this way, each device is capable of precisely
						  describing the specific dialect of SQL that is used by a given system.</para> 
				</sect2> 
				<sect2 id="DDGP2SQLDataTypes"> 
					 <title><indexterm><primary>SQL Data
									 Types</primary></indexterm>SQL Data Types</title> 
					 <para>Common SQL provides several basic data types which most
						  SQL-based systems support. The base device does not register these data types,
						  so it is the responsibility of the descendent device to define which data types
						  are supported, and possibly provide other data types as well.</para> 
					 <para>In order to completely describe any SQL data type, the
						  SQL connectivity layer introduces a hierarchy of classes descended from the
						  abstract base class <symbol>Alphora.Dataphor.DAE.Connection.SQLType</symbol>.
						  These classes do not provide translation services, they simply provide
						  representations of the data types. These descriptions are used by the
						  connectivity layer to describe the types of values being relayed. For a
						  complete discussion of these data type descriptions, refer to the section on
						  SQL Connectivity.</para> 
					 <para>Common SQL support introduces a new
						  <symbol>DeviceScalarType</symbol> descendent called
						  <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLDomain</symbol> to introduce
						  translation support for SQL data types. All the scalar type mappings for the
						  SQL devices descend from this class. It introduces the
						  <symbol>GetSQLType</symbol> method which returns an instance of some descendent
						  of the class <symbol>SQLType</symbol> to describe the SQL domain to be used to
						  map values of the given type.</para> 
					 <para>The following table lists the data types provided in
						  Common SQL, the supporting D4 system type, and the <symbol>SQLDomain</symbol>
						  descendent responsible for the support: 
						  <informaltable> 
								<tgroup cols="3"><thead> 
										  <row><entry>D4 Data Type</entry><entry>Common
													 SQL Data Type</entry><entry>Translation Class</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER
													 (0 or 1)</entry><entry><symbol>SQLBoolean</symbol></entry> 
										  </row> 
										  <row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
													 <symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
										  </row> 
										  <row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
													 8)</entry><entry><symbol>SQLMoney</symbol></entry> 
										  </row> 
										  <row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>System.String</symbol>,
													 <symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
													 CLOB</entry><entry><symbol>SQLString</symbol></entry> 
										  </row> 
										  <row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
												
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The following table lists metadata tags that can be used
						  to control reconciliation and value translation in the SQL devices: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Tag
													 Name</entry><entry>Meaning</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>Storage.Name</symbol></entry><entry>Indicates
													 that the object on which it appears should be identified by the value of the
													 tag when referenced within the device.</entry> 
										  </row> 
										  <row><entry><symbol>Storage.Length</symbol></entry><entry>Indicates
													 the storage length for translated domains. This tag is only used for the string
													 domains (<symbol>System.String</symbol> and <symbol>System.IString</symbol>) to
													 indicate the length of the VARCHAR data type to be used. If the value of this
													 tag is <symbol>unlimited</symbol>, the SQL column will use a CLOB, or
													 equivalent text storage data type.</entry> 
										  </row> 
										  <row><entry><symbol>Storage.Precision</symbol></entry><entry>Indicates
													 the storage precision for exact numeric data in translated domains. This tag is
													 only used for the <symbol>System.Decimal</symbol> domain to indicate the
													 precision of the DECIMAL data type to be used.</entry> 
										  </row> 
										  <row><entry><symbol>Storage.Scale</symbol></entry><entry>Indicates
													 the storage scale for exact numeric data in translated domains. This tag is
													 only used for the <symbol>System.Decimal</symbol> domain to indicate the scale
													 of the DECIMAL data type to be used.</entry> 
										  </row> 
										  <row><entry><symbol>Storage.Deferred</symbol></entry><entry>Indicates
													 that the values for the column or domain on which it appears should be read
													 entirely as overflow. If the value of this tag is <symbol>true</symbol>, the
													 system will not retrieve values from this column when the table is selected,
													 rather, the device will defer reading of the value for this column until it is
													 actually read by the client application. At that point, a separate stream is
													 used to read data for the column.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGP2SQLOperators"> 
					 <title><indexterm><primary>SQL
									 Operators</primary></indexterm>SQL Operators</title> 
					 <para>Common SQL support provides operator mapping classes for
						  many of the D4 system operators. For the table operators, these classes descend
						  directly from <symbol>Alphora.Dataphor.DAE.Schema.DeviceOperator</symbol>. For
						  the scalar operators, several new base classes are introduced to abstract
						  support for common operators.</para> 
					 <para>The following table lists the
						  <symbol>DeviceOperator</symbol> descendent responsible for translation for the
						  D4 table operators: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>D4 Table
													 Operator</entry><entry>Translation Class</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>iRetrieve</symbol></entry><entry><symbol>SQLRetrieve</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iAdorn</symbol></entry><entry><symbol>SQLAdorn</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iRestrict</symbol></entry><entry><symbol>SQLRestrict</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iProject</symbol></entry><entry><symbol>SQLProject</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iRename</symbol></entry><entry><symbol>SQLRename</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iExtend</symbol></entry><entry><symbol>SQLExtend</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iRedefine</symbol></entry><entry><symbol>SQLRedefine</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iAggregate</symbol></entry><entry><symbol>SQLAggregate</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iOrder</symbol></entry><entry><symbol>SQLOrder</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iUnion</symbol></entry><entry><symbol>SQLUnion</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iDifference</symbol></entry><entry><symbol>SQLDifference</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iJoin</symbol></entry><entry><symbol>SQLJoin</symbol></entry>
												
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>For scalar operators, Common SQL support introduces the
						  abstract base class
						  <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLOperator</symbol> to describe the
						  translation behavior of an SQL operator. This class introduces the
						  <symbol>GetInstruction</symbol> method to translate between D4 instructions and
						  SQL instructions, and the <symbol>GetIsBooleanContext</symbol> method to
						  indicate whether arguments to the operator are allowed to be boolean values.
						  <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLUnaryOperator</symbol> and
						  <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLBinaryOperator</symbol> are then
						  descended to provide support for unary and binary operators,
						  respectively.</para> 
					 <para>From these basic classes, device operators are built to
						  handle most of the D4 system operators. These classes are registered as
						  operator maps in the base device. Specific devices introduce more functionality
						  to handle other system operators as appropriate for the device in
						  question.</para> 
					 <para>The following table lists the default operator mappings
						  for all SQL devices and the associated translation handlers: 
						  <informaltable> 
								<tgroup cols="3"><thead> 
										  <row><entry>D4 Operator</entry><entry>SQL
													 Equivalent</entry><entry>Translation Handler</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>iEqual</symbol>(<symbol>=</symbol>),
													 all
													 overloads</entry><entry><symbol>=</symbol></entry><entry><symbol>SQLEqual</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iNotEqual</symbol>(<symbol>&lt;&gt;</symbol>),
													 all
													 overloads</entry><entry><symbol>&lt;&gt;</symbol></entry><entry><symbol>SQLNotEqual</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iInclusiveLess</symbol>(<symbol>&lt;=</symbol>),
													 all
													 overloads</entry><entry><symbol>&lt;=</symbol></entry><entry><symbol>SQLInclusiveLess</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iLess</symbol>(<symbol>&lt;</symbol>),
													 all
													 overloads</entry><entry><symbol>&lt;</symbol></entry><entry><symbol>SQLLess</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iInclusiveGreater</symbol>(<symbol>&gt;=</symbol>),
													 all
													 overloads</entry><entry><symbol>&gt;=</symbol></entry><entry><symbol>SQLInclusiveGreater</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iGreater</symbol>(<symbol>&gt;</symbol>),
													 all
													 overloads</entry><entry><symbol>&gt;</symbol></entry><entry><symbol>SQLGreater</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iCompare</symbol>(<symbol>?=</symbol>),
													 all overloads</entry><entry><symbol>case when X = Y then 0 else case when X
													 &lt; Y then - 1 else 1 end
													 end</symbol></entry><entry><symbol>SQLCompare</symbol></entry> 
										  </row> 
										  <row><entry><symbol>iBitwiseNot</symbol>(<symbol>~</symbol>),
													 all
													 overloads</entry><entry><symbol>~</symbol></entry><entry><symbol>SQLBitwiseNot</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iBitwiseAnd</symbol>(<symbol>&amp;</symbol>),
													 all
													 overloads</entry><entry><symbol>&amp;</symbol></entry><entry><symbol>SQLBitwiseAnd</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iBitwiseOr</symbol>(<symbol>|</symbol>),
													 all
													 overloads</entry><entry><symbol>|</symbol></entry><entry><symbol>SQLBitwiseOr</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iBitwiseXor</symbol>(<symbol>^</symbol>),
													 all
													 overloads</entry><entry><symbol>^</symbol></entry><entry><symbol>SQLBitwiseXor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iLeftShift</symbol>(<symbol>&lt;&lt;</symbol>),
													 all
													 overloads</entry><entry><symbol>&lt;&lt;</symbol></entry><entry><symbol>SQLLeftShift</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iRightShift</symbol>(<symbol>&gt;&gt;</symbol>),
													 all
													 overloads</entry><entry><symbol>&gt;&gt;</symbol></entry><entry><symbol>SQLRightShift</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iNegate</symbol>(unary
													 <symbol>-</symbol>), all
													 overloads</entry><entry><symbol>-</symbol></entry><entry><symbol>SQLNegate</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iAddition</symbol>(<symbol>+</symbol>),
													 all overloads except for
													 <symbol>String</symbol></entry><entry><symbol>+</symbol></entry><entry><symbol>SQLAddition</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iSubtraction</symbol>(<symbol>-</symbol>),
													 all
													 overloads</entry><entry><symbol>-</symbol></entry><entry><symbol>SQLSubtraction</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iMultiplication</symbol>(<symbol>*</symbol>),
													 all
													 overloads</entry><entry><symbol>*</symbol></entry><entry><symbol>SQLMultiplication</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iDivision</symbol>(<symbol>/</symbol>),
													 all integer types and <symbol>TimeSpan</symbol></entry><entry><symbol>cast(X as
													 decimal(28, 8) / cast(Y as decimal(28,
													 8)</symbol></entry><entry><symbol>SQLIntegerDivision</symbol></entry> 
										  </row> 
										  <row><entry><symbol>iDivision</symbol>(<symbol>/</symbol>),
													 <symbol>Decimal</symbol> and
													 <symbol>Money</symbol></entry><entry><symbol>/</symbol></entry><entry><symbol>SQLDivision</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iDiv</symbol>(<symbol>div</symbol>),
													 all integer
													 types</entry><entry><symbol>/</symbol></entry><entry><symbol>SQLDivision</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iMod</symbol>(<symbol>mod</symbol>),
													 all integer
													 types</entry><entry><symbol>%</symbol></entry><entry><symbol>SQLMod</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iNot</symbol>(<symbol>not</symbol>),
													 <symbol>Boolean</symbol></entry><entry><symbol>not</symbol></entry><entry><symbol>SQLNot</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iAnd</symbol>(<symbol>and</symbol>),
													 <symbol>Boolean</symbol></entry><entry><symbol>and</symbol></entry><entry><symbol>SQLAnd</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iOr</symbol>(<symbol>or</symbol>),
													 <symbol>Boolean</symbol></entry><entry><symbol>or</symbol></entry><entry><symbol>SQLOr</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iXor</symbol>(<symbol>xor</symbol>),
													 <symbol>Boolean</symbol></entry><entry><symbol>(X or Y) and not (X and
													 Y)</symbol></entry><entry><symbol>SQLXor</symbol></entry> 
										  </row> 
										  <row><entry><symbol>IsNull(Alpha)</symbol></entry><entry><symbol>X
													 is null</symbol></entry><entry><symbol>SQLIsNull</symbol></entry> 
										  </row> 
										  <row><entry><symbol>IfNull(Alpha,
													 Alpha)</symbol></entry><entry><symbol>IsNull(X, Y)</symbol> 
													 <para>Note that this translation, as
														  with the others may be affected by the actual language emitter used by each
														  device. The output shown here is typical of the MSSQL device, whereas the
														  Oracle device would use a different construct. In either the case, the
														  translation handler remains the
														  same.</para></entry><entry><symbol>SQLIfNull</symbol></entry> 
										  </row> 
										  <row><entry><symbol>iExists</symbol>(<symbol>exists</symbol>)</entry><entry><symbol>exists</symbol></entry><entry><symbol>SQLExists</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>iIn(Scalar, List)</symbol>,
													 <symbol>iIn(Scalar,
													 Table)</symbol>(<symbol>in</symbol>)</entry><entry><symbol>in</symbol></entry><entry><symbol>SQLIn</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Count()</symbol></entry><entry><symbol>Count(*)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Count(Scalar)</symbol></entry><entry><symbol>Count(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Sum</symbol>, all
													 overloads</entry><entry><symbol>Sum(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Min</symbol>, all
													 overloads</entry><entry><symbol>Min(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Max</symbol>, all
													 overloads</entry><entry><symbol>Max(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>Avg</symbol>, all
													 overloads</entry><entry><symbol>Avg(X)</symbol></entry><entry><symbol>SQLAggregateOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Milliseconds</symbol></entry><entry><symbol>X
													 *
													 TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanMilliseconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Days</symbol></entry><entry><symbol>X
													 * TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanDays</symbol></entry> 
										  </row> 
										  <row><entry><symbol>TimeSpan.Seconds</symbol></entry><entry><symbol>X
													 *
													 TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanSeconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Minutes</symbol></entry><entry><symbol>X
													 *
													 TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanMinutes</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Hours</symbol></entry><entry><symbol>X
													 * TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanHours</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Ticks</symbol></entry><entry><symbol>X</symbol></entry><entry><symbol>SQLScalarSelector</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan</symbol>, 1
													 operand</entry><entry><symbol>X1 *
													 TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpan1Operand</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan</symbol>, 2
													 operands</entry><entry><symbol>X1 * TicksPerDay + X2 *
													 TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpan2Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan</symbol>, 3
													 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3 *
													 TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpan3Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan</symbol>, 4
													 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3
													 *TicksPerMinute + X4 *
													 TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpan4Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan</symbol>, 5
													 operands</entry><entry><symbol>X1 * TicksPerDay + X2 * TicksPerHour + X3
													 *TicksPerMinute + X4 * TicksPerSecond + X5 *
													 TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpan5Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>AddTicks(TimeSpan,
													 Long)</symbol></entry><entry><symbol>X +
													 Y</symbol></entry><entry><symbol>SQLTimeSpanAddTicks</symbol></entry> 
										  </row> 
										  <row><entry><symbol>Duration(TimeSpan)</symbol></entry><entry><symbol>Abs(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Time</symbol>, 1
													 operand</entry><entry><symbol>X1 *
													 TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanTime1Operand</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Time</symbol>, 2
													 operands</entry><entry><symbol>X1 * TicksPerHour + X2 *
													 TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanTime2Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Time</symbol>, 3
													 operands</entry><entry><symbol>X1 * TicksPerHour + X2 * TicksPerMinute + X3 *
													 TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanTime3Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.Time</symbol>, 4
													 operands</entry><entry><symbol>X1 * TicksPerHour + X2 * TicksPerMinute + X3 *
													 TicksPerSecond + X4 *
													 TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanTime4Operands</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadMilliseconds</symbol></entry><entry><symbol>X
													 /
													 TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanReadMilliseconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteMilliseconds</symbol></entry><entry><symbol>Y
													 *
													 TicksPerMillisecond</symbol></entry><entry><symbol>SQLTimeSpanWriteMilliseconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadTicks</symbol></entry><entry><symbol>X</symbol></entry><entry><symbol>SQLScalarReadAccessor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteTicks</symbol></entry><entry><symbol>Y</symbol></entry><entry><symbol>SQLScalarWriteAccessor</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadMinutes</symbol></entry><entry><symbol>X
													 /
													 TicksPerMinute</symbol></entry><entry><symbol>SQLScalarReadMinutes</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteMinutes</symbol></entry><entry><symbol>Y
													 *
													 TicksPerMinute</symbol></entry><entry><symbol>SQLTimeSpanWriteMinutes</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadHours</symbol></entry><entry><symbol>X
													 /
													 TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanReadHours</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteHours</symbol></entry><entry><symbol>Y
													 *
													 TicksPerHour</symbol></entry><entry><symbol>SQLTimeSpanWriteHours</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadSeconds</symbol></entry><entry><symbol>X
													 /
													 TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanReadSeconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteSeconds</symbol></entry><entry><symbol>Y
													 *
													 TicksPerSecond</symbol></entry><entry><symbol>SQLTimeSpanWriteSeconds</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.ReadDays</symbol></entry><entry><symbol>X
													 /
													 TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanReadDays</symbol></entry>
												
										  </row> 
										  <row><entry><symbol>TimeSpan.WriteDays</symbol></entry><entry><symbol>Y
													 *
													 TicksPerDay</symbol></entry><entry><symbol>SQLTimeSpanWriteDays</symbol></entry>
												
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable>All the translation handlers listed above
						  are declared in the namespace <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol>
						  in assembly <symbol>Alphora.Dataphor.DAE.Device.SQL</symbol>.</para> 
					 <para>In addition to the specific translators for system
						  operators, the base SQL device introduces several general purpose translators
						  that can be used without modification to handle most programming tasks. The
						  following table details the available handlers: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Translation
													 Handler</entry><entry>Functionality Provided</entry> 
										  </row></thead><tbody> 
										  <row><entry><symbol>SQLScalarSelector</symbol></entry><entry>Provides
													 a basic passthrough implementation, in other words, the operator mapped to this
													 handler is skipped in the translation output. This is useful when the device
													 representation for a particular data type is known to be the same as the device
													 representation for the data type of the single scalar component of the
													 representation for a given selector. For example, the domain <symbol>ID {
													 representation ID { Value : String } }</symbol> would have the same device
													 representation as <symbol>String</symbol>, and so a selector invocation
													 <symbol>ID("001")</symbol> would effectively be translated to just the string
													 literal <symbol>"001"</symbol>.</entry> 
										  </row> 
										  <row><entry><symbol>SQLScalarReadAccessor</symbol></entry><entry>Provides
													 a basic passthrough implementation for read accessors. To continue with the
													 above example, the invocation in D4 <symbol>ID.Value</symbol> could be
													 translated by simply ignoring the read accessor.</entry> 
										  </row> 
										  <row><entry><symbol>SQLScalarWriteAccessor</symbol></entry><entry>Provides
													 a basic passthrough implementation for write accessors. The D4 assignment to
													 <symbol>ID.Value</symbol> can be translated to SQL by a replacement of the
													 value if the representation has a single scalar component with the same device
													 representation as the type itself.</entry> 
										  </row> 
										  <row><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry><entry>Provides
													 a basic implementation for the <symbol>IsSpecial</symbol> operators created for
													 each domain. If a domain has no specials, this handler is appropriate, as it
													 always emits <symbol>0 = 1</symbol> or false, in SQL.</entry> 
										  </row> 
										  <row><entry><symbol>SQLCallOperator</symbol></entry><entry>Provides
													 a generic handler that is capable of invoking an operator in SQL. This handler
													 has an attribute called <symbol>OperatorName</symbol>, set through the
													 attributes in the class definition, which is used to construct the output. For
													 example, if the operator name of the handler is <symbol>Rand</symbol>, and the
													 handler is mapped to the D4 operator <symbol>Random</symbol>, the result of
													 translating the D4 expression <symbol>Random(5)</symbol> is
													 <symbol>Rand(5)</symbol>. The call operator works with any number of operands
													 for the operator being mapped. This is useful when the implementation for a
													 specific operator in D4 is provided by a user-defined function in the target
													 system.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="DDGP2SQLConnectivity"> 
					 <title><indexterm><primary>SQL
									 Connectivity</primary></indexterm>SQL Connectivity</title> 
					 <para>Common SQL support introduces a connectivity layer for
						  handling communication with different SQL-based DBMSs. This layer abstractly
						  describes the behaviors required by the Common SQL device, and its descendents.
						  Specific implementations of connectivity layers are then provided to
						  communicate with the different data access methodologies available for existing
						  systems.</para> 
					 <para>The connectivity architecture breaks down into three
						  basic levels: 
						  <orderedlist> 
								<listitem> 
									 <para>Connection</para> 
								</listitem> 
								<listitem> 
									 <para>Command</para> 
								</listitem> 
								<listitem> 
									 <para>Reader</para> 
								</listitem> 
						  </orderedlist></para> 
					 <sect3 id="DDGP2SQLConnection"> 
						  <title><indexterm><primary>SQLConnection</primary></indexterm>SQLConnection</title>
						  
						  <para>The connection layer manages communication with a
								specific data store. Transaction management services are provided by this
								layer, as well as mechanisms for preparing commands. A given connection can
								prepare any number of commands, but can only actively execute one at a time. No
								other operations may be performed while a connection is executing a
								command.</para> 
						  <para>This layer of the architecture is described by the
								class <symbol>Alphora.Dataphor.DAE.Connection.SQLConnection</symbol>. Each
								connection exposes the currently executing command through the value of the
								<symbol>ActiveCommand</symbol> property. Each connection also exposes the
								currently executing reader, if applicable, through the value of the
								<symbol>ActiveReader</symbol> property.</para> 
						  <para>Each connection exposes the current state through the
								value of the <symbol>State</symbol> property. Valid values for this property
								are: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Connection
														  State</entry><entry>Description</entry> 
												</row></thead><tbody> 
												<row><entry><symbol>Idle</symbol></entry><entry>The
														  connection is open and ready.</entry> 
												</row> 
												<row><entry><symbol>Executing</symbol></entry><entry>The
														  connection is executing a statement.</entry> 
												</row> 
												<row><entry><symbol>Reading</symbol></entry><entry>The
														  connection is actively servicing a cursor.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The <symbol>CreateCommand</symbol> method is used to
								obtain a command appropriate for the connection. This command can then be used
								to describe the statement to be executed, and any parameters required. The
								<symbol>Execute</symbol> and <symbol>Open</symbol> methods perform this
								processing automatically.</para> 
						  <para>Connection instances are unmanaged resources, and
								must be explicitly disposed through a call to the <symbol>Dispose</symbol>
								method.</para> 
					 </sect3> 
					 <sect3 id="DDGP2SQLCommand"> 
						  <title><indexterm><primary>SQLCommand</primary></indexterm>SQLCommand</title>
						  
						  <para>The command layer represents commands to be executed
								against a specfic data store. These commands may have parameters associated
								with them, and they may be prepared to improve execution performance.</para> 
						  <para>This layer of the architecture is described by the
								class <symbol>Alphora.Dataphor.DAE.Connection.SQLCommand</symbol>. Each command
								exposes the currently active reader, if applicable, through the
								<symbol>ActiveReader</symbol> property.</para> 
						  <para>Each command has a <symbol>Statement</symbol>
								property which represents the statement to be executed. This statement must be
								a string in a dialect of the existing system. Parameterization is the only
								manipulation performed on this statement.</para> 
						  <para>Each command has a <symbol>Parameters</symbol>
								property which must contain an instance of the class
								<symbol>Alphora.Dataphor.DAE.Connection.SQLParameter</symbol> for each
								parameter described in the statement for the command. Parameters in the command
								are delineated using the <symbol>@</symbol> symbol. For example: 
								<programlisting>select * from City where Name = @CityName</programlisting>This statement contains a single parameter called
								<symbol>CityName</symbol>.</para> 
						  <para>If the underlying data store supports it, a command
								may be explicitly prepared, improving performance for repeated execution of the
								command. This state is managed through the <symbol>Prepare</symbol> and
								<symbol>Unprepare</symbol> methods, and exposed as the value of the
								<symbol>Prepared</symbol> property.</para> 
						  <para>Commands are unmanaged resources, and must be
								explicitly disposed through a call to the <symbol>Dispose</symbol>
								method.</para> 
					 </sect3> 
					 <sect3 id="DDGP2SQLReader"> 
						  <title><indexterm><primary>SQLReader</primary></indexterm>SQLReader</title>
						  
						  <para>The reader layer represents cursors against a
								specific data store. This is where data retrieval takes place. The reader
								provided must be a "cracked" cursor in order to function correctly within the
								SQL devices.</para> 
						  <para>This layer of the architecture is described by the
								class <symbol>Alphora.Dataphor.DAE.Connection.SQLReader</symbol>. The reader
								represents a forward-only, read-only cursor against the data store. Values are
								exposed through the indexer of the reader. The <symbol>IsNull</symbol> method
								returns whether a given column has a value. In addition, the reader exposes a
								mechanism for deferred reading of byte streams. The <symbol>IsDeferred</symbol>
								method returns whether a given column supports deferred access. If this method
								returns true, the <symbol>OpenDeferredStream</symbol> method may be invoked to
								retrieve a deferred read stream against the data store.</para> 
						  <para>Navigation is accomplished using the
								<symbol>Next</symbol> method, which returns a boolean value indicating whether
								the end of the reader has been reached. If this method returns true, the reader
								is positioned on a valid row, otherwise, it is an error to attempt to read
								data. When the reader is first opened, it is positioned before the first row of
								the result set, and <symbol>Next</symbol> must be called to retrieve any
								rows.</para> 
						  <para>Reader instances are unmanaged resources, and must be
								explicitly disposed by either passing the reader as the argument to the
								<symbol>Close</symbol> method of the <symbol>Command</symbol> responsible for
								its creation, or through a call to the <symbol>Dispose</symbol> method.</para> 
					 </sect3> 
					 <sect3 id="DDGP2ConnectivityImplementationsinDataphor"> 
						  <title><indexterm><primary>Connectivity Implementations in
										  Dataphor</primary></indexterm>Connectivity Implementations in Dataphor</title> 
						  <para>The Dataphor toolset provides several implementations
								of the SQL connectivity layer described above. These wrap common data access
								technologies, and expose them to the SQL devices. In addition, new data access
								technologies can easily be exposed by providing an SQL Connectivity
								implementation. The following table lists the available implementations as of
								the preparation of this document. More may be made available in the future as
								necessary. 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Data Access
														  Technology</entry><entry>SQL Connectivity Connection Class</entry> 
												</row></thead><tbody> 
												<row><entry>ADO</entry><entry><symbol>Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
														  Alphora.Dataphor.DAE.Connection.ADO</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for Microsoft
														  SQL
														  Server</entry><entry><symbol>Alphora.Dataphor.DAE.Connection.MSSQLConnection,
														  Alphora.Dataphor.DAE.Connection</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for OLE
														  DB</entry><entry><symbol>Alphora.Dataphor.DAE.Connection.OLEDBConnection,
														  Alphora.Dataphor.DAE.Connection</symbol></entry> 
												</row> 
												<row><entry>ADO.NET Provider for
														  ODBC</entry><entry><symbol>Alphora.Dataphor.DAE.Connection.ODBC.ODBCConnection,
														  Alphora.Dataphor.DAE.Connection.ODBC</symbol></entry> 
												</row> 
												<row><entry>Microsoft ADO.NET Provider for
														  Oracle</entry><entry><symbol>Alphora.Dataphor.DAE.Connection.Oracle.OracleConnection,
														  Alphora.Dataphor.DAE.Connection.Oracle</symbol></entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2SQLDevice"> 
					 <title><indexterm><primary>SQL Device</primary></indexterm>SQL
						  Device</title> 
					 <para>The base SQL device brings all the layers of Common SQL
						  support together to facilitate writing specific SQL devices. There are four
						  basic categories of services described by the base SQL device: 
						  <itemizedlist> 
								<listitem> 
									 <para>Translation</para> 
								</listitem> 
								<listitem> 
									 <para>Reconciliation</para> 
								</listitem> 
								<listitem> 
									 <para>Connectivity</para> 
								</listitem> 
								<listitem> 
									 <para>Retrieval and Manipulation</para> 
								</listitem> 
						  </itemizedlist>These services are implemented to the degree
						  possible for all devices, and are tailored by the specific devices where
						  appropriate.</para> 
					 <para>The base SQL device is described by the class
						  <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLDevice</symbol>. This class
						  implements the bulk of the necessary translation and reconciliation code. It
						  also provides a mechanism for describing the type of connectivity to be
						  used.</para> 
					 <para>The session layer for the base SQL device is described by
						  the class <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLDeviceSession</symbol>.
						  This class manages the connections required for the session, including
						  transaction management. It also provides execution services, and coordinates
						  translation with the device. This class also functions as a stream provider for
						  the system stream manager to support deferred stream access in the SQL
						  devices.</para> 
					 <para>The plan layer for the base SQL device is described by
						  the class <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLDevicePlan</symbol>. This
						  class manages the state associated with translating D4 assembly into an
						  equivalent SQL statement, and keeps the prepared command for use in the execute
						  phase.</para> 
					 <para>The cursor layer for the base SQL device is described by
						  the class <symbol>Alphora.Dataphor.DAE.Device.SQL.SQLDeviceReader</symbol>.
						  This class works in conjunction with the <symbol>SQLDeviceSession</symbol> to
						  implement connection multiplexing, and deferred stream access.</para> 
					 <sect3 id="DDGP2Translation"> 
						  <title><indexterm><primary>Translation</primary></indexterm>Translation</title>
						  
						  <para>Translation services in the base SQL device are
								provided for the bulk of the Common SQL language. Most translation is
								implemented within this device, and only specific differences in dialect need
								to be customized when descending from this device.</para> 
						  <sect4 id="DDGP2TranslationStructures"> 
								<title><indexterm><primary>Translation
												Structures</primary></indexterm>Translation Structures</title> 
								<para>To begin with, we describe the structures
									 involved in performing the translation from D4 to SQL. The first of these is
									 the <symbol>SQLDevicePlan</symbol> class which manages the overall compiler
									 state during the process. This class manages the following types of
									 information: 
									 <itemizedlist> 
										  <listitem> 
												<para>Query Contexts</para> 
										  </listitem> 
										  <listitem> 
												<para>Boolean Contexts</para> 
										  </listitem> 
										  <listitem> 
												<para>Symbol Table</para> 
										  </listitem> 
										  <listitem> 
												<para>Table Aliases</para> 
										  </listitem> 
									 </itemizedlist></para> 
								<para>A query context is a grouping layer used to track
									 the range variables involved in a particular select statement of SQL. A query
									 context is represented by an instance of the class
									 <symbol>SQLQueryContext</symbol>. Query contexts can be either scalar or
									 non-scalar. A scalar query context is used to indicate that the translation
									 process has moved into a scalar-valued expression translation, and that the
									 appearance of a table-valued expression while in the context constitutes the
									 creation of a new query context. A non-scalar query context consists of a set
									 of range variables represented as instances of the class
									 <symbol>SQLRangeVar</symbol>. A range variable is used to track the appearance
									 of some result in a given query. Each range variable tracks the name of the
									 variable and the table type of the result it represents.</para> 
								<para>A boolean context is a grouping layer used to
									 indicate whether the current context supports boolean-valued results. In a
									 non-boolean context, if a boolean-valued expression is translated, it must be
									 translated as a case expression to introduce a boolean context. This is
									 necessary because the SQL language does not have boolean-valued expression in
									 general, only within certain constructs. For example, even assuming SQL had a
									 boolean-valued literal called <symbol>true</symbol> (which SQL most definitely
									 does not), the following SQL where clause is illegal: 
									 <programlisting>where true</programlisting>In order to work around this problem, the compiler must ensure
									 that if such a situation is encountered, an appropriate comparison is
									 substituted such as: 
									 <programlisting>where 1 = 1</programlisting></para> 
								<para>The symbol table used in SQL compilation is
									 identical to that used in standard D4 compilation. This symbol table is used to
									 track the effect of D4 instructions as the translation moves through the
									 instruction tree. When instructions are encountered which reference the
									 run-time stack, they must be adjusted by the amount of stack displacement that
									 would have been introduced had the instructions actually been executed. This is
									 known as the <emphasis>stack translation offset</emphasis> or just
									 <emphasis>translation offset</emphasis>.</para> 
								<para>The device plan contains information about what
									 the next table alias should be. This ensures that all table aliases used within
									 a given query are unique.</para> 
						  </sect4> 
						  <sect4 id="DDGP2TheTranslationProcess"> 
								<title><indexterm><primary>Translation
												Process</primary></indexterm>The Translation Process</title> 
								<para>The translation process begins in the override of
									 the <symbol>InternalPrepare</symbol> method. At this point, the base device has
									 already called <symbol>CreateDevicePlan</symbol>, which creates a new instance
									 of the class <symbol>SQLDevicePlan</symbol> to support the translation process.
									 If the expression being translated is not a table-valued expression, the
									 process pushes a scalar context on to the query context stack. If the
									 expression being translated is boolean-valued, the process pushes a boolean
									 context as well. The main translate method is then called passing the plan and
									 the root node of the D4 instruction tree. This begins the depth-first descent
									 of the instruction tree. When this descent is complete, the call will return a
									 <symbol>Statement</symbol> descendent that is the SQL parse tree equivalent of
									 the given D4 instructions. If the requested operation is not supported, the
									 <symbol>IsSupported</symbol> property of the <symbol>SQLDevicePlan</symbol>
									 instance will be false, and the result of the <symbol>InternalPrepare</symbol>
									 call is null. Otherwise, some additional processing is done to ensure that the
									 translated expression is a select statement, and to translate the order, if
									 any, and the completed <symbol>SQLDevicePlan</symbol> instance is
									 returned.</para> 
								<para>The bulk of the work in this process is done by
									 the individual translate methods responsible for translating the different
									 instructions of D4. Most of the standard instructions of D4 such as stack
									 reference and stack column reference are handled by translation methods on the
									 device. These translation methods are all virtual, providing customization
									 points for descendent devices. Operator translation is all done through
									 instances of some descendent of the class <symbol>DeviceOperator</symbol>. This
									 class introduces an abstract method called <symbol>Translate</symbol> which is
									 called to provide the translation services. The default translation handlers
									 are listed in the SQL Operators section.</para> 
								<para>The <symbol>Translate</symbol> method itself
									 simply decides which translation method to call. This method also ensures that
									 query contexts are entered as necessary, and makes sure that a given operator
									 and the types it involves are all supported. This method is also virtual to
									 allow for customization of the entire process.</para> 
						  </sect4> 
						  <sect4 id="DDGP2ExtendingTranslation"> 
								<title><indexterm><primary>Extending
												Translation</primary></indexterm>Extending Translation</title> 
								<para>The following extensibility points are provided
									 to customize the translation behavior of the SQL device: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Member</entry><entry>Description</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>Emitter</symbol></entry><entry>Must
																be overridden to provide the emitter to be used for the dialect of SQL
																supported by this device. The emitter must be an instance of some descendent of
																the class <symbol>TextEmitter</symbol> and will likely be some descendent of
																the class <symbol>SQLTextEmitter</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>DetermineCursorBehavior</symbol></entry><entry>Can
																be overridden to change the behavior of the cursor returned by the
																device.</entry> 
													 </row> 
													 <row><entry><symbol>EnsureValidIdentifier</symbol></entry><entry>Can
																be overridden to ensure that the given string is a valid identifier. The
																default implementation simply replaces all qualifiers with an underscore. Note
																that if this method is overridden it must be a deterministic function, i.e. it
																must return the same identifier for successive invocations with the same
																input.</entry> 
													 </row> 
													 <row><entry><symbol>ToSQLIdentifier</symbol></entry><entry>Can
																be overriden to provide identifier translation services from D4 to SQL. The
																default implementation of this method uses the value of the
																<symbol>Storage.Name</symbol> tag, if available, and calls
																<symbol>EnsureValidIdentifier</symbol> otherwise.</entry> 
													 </row> 
													 <row><entry><symbol>FromSQLIdentifier</symbol></entry><entry>Can
																be overridden to provide identifier translation services from SQL to D4. The
																default implementation of this method ensures that the identifier is not a
																reserved word in the D4 language.</entry> 
													 </row> 
													 <row><entry><symbol>FromScalar</symbol></entry><entry>Can
																be overridden to provide value translation services from the D4 representation
																of a value to the device representation. The default implementation of this
																method parameterizes the current query being translated, delaying value
																translation until execution time.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateStackReference</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>StackReferenceNode</symbol> D4 instruction. The default implementation
																uses the <symbol>FromScalar</symbol> method adjusting the stack reference for
																the current translation offset.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateStackColumnReference</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>StackColumnReferenceNode</symbol> D4 instruction. The default
																implementation determines whether the column reference is within the query
																being translated or external to it. If it is internal, the reference is
																translated as an identifier, otherwise it is translated using the
																<symbol>FromScalar</symbol> method adjusting the stack reference for the
																current translation offset.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateValueNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>ValueNode</symbol> D4 instruction. The default implementation uses the
																<symbol>FromScalar</symbol> method.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateExpression</symbol></entry><entry>Can
																be overrridden to provide translation services for expression instructions of
																D4. The default implementation calls the basic <symbol>Translate</symbol>
																method, wrapping the call in a boolean context if necessary.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateConditionNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>ConditionNode</symbol> D4 instruction. The default implementation
																renders the condition as a case expression of SQL.</entry> 
													 </row> 
													 <row><entry><symbol>GetDummyTableSpecifier</symbol></entry><entry>Can
																be overridden to provide the dummy table selector in SQL. The default
																implementation returns the SQL: 
																<programlisting>select dummy1 from dummy1</programlisting></entry> 
													 </row> 
													 <row><entry><symbol>TranslateRowSelectorNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>RowSelectorNode</symbol> D4 instruction. The default implementation
																renders the row selector as a singleton select statement of SQL.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateTableSelectorNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>TableSelectorNode</symbol> D4 instruction. The default implementation
																renders the table selector as the union of multiple singleton select
																statements.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateInsertNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>InsertNode</symbol> D4 instruction. The default implementation renders
																the insert as a standard SQL insert statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateUpdateNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>UpdateNode</symbol> D4 instruction. The default implementation renders
																the update as a standard SQL update statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateDeleteNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>DeleteNode</symbol> D4 instruction. The default implementation renders
																the delete as a standard SQL delete statement.</entry> 
													 </row> 
													 <row><entry><symbol>GetIndexName</symbol></entry><entry>Can
																be overridden to specify the index name that should be used to support a given
																key or order for a table variable. The default implementation attempts to use
																the <symbol>Storage.Name</symbol> tag if available. Otherwise, it is the
																concatenation of the string "UIDX_" with the table name and all the column
																names involved.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateCreateIndex</symbol></entry><entry>Can
																be overridden to provide the translation for index creation statements. The
																default implementation renders the creation as a standard SQL create index
																statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateDropIndex</symbol></entry><entry>Can
																be overridden to provide the translation for drop index statements. The default
																implementation renders the drop as a standard SQL drop index statement.</entry>
														  
													 </row> 
													 <row><entry><symbol>TranslateCreateTable</symbol></entry><entry>Can
																be overridden to provide the translation for create table statements. The
																default implementation renders the create as a standard SQL create table
																statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateCreateTableNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>CreateTableNode</symbol> D4 instruction. The default implementation
																calls the <symbol>TranslateCreateTable</symbol> method.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateAlterTableNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>AlterTableNode</symbol> D4 instruction. The default implementation
																renders the alter as a standard SQL alter table statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateDropTableNode</symbol></entry><entry>Can
																be overridden to provide translation services for the
																<symbol>DropTableNode</symbol> D4 instruction. The default implementation
																renders the drop as a standard SQL drop table statement.</entry> 
													 </row> 
													 <row><entry><symbol>TranslateOrder</symbol></entry><entry>Can
																be overridden to provide translation for the order clause of a given query. The
																default implementation renders the order as a standard SQL order
																clause.</entry> 
													 </row> 
													 <row><entry><symbol>Translate</symbol></entry><entry>Can
																be overridden to provide translation services for all instructions of D4. The
																default implementation partitions the translation tasks between the translation
																methods available on the device and the translation methods provided by
																operator mappings.</entry> 
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2Reconciliation"> 
						  <title><indexterm><primary>Reconciliation</primary></indexterm>Reconciliation</title>
						  
						  <para>As with translation, the bulk of the reconciliation
								process is implemented by the base SQL device. Key extensibility points are
								provided to allow each device to describe the catalog to be reconciled in
								common terms, and dialectic differences in the create statements generated by
								the process are rectified by the translation mechanism described above.</para> 
						  <para>Reconciliation in the base SQL device is accomplished
								by extended the reconciliation process provided by the base device. Three key
								points are extended, <symbol>GetDeviceCatalog</symbol>,
								<symbol>CreateTable</symbol>, and <symbol>ReconcileTable</symbol>.</para> 
						  <para><symbol>GetDeviceCatalog</symbol> is called by the
								base device whenever a reconciliation process must occur. The device must
								return a description of the catalog of the target system in terms of DAE
								catalog structures. To facilitate this process, the base SQL device abstracts
								over the dialects of SQL and requires that each descendent device provide the
								necessary select statements to describe the catalog available (Note that the
								ANSI standard schema views cannot be used for this purpose as they do not
								contain enough information to provide a complete reconciliation). This catalog
								is then returned to the base device for further processing. The base SQL device
								introduces the abstract methods <symbol>GetDeviceTablesExpression</symbol> and
								<symbol>GetDeviceIndexesExpression</symbol> to achieve this goal. Once these
								results have been obtained, the base SQL device iterates through them,
								constructing the DAE catalog structures necessary to represent the tables
								described in these results. During this process, the
								<symbol>ShouldIncludeColumn</symbol> method is called for each column in each
								table encountered. If this method returns false, the column is ignored.
								Otherwise, the <symbol>FindScalarType</symbol> method is called for the column
								to determine the DAE type most closely matching the SQL domain for the given
								column. Both of these methods are also virtual to provide customization
								points.</para> 
						  <para><symbol>CreateTable</symbol> is called by the
								reconciliation process when it is determined that a given table in the DAE
								catalog should be created in the target system. The default implementation is
								sufficient for all the Dataphor SQL devices, but the method is virtual to allow
								for additional customization, if necessary.</para> 
						  <para><symbol>ReconcileTable</symbol> is called by the
								reconciliation process when it is determined that a given table in the DAE
								catalog should be reconciled with an existing table in the target system.
								Again, the default implementation is sufficient for all the Dataphor SQL
								devices, but the method is virtual to allow for additional customization, if
								necessary.</para> 
						  <para>The following extensibility points are provided to
								customize the reconciliation behavior of the base SQL device: 
								<informaltable> 
									 <tgroup cols="2"><thead> 
												<row><entry>Member</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><symbol>ReconcileTable</symbol></entry><entry>Can
														  be overridden to return the alter table statement required to reconcile the
														  differences between the two given tables. The default implementation ensures
														  that the columns of the source table are a subset of the columns of the target
														  table, and that all keys and orders have supporting indexes in the target
														  system.</entry> 
												</row> 
												<row><entry><symbol>ShouldIncludeColumn</symbol></entry><entry>Can
														  be overridden to return whether or not the given column should be included in
														  the imported table definition. The default implementation returns true.</entry>
													 
												</row> 
												<row><entry><symbol>FindScalarType</symbol></entry><entry>Must
														  be overridden to determine the D4 type for a given SQL type. The default
														  implementation throws an <symbol>SQLException</symbol> indicating that the
														  given SQL type cannot be imported.</entry> 
												</row> 
												<row><entry><symbol>GetDeviceTablesExpression</symbol></entry><entry>Must
														  be overridden to return an SQL select statement in the appropriate dialect
														  describing the tables and table columns of the target system. The expression
														  result must be of the form: 
														  <programlisting>TableName varchar(128),
ColumnName varchar(128),
DomainName varchar(128), // native domain name
Length integer, // fixed length column size
IsNullable integer, // 0 = false, 1 = true
IsDeferred integer, // 0 = false, 1 = true </programlisting> and must be ordered by TableName. The IsDeferred column
														  indicates whether values of the column should be read using the deferred read
														  mechanism.</entry> 
												</row> 
												<row><entry><symbol>GetDeviceIndexesExpression</symbol></entry><entry>Must
														  be overridden to return an SQL select statement in the appropriate dialect
														  describing the indexes and index columns of the target system. The expression
														  result must be of the form: 
														  <programlisting>TableName varchar(128),
IndexName varchar(128),
ColumnName varchar(128),
IsUnique integer, // 0 = false, 1 = true
IsDescending integer, // 0 = false, 1 = true</programlisting>and must be ordered by TableName, IndexName,
														  ColumnName.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Connectivity"> 
						  <title><indexterm><primary>Connectivity</primary></indexterm>Connectivity</title>
						  
						  <para>The connectivity layer for the base SQL device
								handles most of the tasks involved in connecting to the target systems. These
								tasks include basic connectivity, transaction coordination, and connection
								management.</para> 
						  <sect4 id="DDGP2BasicConnectivity"> 
								<title><indexterm><primary>Basic
												Connectivity</primary></indexterm>Basic Connectivity</title> 
								<para>Basic communications with the target system are
									 handled by an SQL connectivity implementation. The connectivity implementation
									 to be used is specified by the value of the <symbol>ConnectionClass</symbol>
									 attribute, which specifies the class name of the <symbol>SQLConnection</symbol>
									 descendent to be used. Once a connectivity implementation has been selected,
									 the device must connect to the target system using an appropriate set of
									 connection parameters.</para> 
								<para>All connectivity implementations use the concept
									 of a <emphasis>connection string</emphasis> to specify connection information.
									 A connection string is a set of name-value pairs called <emphasis>connection
									 parameters</emphasis>. Each connection parameter specifies some aspect of
									 connecting to the target system such as <symbol>ServerName</symbol> or
									 <symbol>UserID</symbol>. The class <symbol>SQLConnectionStringBuilder</symbol>
									 provides an abstraction for building sets of connection parameters. Each
									 connectivity implementation and device combination then uses an instance of
									 some descendent of the <symbol>SQLConnectionStringBuilder</symbol> class to
									 build the appropriate connection string. The connection string builder to be
									 used is specified by the value of the
									 <symbol>ConnectionStringBuilderClass</symbol> attribute.</para> 
								<para>The base SQL device also introduces a property
									 called <symbol>ConnectionParameters</symbol> which can be used to specify
									 additional configuration parameters for the device. Device users may also
									 specify configuration parameters for the device. All these parameters are used
									 by the connection string builder to generate the appropriate connection string
									 for the target system.</para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionMultiplexing"> 
								<title><indexterm><primary>Connection
												Multiplexing</primary></indexterm>Connection Multiplexing</title> 
								<para>Transactions in the DAE are associated with a
									 running process. Because of this, device sessions are also associated with a
									 given process. If a transaction is in progress in the DAE, a transaction must
									 be in progress with the target system as well. This is known as
									 <emphasis>transaction coordination</emphasis> and is managed by the process
									 from the DAE. </para> 
								<para>In order for this transaction coordination to
									 work, the DAE requires that a device session be capable of responding to
									 transactional requests, even if cursors are open against the device. In
									 addition, the DAE requires that the device session be able to open multiple
									 cursors within the same transaction. For SQL-based systems, these requirements
									 pose a non-trivial implementation problem, as transactions are usually
									 restricted to the communications session, and transactions cannot be started
									 and stopped independent of cursor lifetimes. The base SQL device solves these
									 problems with a mechanism called <emphasis>connection multiplexing</emphasis>.
									 </para> 
								<para>Connection multiplexing is the process by which a
									 pool (possibly one) of connections to a given target system is shared among
									 multiple task requests against the device session. The device session manages
									 connection multiplexing using two pools of connections: a
									 <emphasis>browse</emphasis> pool, and an <emphasis>execute</emphasis> pool.
									 </para> 
								<para>The browse pool is used for connections which are
									 known to be readonly and have an isolation level of browse. All actions
									 performed on connections in the browse pool are done within a browse
									 transaction which allows the read of uncommitted data. Because the connections
									 in the browse pool do not have to participate in the same transaction, new
									 browse connections can be added as needed. </para> 
								<para>The execute pool is used for connections which
									 may update data, or have an isolation level higher than browse. All connections
									 in the execute pool participate in the same transaction against the target
									 system. If the target system supports multiple connections in a single
									 transaction, the execute pool can contain multiple connections, otherwise the
									 execute pool will only contain a single connection. As requests are made
									 against the device session, they are either readonly browse requests, in which
									 case the browse pool is used to process the request, or they are possibly write
									 requests which must be processed by the execute pool. If all connections in the
									 execute pool are currently busy, the first connection in the pool is released,
									 and then moved to the back of the pool. The released connection can then be
									 used to service the request. </para> 
								<para>In order for this to work, the client of the
									 connection that has been released must be informed that the release has
									 occurred, and be given the chance to collect enough state to be able to resume
									 operation from the point where the connection was released. This capability is
									 provided by the <symbol>SQLDeviceReader</symbol> class. The SQL device reader
									 maintains a working buffer of the data being read from any given connection.
									 When the connection is released, the SQL device reader will read from the
									 working buffer until more data must be fetched. At this point the SQL device
									 reader requests a connection from the device session, and fetches data
									 beginning with the first row after the last row in its working buffer. In this
									 way, a single transactional connection to the target system can be utilized by
									 multiple requests coming in from the DAE. The value of the
									 <symbol>ConnectionBufferSize</symbol> property of the
									 <symbol>SQLDevice</symbol> instance determines the number of rows to keep in
									 the working buffer of each <symbol>SQLDeviceReader</symbol> instance.</para> 
								<para>When connection multiplexing requires a new
									 connection, the <symbol>CreateConnection</symbol> method is called. This method
									 is introduced in the <symbol>SQLDeviceSession</symbol> class and must be
									 overridden by each descendent to provide a new connection using the appropriate
									 connectivity implementation and connection string.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2RetrievalandManipulation"> 
						  <title><indexterm><primary>Retrieval and
										  Manipulation</primary></indexterm>Retrieval and Manipulation</title> 
						  <para>Retrieval and manipulation tasks are handled
								completely by the base SQL device. Customization points are available to allow
								for specific behaviors to be implemented, but the Dataphor SQL devices have not
								required any customization in this area.</para> 
						  <para>The base SQL device uses an instance of the class
								<symbol>SQLTable</symbol> to return the results of a given expression to the
								DAE. Instances of this class manage multiple instaces of the class
								<symbol>SQLDeviceReader</symbol> to return the data to the DAE, and coordinate
								with the device session to provide deferred stream access to blob data.</para> 
						  <para>The SQL table uses a single SQL device reader to read
								the main table result. For each deferred read column, this result only
								indicates whether there is a value to be read. When the value is actually read
								by the DAE, the SQL table opens another <symbol>SQLDeviceReader</symbol> to
								retrieve the value from the target system. To accomplish this deferred reading,
								the device session becomes a stream provider in the stream architecture of the
								DAE. As deferred read columns are encountered in the main result, a deferred
								read stream header is constructed which contains enough information to read the
								blob value from the target system. This header is assigned a stream identifier
								by the DAE's stream manager, and the value in the row being returned is set to
								use this new stream as the overflow for the column. In this way, only when the
								value is actually read from the row is the blob value actually retrieved from
								the target system. If the value is never read, the blob is never retrieved. For
								more information on the stream manager and overflow architecture, refer to the
								Runtime Architecture section of this manual.</para> 
						  <para>The SQL table provides translation services between
								the device and physical representations of a given value using the domain maps
								registered with the device. Each domain map provides an implementation of the
								<symbol>FromScalar</symbol> and <symbol>ToScalar</symbol> methods.</para> 
						  <para>Data modification in the base SQL device is handled
								in two ways: first, by overriding the row level data modification commands, and
								second, by translating complete modification statements.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="DDGP2SpecificDevices"> 
					 <title><indexterm><primary>Specific
									 Devices</primary></indexterm>Specific Devices</title> 
					 <para>The Dataphor DAE includes several devices for
						  communicating with commercial SQL-based DBMSs. These systems include: 
						  <itemizedlist> 
								<listitem> 
									 <para>Microsoft SQL Server</para> 
								</listitem> 
								<listitem> 
									 <para>Oracle SQL Server</para> 
								</listitem> 
								<listitem> 
									 <para>IBM DB2 Universal Database Server</para> 
								</listitem> 
								<listitem> 
									 <para>Linter SQL Server</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Each of these devices is considered in detail in the
						  following sections.</para> 
					 <sect3 id="DDGP2MicrosoftSQLServerDevice"> 
						  <title><indexterm><primary>Microsoft SQL
										  Device</primary></indexterm>Microsoft SQL Server Device</title> 
						  <para>The Microsoft SQL Server Device is capable of
								communicating with Microsoft SQL Server and Microsoft Desktop Engine (MSDE)
								versions 7.0 and 2000.</para> 
						  <sect4 id="DDGP2ImplementationClasses"> 
								<title><indexterm><primary>Implementation
												Classes</primary></indexterm>Implementation Classes</title> 
								<para>The device layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.MSSQL.MSSQLDevice</symbol> in the assembly
									 <symbol>AlphoraMSSQLDevice</symbol>. </para> 
								<para>The session layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.MSSQL.MSSQLDeviceSession</symbol> in the
									 assemlby <symbol>AlphoraMSSQLDevice</symbol>. This class implements the
									 connectivity layer for the MSSQL device.</para> 
								<para>The plan and cursor layers are not customized by
									 the MSSQL device.</para> 
						  </sect4> 
						  <sect4 id="DDGP2DeviceSettings"> 
								<title><indexterm><primary>Device
												Settings</primary></indexterm>Device Settings</title> 
								<para>The following settings are configurable as
									 attributes in the class definition describing the device: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Attribute
																Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>ConnectionClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																implement the connectivity layer for this device. See the connectivity section
																for a discussion of the possible settings for this attribute. The default value
																for this attribute is
																<symbol>Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
																Alphora.Dataphor.DAE.Connection.ADO</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																construct connection strings for this device. See the connectivity section for
																a discussion of the possible settings for this attribute. The default value for
																this attribute is
																<symbol>Alphora.Dataphor.DAE.Device.MSSQL.MSSQLOLEDBConnectionStringBuilder,
																AlphoraMSSQLDevice</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionParameters</symbol></entry><entry>
																
																<programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
																be used in building the connection string. For more information on how the
																MSSQL device buils a connection string, refer to the connectivity
																section.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
																
																<programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
																from the target system. The default value for this attribute is 20. A value of
																0 for this attribute indicates that the entire result set should be read
																immediately, i.e., the result set should be
																<emphasis>disconnected</emphasis>.</entry> 
													 </row> 
													 <row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
																case-sensitive for the purposes of identifier resolution and string comparison.
																This setting determines whether the device will map the
																<symbol>System.String</symbol> domain (case-sensitive) or the
																<symbol>System.IString</symbol> domain (case-insensitive) by default. The
																default value for this attribute is false.</entry> 
													 </row> 
													 <row><entry><symbol>IsMSSQL70</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the target system is version
																7.0. If this value is false, the system is considered version 2000. Version
																2000 mappings will use user-defined functions in the target system to support
																many of the operators in the DAE. For a version 7.0 system, these operators
																must be translated as expressions inline. The default value for this attribute
																is false.</entry> 
													 </row> 
													 <row><entry><symbol>ShouldEnsureDatabase</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the database name given by
																the <symbol>DatabaseName</symbol> attribute should be created on the target
																system if it does not exist. The default value for this attribute is
																true.</entry> 
													 </row> 
													 <row><entry><symbol>ShoudEnsureOperators</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the device should ensure
																that the user-defined functions used to support operator mapping exist in the
																target system. This setting has no effect if the value of the
																<symbol>IsMSSQL70</symbol> attribute is true. The default value for this
																attribute is true. All the user-defined functions created by the MSSQL device
																are prefixed by <symbol>DAE_</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ServerName</symbol></entry><entry>
																
																<programlisting>&lt;server name&gt;</programlisting></entry><entry>Indicates the name of the Microsoft SQL Server
																instance to use. This attribute has no default value.</entry> 
													 </row> 
													 <row><entry><symbol>DatabaseName</symbol></entry><entry>
																
																<programlisting>&lt;database name&gt;</programlisting></entry><entry>Indicates the name of the database to be used
																within the specified server instance. This attribute has no default
																value.</entry> 
													 </row> 
													 <row><entry><symbol>UseIntegratedSecurity</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Indicates whether integrated security should be
																used to connect to the Microsoft SQL Server Instance. If the value of this
																attribute is true, the device will connect to the specified server instance
																using windows authentication. For more information on security configuration in
																Microsoft SQL Server, see the Microsoft SQL Server Books Online.</entry> 
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectivityImplementations"> 
								<title><indexterm><primary>Connectivity
												Implementation</primary></indexterm>Connectivity Implementations</title> 
								<para>The following connectivity implementations may be
									 used with the MSSQL device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>ADOConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
													 connectivity implementation uses Microsoft Active Data Objects (ADO) to
													 communicate with the specified server instance. This is the default
													 connectivity implementation for the MSSQL device. This is also the only fully
													 supported connectivity implementation due to some issues with the various
													 ADO.NET data providers.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>OLEDBConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
													 implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
													 with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>MSSQLConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
													 implementation uses the Microsoft ADO.NET native SQL Server data provider to
													 communicate with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>ODBCConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
													 connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
													 communicate with the specified server instance.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionStringBuilderImplementations"> 
								<title><indexterm><primary>Connection String Builder
												Implementations</primary></indexterm>Connection String Builder
									 Implementations</title> 
								<para>The following connection string builder
									 implementations are avilable for the MSSQL device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>MSSQLOLEDBConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
													 <symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
													 connection strings for the <symbol>ADOConnection</symbol> and
													 <symbol>OLEDBConnection</symbol> connectivity implementations. This is the
													 default connection string builder class for the MSSQL device.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>MSSQLADODotNetConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
													 <symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
													 a connection string for the <symbol>MSSQLConnection</symbol> connectivity
													 implementation.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>MSSQLODBCConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
													 <symbol>AlphoraMSSQLDevice</symbol> assembly. This class is capable of building
													 a connection string for the <symbol>ODBCConnection</symbol> connectivity
													 implementation.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2TranslationHandlers"> 
								<title><indexterm><primary>Translation
												Handlers</primary></indexterm>Translation Handlers</title> 
								<para>The MSSQL device registers the following
									 translation domain maps: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4 Data
																Type</entry><entry>Transact SQL Data Type</entry><entry>Translation
																Class</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>System.Boolean</symbol></entry><entry>BIT</entry><entry><symbol>MSSQLBoolean</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Byte</symbol></entry><entry>TINYINT</entry><entry><symbol>MSSQLByte</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
																<symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Money</symbol></entry><entry>MONEY</entry><entry><symbol>MSSQLMoney</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Guid</symbol></entry><entry>UNIQUEIDENTIFIER</entry><entry><symbol>MSSQLGuid</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.String</symbol>,
																<symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
																TEXT</entry><entry><symbol>MSSQLString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Image</symbol></entry><entry>IMAGE</entry><entry><symbol>MSSQLImage</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>The MSSQL device registers the following operator
									 maps: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4
																Operator</entry><entry>Transact-SQL Equivalent</entry><entry>Translation
																Handler</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>iAddition(String,
																String)</symbol>(<symbol>+</symbol>)</entry><entry><symbol>+</symbol></entry><entry><symbol>SQLAddition</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Length(String)</symbol></entry><entry><symbol>Len</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Copy(String,
																Integer, Integer)</symbol></entry><entry><symbol>Substring(X, Y + 1,
																Z)</symbol></entry><entry><symbol>MSSQLCopy</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Pos(String,
																String)</symbol></entry><entry><symbol>case when X = '' then 1 else
																CharIndex(X, Y) end -
																1</symbol></entry><entry><symbol>MSSQLPos</symbol></entry> 
													 </row> 
													 <row><entry><symbol>IndexOf(String,
																String)</symbol></entry><entry><symbol>case when Y = '' then 1 else
																CharIndex(Y, X) end -
																1</symbol></entry><entry><symbol>MSSQLIndexOf</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Upper(String)</symbol></entry><entry><symbol>Upper(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Lower(String)</symbol></entry><entry><symbol>Lower(X)</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>CompareText(String,
																String)</symbol></entry><entry><symbol>case when Upper(X) = Upper(Y) then 0
																when Upper(X) &lt; Upper(Y) then -1 else 1
																end</symbol></entry><entry><symbol>MSSQLCompareText</symbol> 
																<para>Note that this
																	 translation is only used if <symbol>IsCaseSensitive</symbol> is true for this
																	 device, otherwise <symbol>SQLCompare</symbol> is used to perform the
																	 translation.</para></entry> 
													 </row> 
													 <row><entry><symbol>IsSpecial</symbol>,
																all overloads</entry><entry><symbol>1 =
																0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iPower</symbol>(<symbol>**</symbol>)</entry><entry><symbol>Power(X,
																Y)</symbol></entry><entry><symbol>MSSQLPower</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Abs</symbol>, all
																overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceiling</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ln</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Now</symbol></entry><entry><symbol>GetDate</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_TSDateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_DTTimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>Month</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>Year</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Today</symbol></entry><entry><symbol>Round(GetDate())</symbol></entry><entry><symbol>MSSQLToday</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>ToBoolean</symbol>,
																all overloads</entry><entry><symbol>convert(bit,
																X)</symbol></entry><entry><symbol>MSSQLToBit</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToString(Boolean)</symbol></entry><entry><symbol>case
																when X = 0 then 'False' else 'True'
																end</symbol></entry><entry><symbol>SQLBooleanToString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToString</symbol>,
																all overloads except
																<symbol>Boolean</symbol></entry><entry><symbol>convert(varchar,
																X)</symbol></entry><entry><symbol>MSSQLToString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToByte</symbol>,
																<symbol>Boolean</symbol>, <symbol>String</symbol>, and
																<symbol>IString</symbol></entry><entry><symbol>convert(tinyint,
																X)</symbol></entry><entry><symbol>MSSQLToTinyInt</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToByte</symbol>,
																all overloads except <symbol>Boolean</symbol>, <symbol>String</symbol>, and
																<symbol>IString</symbol></entry><entry><symbol>convert(tinyint, X &amp;
																(power(2, 8) - 1)) </symbol></entry><entry><symbol>MSSQLToByte</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>ToShort(Boolean)</symbol>,
																<symbol>ToShort(String)</symbol>, <symbol>ToShort(IString)</symbol>,
																<symbol>ToShort(Byte)</symbol></entry><entry><symbol>convert(smallint,
																X)</symbol></entry><entry><symbol>MSSQLToSmallInt</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToShort(Integer)</symbol>,
																<symbol>ToShort(Long)</symbol></entry><entry><symbol>convert(smallint, ((X
																&amp; (power(2, 16) - 1) &amp; ~power(2, 15)) - (power(2, 15) &amp;
																X)))</symbol></entry><entry><symbol>MSSQLToShort</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToInteger(Boolean)</symbol>,
																<symbol>ToInteger(String)</symbol>, <symbol>ToInteger(IString)</symbol>,
																<symbol>ToInteger(Byte)</symbol>, <symbol>ToInteger(Short)</symbol>,
																<symbol>ToInteger(Decimal)</symbol>,
																<symbol>ToInteger(Money)</symbol></entry><entry><symbol>convert(int,
																X)</symbol></entry><entry><symbol>MSSQLToInt</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToInteger(Long)</symbol></entry><entry><symbol>convert(int,
																((X &amp; ((power(convert(bigint, 2), 32) - 1) &amp; ~(power(convert(bigint,
																2), 31)) - (power(convert(bigint, 2), 31) &amp;
																X)))</symbol></entry><entry><symbol>MSSQLToInteger</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToLong</symbol>,
																all overloads</entry><entry><symbol>convert(bigint,
																X)</symbol></entry><entry><symbol>MSSQLToBigInt</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToDecimal(Integer)</symbol>,
																<symbol>ToDecimal(Long)</symbol>,
																<symbol>ToDecimal(Money)</symbol></entry><entry><symbol>convert(decimal(28, 8)
																X)</symbol></entry><entry><symbol>MSSQLToDecimal288</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToMoney(Integer)</symbol>,
																<symbol>ToMoney(Long)</symbol>,
																<symbol>ToMoney(Decimal)</symbol></entry><entry><symbol>convert(money,
																X)</symbol></entry><entry><symbol>MSSQLToMoney</symbol></entry> 
													 </row> 
													 <row><entry><symbol>ToGuid(String)</symbol>,
																<symbol>ToGuid(IString)</symbol></entry><entry><symbol>convert(uniqueidentifier,
																X)</symbol></entry><entry><symbol>MSSQLToUniqueIdentifier</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>MSSQLFrac</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log</symbol></entry><entry><symbol>DAE_LogB</symbol></entry><entry><symbol>MSSQLLogB</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Truncate</symbol></entry><entry><symbol>DAE_Trunc</symbol></entry><entry><symbol>MSSQLTruncate</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadDaysPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadHoursPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadMinutesPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadSecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanReadMillisecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteDaysPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteHoursPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteMinutesPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteSecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>MSSQLTimeSpanWriteMillisecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>MSSQLAddYears</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddMonths</symbol></entry><entry><symbol>DAE_AddMonths</symbol></entry><entry><symbol>MSSQLAddMonths</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>MSSQLDayOfWeek</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>MSSQLDayOfYear</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>MSSQLDateTimeReadHoursPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>MSSQLDateTimeReadMinutesPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeReadSecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeReadMillisecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteYearsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMonthsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteDaysPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteHoursPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMinutesPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteSecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>MSSQLDateTimeWriteMillisecondsPart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DatePart</symbol></entry><entry><symbol>DAE_DTDatePart</symbol></entry><entry><symbol>MSSQLDateTimeDatePart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_DTTimePart</symbol></entry><entry><symbol>MSSQLDateTimeTimePart</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																all
																overloads</entry><entry><symbol>DAE_DTDateTimeSelector</symbol></entry><entry><symbol>MSSQLDateTimeSelector</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Translation classes beginning with
									 <symbol>MSSQL</symbol> are defined in the
									 <symbol>Alphora.Dataphor.DAE.Device.MSSQL</symbol> namespace in the
									 <symbol>AlphoraMSSQLDevice</symbol> assembly. The other translation classes are
									 used from the basic SQL device.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2OracleSQLServerDevice"> 
						  <title><indexterm><primary>Oracle SQL Server
										  Device</primary></indexterm>Oracle SQL Server Device</title> 
						  <para>The Oracle SQL Server Device is capable of
								communicating with Oracle SQL Server versions 8i and 9i.</para> 
						  <sect4 id="DDGP2ImplementationClasses2"> 
								<title><indexterm><primary>Implementation
												Classes</primary></indexterm>Implementation Classes</title> 
								<para>The device layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.Oracle.OracleDevice</symbol> in the
									 assembly <symbol>AphoraOracleDevice</symbol>.</para> 
								<para>The session layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.Oracle.OracleDeviceSession</symbol> in the
									 assembly <symbol>AlphoraOracleDevice</symbol>.</para> 
								<para>The plan and cursors layers are not customized by
									 the Oracle device.</para> 
						  </sect4> 
						  <sect4 id="DDGP2DeviceSettings2"> 
								<title><indexterm><primary>Device
												Settings</primary></indexterm>Device Settings</title> 
								<para>The following table lists the settings available
									 for the Oracle device. These settings are configured using the attributes of
									 the class definition: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Attribute
																Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>ConnectionClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																implement the connectivity layer for this device. See the connectivity section
																for a discussion of the possible settings for this attribute. The default value
																for this attribute is
																<symbol>Alphora.Dataphor.DAE.Connection.ADO.ADOConnection,
																Alphora.Dataphor.DAE.Connection.ADO</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																construct connection strings for this device. See the connectivity section for
																a discussion of the possible settings for this attribute. The default value for
																this attribute is
																<symbol>Alphora.Dataphor.DAE.Device.Oracle.OracleOLEDBConnectionStringBuilder,
																AlphoraOracleDevice</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionParameters</symbol></entry><entry>
																
																<programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
																be used in building the connection string. For more information on how the
																MSSQL device buils a connection string, refer to the connectivity
																section.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
																
																<programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
																from the target system. The default value for this attribute is 20. A value of
																0 for this attribute indicates that the entire result set should be read
																immediately, i.e., the result set should be
																<emphasis>disconnected</emphasis>.</entry> 
													 </row> 
													 <row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
																case-sensitive for the purposes of identifier resolution and string comparison.
																This setting determines whether the device will map the
																<symbol>System.String</symbol> domain (case-sensitive) or the
																<symbol>System.IString</symbol> domain (case-insensitive) by default. The
																default value for this attribute is false.</entry> 
													 </row> 
													 <row><entry><symbol>HostName</symbol></entry><entry>
																
																<programlisting>&lt;host name&gt;</programlisting></entry><entry>Indicates the name of the Oracle instance to
																use. This attribute has no default value.</entry> 
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectivityImplementations2"> 
								<title><indexterm><primary>Connectivity
												Implementations</primary></indexterm>Connectivity Implementations</title> 
								<para>The following connectivity implementations are
									 available for use with the Oracle device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>ADOConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
													 connectivity implementation uses Microsoft Active Data Objects (ADO) to
													 communicate with the specified server instance. This is the default
													 connectivity implementation for the Oracle device. This is also the only fully
													 supported connectivity implementation due to some issues with the various
													 ADO.NET data providers.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>OLEDBConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
													 implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
													 with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>OracleConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.Oracle</symbol> assembly. This
													 connectivity implementation uses the Microsoft ADO.NET Oracle data provider to
													 communicate with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>ODBCConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
													 connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
													 communicate with the specified server instance.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionStringBuilderImplementations2"> 
								<title><indexterm><primary>Connection String Builder
												Implementations</primary></indexterm>Connection String Builder
									 Implementations</title> 
								<para>The following connection string builder
									 implementations are available for use with the Oracle device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>OracleOLEDBConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.Oracle</symbol> namespace in the
													 <symbol>AlphoraOracleDevice</symbol> assembly. This class is capable of
													 building connection strings for the <symbol>ADOConnection</symbol> and
													 <symbol>OLEDBConnection</symbol> connectivity implementations. This is the
													 default connection string builder class for the Oracle device.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2TranslationHandlers2"> 
								<title><indexterm><primary>Translation
												Handlers</primary></indexterm>Translation Handlers</title> 
								<para>Value translation in the Oracle device uses the
									 following domain mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4 Data
																Type</entry><entry>Oracle SQL Data Type</entry><entry>Translation Class</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>System.Boolean</symbol></entry><entry>DECIMAL(1,
																0)</entry><entry><symbol>OracleBoolean</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Byte</symbol></entry><entry>DECIMAL(3,
																0)</entry><entry><symbol>OracleByte</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Short</symbol></entry><entry>DECIMAL(5,
																0)</entry><entry><symbol>OracleShort</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Integer</symbol></entry><entry>DECIMAL(10,
																0)</entry><entry><symbol>OracleInteger</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Long</symbol></entry><entry>DECIMAL(20,
																0)</entry><entry><symbol>OracleLong</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
																<symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.TimeSpan</symbol></entry><entry>DECIMAL(20,
																0)</entry><entry><symbol>OracleTimeSpan</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
																8)</entry><entry><symbol>SQLMoney</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.String</symbol>,
																<symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
																CLOB</entry><entry><symbol>SQLString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Operator translation in the Oracle device uses
									 the following operator mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4
																Operator</entry><entry>Oracle SQL Equivalent</entry><entry>Translation
																Handler</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>IsSpecial</symbol>,
																all overloads</entry><entry><symbol>1 =
																0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iPower</symbol>(<symbol>**</symbol>)</entry><entry><symbol>Power(X,
																Y)</symbol></entry><entry><symbol>SQLPower</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Abs</symbol>, all
																overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ln</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log</symbol></entry><entry><symbol>DAE_LogB</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Truncate</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Now</symbol></entry><entry><symbol>SysDate</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>DAE_DTReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_TSDateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_DTTimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>Month</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>Day</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>Year</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Today</symbol></entry><entry><symbol>DAE_Today</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddMonths</symbol></entry><entry><symbol>Add_Months</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DatePart</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																1
																operand</entry><entry><symbol>DAE_DateTimeSelector1</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																2
																operands</entry><entry><symbol>DAE_DateTimeSelector2</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																3
																operands</entry><entry><symbol>DAE_DateTimeSelector3</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																4
																operands</entry><entry><symbol>DAE_DateTimeSelector4</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																5
																operands</entry><entry><symbol>DAE_DateTimeSelector5</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																6
																operands</entry><entry><symbol>DAE_DateTimeSelector6</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																7
																operands</entry><entry><symbol>DAE_DateTimeSelector7</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Translation classes beginning with
									 <symbol>Oracle</symbol> are defined in the
									 <symbol>Alphora.Dataphor.DAE.Device.Oracle</symbol> namespace in the
									 <symbol>AlphoraOracleDevice</symbol> assembly. The other translation classes
									 are used from the basic SQL device.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2DB2UniversalDatabaseServerDevice"> 
						  <title><indexterm><primary>DB2 Universal Database Server
										  Device</primary></indexterm>DB2 Universal Database Server Device</title> 
						  <para>The DB2 Universal Database Server Device is capable
								of communicating with the IBM DB2 Universal Database Server Version 7.0.</para>
						  
						  <sect4 id="DDGP2ImplementationClasses3"> 
								<title><indexterm><primary>Implementation
												Classes</primary></indexterm>Implementation Classes</title> 
								<para>The device layer is implemented by the class
									 <symbol>Aphora.Dataphor.DAE.Device.DB2.DB2Device</symbol> in the assembly
									 <symbol>AlphoraDB2Device</symbol>.</para> 
								<para>The session layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.DB2.DB2DeviceSession</symbol> in the
									 assembly <symbol>AlphoraDB2Device</symbol>.</para> 
								<para>The plan and cursor layers are not customized by
									 the DB2 device.</para> 
						  </sect4> 
						  <sect4 id="DDGP2DeviceSettings3"> 
								<title><indexterm><primary>Device
												Settings</primary></indexterm>Device Settings</title> 
								<para>The following table lists the settings available
									 for the DB2 device. These settings are configured using the attributes of the
									 class definition: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Attribute
																Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>ConnectionClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																implement the connectivity layer for this device. See the connectivity section
																for a discussion of the possible settings for this attribute. The default value
																for this attribute is
																<symbol>Alphora.Dataphor.DAE.Connection.ODBC.ODBCConnection,
																Alphora.Dataphor.DAE.Connection.ODBC</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																construct connection strings for this device. See the connectivity section for
																a discussion of the possible settings for this attribute. The default value for
																this attribute is
																<symbol>Alphora.Dataphor.DAE.Device.DB2.DB2ODBCConnectionStringBuilder,
																AlphoraDB2Device</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionParameters</symbol></entry><entry>
																
																<programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
																be used in building the connection string. For more information on how the
																MSSQL device buils a connection string, refer to the connectivity
																section.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
																
																<programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
																from the target system. The default value for this attribute is 20. A value of
																0 for this attribute indicates that the entire result set should be read
																immediately, i.e., the result set should be
																<emphasis>disconnected</emphasis>.</entry> 
													 </row> 
													 <row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
																case-sensitive for the purposes of identifier resolution and string comparison.
																This setting determines whether the device will map the
																<symbol>System.String</symbol> domain (case-sensitive) or the
																<symbol>System.IString</symbol> domain (case-insensitive) by default. The
																default value for this attribute is false.</entry> 
													 </row> 
													 <row><entry><symbol>Data
																Source</symbol></entry><entry> 
																<programlisting>&lt;data source name&gt;</programlisting></entry><entry>Indicates the name of the DB2 instance to use.
																This attribute has no default value.</entry> 
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectivityImplementations3"> 
								<title><indexterm><primary>Connectivity
												Implementations</primary></indexterm>Connectivity Implementations</title> 
								<para>The following connectivity implementations are
									 available for use with the DB2 device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>ADOConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
													 connectivity implementation uses Microsoft Active Data Objects (ADO) to
													 communicate with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>OLEDBConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
													 implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
													 with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>ODBCConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
													 connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
													 communicate with the specified server instance. This is the default
													 connectivity implementation for the DB2 device.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionStringBuilderImplementations3"> 
								<title><indexterm><primary>Connection String Builder
												Implementations</primary></indexterm>Connection String Builder
									 Implementations</title> 
								<para>The following connection string builder
									 implementations are available for use with the DB2 device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>DB2ODBCConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.DB2</symbol> namespace in the
													 <symbol>AlphoraDB2Device</symbol> assembly. This class is capable of building
													 connection strings for the <symbol>ODBCConnection</symbol> connectivity
													 implementation. This is the default connection string builder class for the DB2
													 device.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2TranslationHandlers3"> 
								<title><indexterm><primary>Translation
												Handlers</primary></indexterm><indexterm><primary>DB2 Universal Database Server
												DeviceDB2 Universal Database Server Device</primary><secondary>Translation
												Handlers</secondary></indexterm>Translation Handlers</title> 
								<para>Value translation in the DB2 device uses the
									 following domain mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4 Data
																Type</entry><entry>DB2 SQL Data Type</entry><entry>Translation Class</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLBoolean</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
																<symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.DateTime</symbol></entry><entry>TIMESTAMP</entry><entry><symbol>SQLDateTime</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
																8)</entry><entry><symbol>SQLMoney</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.String</symbol>,
																<symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
																CLOB</entry><entry><symbol>SQLString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Operator translation in the DB2 device uses the
									 following operator mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4
																Operator</entry><entry>DB2 SQL Equivalent</entry><entry>Translation
																Handler</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>IsSpecial</symbol>,
																all overloads</entry><entry><symbol>1 =
																0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
													 </row> 
													 <row><entry><symbol>iPower</symbol>(<symbol>**</symbol>),
																all overloads</entry><entry><symbol>Power(X,
																Y)</symbol></entry><entry><symbol>SQLPower</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Abs</symbol>, all
																overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ln</symbol></entry><entry><symbol>Ln</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log10</symbol></entry><entry><symbol>Log10</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Exp</symbol></entry><entry><symbol>Exp</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Random</symbol></entry><entry><symbol>Rand</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Frac</symbol></entry><entry><symbol>DAE_Frac</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log</symbol></entry><entry><symbol>LogB</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Truncate</symbol></entry><entry><symbol>DAE_Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Now</symbol></entry><entry><symbol>DAE_Now</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DaysInMonth</symbol></entry><entry><symbol>DAE_DaysInMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>IsLeapYear</symbol></entry><entry><symbol>DAE_IsLeapYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfMonth</symbol></entry><entry><symbol>DAE_DayOfMonth</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime(TimeSpan)</symbol></entry><entry><symbol>DAE_DateTime</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan(DateTime)</symbol></entry><entry><symbol>DAE_TimeSpan</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMonthsPart</symbol></entry><entry><symbol>DAE_DTReadMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadDaysPart</symbol></entry><entry><symbol>DAE_DTReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadYearsPart</symbol></entry><entry><symbol>DAE_DTReadYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Today</symbol></entry><entry><symbol>DAE_Today</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadDaysPart</symbol></entry><entry><symbol>DAE_TSReadDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadHoursPart</symbol></entry><entry><symbol>DAE_TSReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMinutesPart</symbol></entry><entry><symbol>DAE_TSReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadSecondsPart</symbol></entry><entry><symbol>DAE_TSReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_TSReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteDaysPart</symbol></entry><entry><symbol>DAE_TSWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteHoursPart</symbol></entry><entry><symbol>DAE_TSWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMinutesPart</symbol></entry><entry><symbol>DAE_TSWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteSecondsPart</symbol></entry><entry><symbol>DAE_TSWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimeSpan.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_TSWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddYears</symbol></entry><entry><symbol>DAE_AddYears</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>AddMonths</symbol></entry><entry><symbol>DAE_AddMonths</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfWeek</symbol></entry><entry><symbol>DAE_DayOfWeek</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DayOfYear</symbol></entry><entry><symbol>DAE_DayOfYear</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadHoursPart</symbol></entry><entry><symbol>DAE_DTReadHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMinutesPart</symbol></entry><entry><symbol>DAE_DTReadMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadSecondsPart</symbol></entry><entry><symbol>DAE_DTReadSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.ReadMillisecondsPart</symbol></entry><entry><symbol>DAE_DTReadMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteYearsPart</symbol></entry><entry><symbol>DAE_DTWriteYearsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMonthsPart</symbol></entry><entry><symbol>DAE_DTWriteMonthsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteDaysPart</symbol></entry><entry><symbol>DAE_DTWriteDaysPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteHoursPart</symbol></entry><entry><symbol>DAE_DTWriteHoursPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMinutesPart</symbol></entry><entry><symbol>DAE_DTWriteMinutesPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteSecondsPart</symbol></entry><entry><symbol>DAE_DTWriteSecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime.WriteMillisecondsPart</symbol></entry><entry><symbol>DAE_DTWriteMillisecondsPart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DatePart</symbol></entry><entry><symbol>DAE_DatePart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>TimePart</symbol></entry><entry><symbol>DAE_TimePart</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																1
																operand</entry><entry><symbol>DAE_DateTimeSelector1</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																2
																operands</entry><entry><symbol>DAE_DateTimeSelector2</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																3
																operands</entry><entry><symbol>DAE_DateTimeSelector3</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																4
																operands</entry><entry><symbol>DAE_DateTimeSelector4</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																5
																operands</entry><entry><symbol>DAE_DateTimeSelector5</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																6
																operands</entry><entry><symbol>DAE_DateTimeSelector6</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>DateTime</symbol>,
																7
																operands</entry><entry><symbol>DAE_DateTimeSelector7</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Translation classes beginning with
									 <symbol>DB2</symbol> are defined in the
									 <symbol>Alphora.Dataphor.DAE.Device.DB2</symbol> namespace in the
									 <symbol>AlphoraDB2Device</symbol> assembly. The other translation classes are
									 used from the basic SQL device.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="DDGP2LinterSQLServerDevice"> 
						  <title><indexterm><primary>Linter SQL Server
										  Device</primary></indexterm>Linter SQL Server Device</title> 
						  <para>The Linter SQL Server Device is capable of
								communicating with the Relexus Linter DBMS versions 5.9 and 6.0.</para> 
						  <sect4 id="DDGP2ImplementationClasses4"> 
								<title><indexterm><primary>Implementation
												Classes</primary></indexterm>Implementation Classes</title> 
								<para>The device layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.Linter.LinterDevice</symbol> in the
									 assembly <symbol>AlphoraLinterDevice</symbol>.</para> 
								<para>The session layer is implemented by the class
									 <symbol>Alphora.Dataphor.DAE.Device.Linter.LinterDeviceSession</symbol> in the
									 assembly <symbol>AlphoraLinterDevice</symbol>.</para> 
								<para>The plan and cursor layers are not customized by
									 the Linter device.</para> 
						  </sect4> 
						  <sect4 id="DDGP2DeviceSettings4"> 
								<title><indexterm><primary>Device
												Settings</primary></indexterm>Device Settings</title> 
								<para>The following table lists the settings available
									 for the Linter device. These settings are configured using the attributes of
									 the class definition: 
									 <informaltable> 
										  <tgroup cols="2"><thead> 
													 <row><entry>Attribute
																Name</entry><entry>Possible Values</entry><entry>Meaning</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>ConnectionClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																implement the connectivity layer for this device. See the connectivity section
																for a discussion of the possible settings for this attribute. The default value
																for this attribute is
																<symbol>Alphora.Dataphor.DAE.Connection.ODBC.ODBCConnection,
																Alphora.Dataphor.DAE.Connection.ODBC</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionStringBuilderClass</symbol></entry><entry>
																
																<programlisting>&lt;assembly qualified class name&gt;</programlisting></entry><entry>Determines the class which will be used to
																construct connection strings for this device. See the connectivity section for
																a discussion of the possible settings for this attribute. The default value for
																this attribute is
																<symbol>Alphora.Dataphor.DAE.Device.Linter.LinterODBCConnectionStringBuilder,
																AlphoraLinterDevice</symbol>.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionParameters</symbol></entry><entry>
																
																<programlisting>&lt;parameter&gt;{;&lt;parameter&gt;}

&lt;parameter&gt; ::=
	&lt;parameter name&gt;=&lt;parameter value&gt;</programlisting></entry><entry>Specifies additional connection parameters to
																be used in building the connection string. For more information on how the
																MSSQL device buils a connection string, refer to the connectivity
																section.</entry> 
													 </row> 
													 <row><entry><symbol>ConnectionBufferSize</symbol></entry><entry>
																
																<programlisting>&lt;integer&gt;</programlisting></entry><entry>Specifies the number of rows to fetch at a time
																from the target system. The default value for this attribute is 20. A value of
																0 for this attribute indicates that the entire result set should be read
																immediately, i.e., the result set should be
																<emphasis>disconnected</emphasis>.</entry> 
													 </row> 
													 <row><entry><symbol>IsCaseSensitive</symbol></entry><entry>
																
																<programlisting>true | false</programlisting></entry><entry>Determines whether the target system is
																case-sensitive for the purposes of identifier resolution and string comparison.
																This setting determines whether the device will map the
																<symbol>System.String</symbol> domain (case-sensitive) or the
																<symbol>System.IString</symbol> domain (case-insensitive) by default. The
																default value for this attribute is false.</entry> 
													 </row> 
													 <row><entry><symbol>Data
																Source</symbol></entry><entry> 
																<programlisting>&lt;data source name&gt;</programlisting></entry><entry>Indicates the name of the Linter instance to
																use. This attribute has no default value.</entry> 
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectivityImplementations4"> 
								<title><indexterm><primary>Connectivity
												Implementations</primary></indexterm>Connectivity Implementations</title> 
								<para>The following connectivity implementations are
									 available for use by the Linter device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>ADOConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ADO</symbol> assembly. This
													 connectivity implementation uses Microsoft Active Data Objects (ADO) to
													 communicate with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>OLEDBConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection</symbol> assembly. This connectivity
													 implementation uses the Microsoft ADO.NET OLEDB data provider to communicate
													 with the specified server instance.</para> 
										  </listitem> 
										  <listitem> 
												<para><symbol>ODBCConnection</symbol></para>
												
												<para>This class is located in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> namespace in the
													 <symbol>Alphora.Dataphor.DAE.Connection.ODBC</symbol> assembly. This
													 connectivity implementation uses the Microsoft ADO.NET ODBC data provider to
													 communicate with the specified server instance. This is the default
													 connectivity implementation for the Linter device.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionStringBuilderImplementations4"> 
								<title><indexterm><primary>Connection String Builder
												Implementations</primary></indexterm>Connection String Builder
									 Implementations</title> 
								<para>The following connection string builder
									 implementations are available for use by the Linter device: 
									 <itemizedlist> 
										  <listitem> 
												<para><symbol>LinterODBCConnectionStringBuilder</symbol></para>
												
												<para>This class is defined in the
													 <symbol>Alphora.Dataphor.DAE.Device.Linter</symbol> namespace in the
													 <symbol>AlphoraLinterDevice</symbol> assembly. This class is capable of
													 building connection strings for the <symbol>ODBCConnection</symbol>
													 connectivity implementation. This is the default connection string builder
													 class for the Linter device.</para> 
										  </listitem> 
									 </itemizedlist></para> 
						  </sect4> 
						  <sect4 id="DDGP2TranslationHandlers4"> 
								<title><indexterm><primary>Translation
												Handlers</primary></indexterm>Translation Handlers</title> 
								<para>Value translation in the Linter device uses the
									 following domain mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4 Data
																Type</entry><entry>Linter SQL Data Type</entry><entry>Translation Class</entry>
														  
													 </row></thead><tbody> 
													 <row><entry><symbol>System.Boolean</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLBoolean</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Byte</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLByte</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Short</symbol></entry><entry>SMALLINT</entry><entry><symbol>SQLShort</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Integer</symbol></entry><entry>INTEGER</entry><entry><symbol>SQLInteger</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Long</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLLong</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Decimal</symbol></entry><entry>DECIMAL(<symbol>P</symbol>,
																<symbol>S</symbol>)</entry><entry><symbol>SQLDecimal</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.DateTime</symbol></entry><entry>DATETIME</entry><entry><symbol>SQLDateTime</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.TimeSpan</symbol></entry><entry>BIGINT</entry><entry><symbol>SQLTimeSpan</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.Money</symbol></entry><entry>DECIMAL(28,
																8)</entry><entry><symbol>SQLMoney</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Guid</symbol></entry><entry>CHAR(24)</entry><entry><symbol>SQLGuid</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>System.String</symbol>,
																<symbol>System.IString</symbol></entry><entry>VARCHAR(<symbol>L</symbol>) or
																CLOB</entry><entry><symbol>SQLString</symbol></entry> 
													 </row> 
													 <row><entry><symbol>System.Image</symbol></entry><entry>BLOB</entry><entry><symbol>SQLImage</symbol></entry>
														  
													 </row></tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Operator translation in the Linter device uses
									 the following operator mappings: 
									 <informaltable> 
										  <tgroup cols="3"><thead> 
													 <row><entry>D4
																Operator</entry><entry>Linter SQL Equivalent</entry><entry>Translation
																Handler</entry> 
													 </row></thead><tbody> 
													 <row><entry><symbol>IsSpecial</symbol>,
																all overloads</entry><entry><symbol>1 =
																0</symbol></entry><entry><symbol>SQLScalarIsSpecialOperator</symbol></entry> 
													 </row> 
													 <row><entry><symbol>Abs</symbol>, all
																overloads</entry><entry><symbol>Abs</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Round</symbol></entry><entry><symbol>Round</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ceiling</symbol></entry><entry><symbol>Ceil</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Floor</symbol></entry><entry><symbol>Floor</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Ln</symbol></entry><entry><symbol>Ln</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Log10</symbol></entry><entry><symbol>Log</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
													 <row><entry><symbol>Truncate</symbol></entry><entry><symbol>Trunc</symbol></entry><entry><symbol>SQLCallOperator</symbol></entry>
														  
													 </row> 
												</tbody> 
										  </tgroup> 
									 </informaltable></para> 
								<para>Translation classes beginning with
									 <symbol>Linter</symbol> are defined in the
									 <symbol>Alphora.Dataphor.DAE.Device.Linter</symbol> namespace in the
									 <symbol>AlphoraLinterDevice</symbol> assembly. The other translation classes
									 are used from the base SQL device.</para> 
						  </sect4> 
					 </sect3> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGCLIAdvancedFeatures"> 
		  <title><indexterm><primary>Application Targeted
						  Features</primary></indexterm>Application Targeted Features</title> 
		  <para>[This documentation is incomplete as of version 1.1. Please check
				the Alphora web site for the latest documentation updates.]</para> 
		  <sect1 id="DDGCLIProposable"> 
				<title><indexterm><primary>Proposable
								Interfaces</primary></indexterm>Proposable Interfaces</title> 
				<para/> 
		  </sect1> 
		  <sect1 id="DDGCLIBrowse"> 
				<title><indexterm><primary>Navigational
								Access</primary></indexterm>Navigational Access</title> 
				<para/> 
		  </sect1> 
		  <sect1 id="DDGCLIAppTrans"> 
				<title><indexterm><primary>Application
								Transactions</primary></indexterm>Application Transactions</title> 
				<para/> 
		  </sect1> 
		  <sect1 id="DDGCLICatalog"> 
				<title><indexterm><primary>Accessing Inferred
								Information</primary></indexterm>Accessing Inferred Information</title> 
				<para/> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGP1DataAccessComponents"> 
		  <title><indexterm><primary>Data Access
						  Components</primary></indexterm>Data Access Components</title> 
		  <para>[This documentation is incomplete as of version 1.1. Please check
				the Alphora web site for the latest documentation updates.]</para> 
		  <para>The Dataphor Data Access Components and Controls wrap the
				functionality of the Call-Level Interface in a set of easy to use .NET
				Framework components which can be used in any .NET Application. These controls
				use a relatively indexed binding model to take advantage of Navigational Access
				enabled by the DAE. These controls can also use Application Transactions
				without developer intervention.</para> 
		  <para>
				<inlinegraphic fileref="images/Frontend Windows Client.gif" width="50"
				depth="39"/> </para> 
		  <para>
				<inlinegraphic fileref="images/Frontend Web Client.gif" width="50" depth="34"/>
				</para> 
		  <para>Data Access Components Overview</para> 
		  <para> [assembly]</para> 
		  <para>DataSession</para> 
		  <para>DataView</para> 
		  <para>DataSource</para> 
		  <para>DataLink</para> 
		  <para>DBxxx Controls </para> 
	 </chapter> 
	 <chapter id="DDGP1ADONETProvider"> 
		  <title><indexterm><primary>ADO.NET
						  Provider</primary></indexterm>ADO.NET Provider</title> 
		  <para>[This documentation is incomplete as of version 1.1. Please check
				the Alphora web site for the latest documentation updates.]</para> 
		  <para>The DAE can also be accessed using ADO.NET through the ADO.NET
				Provider. Microsoft would refer to this as an ADO.NET DAE "Client,"
				but we choose to use the term "provider" for clarity. Using the DAE
				provider, users can access the DAE using the standard data access facilities
				provided by the .NET Framework.</para> 
		  <para>ADO.NET Provider Overview</para> 
		  <para>[assembly]</para> 
		  <para>Connection</para> 
		  <para>Command</para> 
		  <para>Data Reader</para> 
		  <para>Data Adapter </para> 
	 </chapter> 
</part> 
