<?xml version="1.0"?>
<part id="D4LG"> 
	 <partinfo><date role="LastMod">Friday, June 15, 2007 12:52:23 PM</date> 
	 </partinfo> 
	 <title>D4 Language Guide</title> 
	 <partintro> 
		  <para>This part introduces the D4 language and discusses its intentions
				and usage. It provides a complete reference guide for the language, as well as
				discussions of common programming topics, and a comparison with SQL.</para> 
	 </partintro> 
	 <chapter id="D4LGIntroduction"> 
		  <title>Introduction</title> 
		  <para>D4 provides a powerful set of data manipulation capabilities, as
				well as a rich type system for describing even the most complex data. D4 also
				supports a full complement of flow control constructs, including exception
				handling, to provide a complete development language with data manipulation
				capabilities. Using D4, the impedance mismatch that traditionally exists
				between the database access language and the host programming language is
				eliminated, enabling a single data access and development paradigm.</para> 
		  <sect1 id="D4LGIntroduction-PurposeoftheD4Language"> 
				<title>Purpose of the D4 Language</title> 
				<para>The Dataphor Server uses a simple, yet powerful data access
					 and manipulation language called D4. All manipulation of the application schema
					 and its data are done using this language. There are three broad categories of
					 statements in D4: Structural, Manipulative, and Imperative.</para> 
				<para> 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para><emphasis role="strong">Structural
									 statements</emphasis> (also called Data Definition Language (DDL)) manipulate
									 the definition of the data model. These are used to describe the structure of
									 the data to be stored. These include statements like create, drop, and alter.
									 </para> 
						  </listitem> 
						  <listitem> 
								<para> <emphasis role="strong">Manipulative
									 statements</emphasis> (also called Data Manipulation Language (DML)) manipulate
									 the actual data in the database. These are used to insert, update and delete
									 data in the database, as well as retrieve it for presentation and
									 analysis.</para> 
						  </listitem> 
						  <listitem> 
								<para> <emphasis role="strong">Imperative
									 statements</emphasis> provide the framework for execution in D4. These
									 statements include variable declaration and assignment, flow control, and
									 exception handling.</para> 
						  </listitem> 
					 </itemizedlist> </para> 
				<para>D4 is a relationally complete language based on the
					 relational algebra. The syntax of the language is designed to allow the
					 developer to express queries naturally and easily.</para> 
		  </sect1> 
		  <sect1 id="D4LGIntroduction-SyntacticConventions"> 
				<title><indexterm><primary>Syntactic
								Conventions</primary></indexterm><indexterm><primary>Extended Backus-Naur Form
								(EBNF)</primary></indexterm><indexterm><primary>Backus-Naur Form
								(BNF)</primary></indexterm>Syntactic Conventions</title> 
				<para><indexterm><primary>Production
								Rules</primary></indexterm><indexterm><primary>Grammar</primary></indexterm><indexterm><primary>Terminals</primary></indexterm><indexterm><primary>Non-Terminals</primary></indexterm>This
					 language guide uses a variation of Extended Backus-Naur Form (EBNF) to describe
					 the syntax of D4. The variations facilitate the expression of list structures
					 which are common in the language. EBNF is made up of three types of elements:
					 terminals, non-terminals, and symbols. These elements are used to create
					 <emphasis>production rules</emphasis>. The set of production rules describing
					 the language is called the <emphasis>grammar</emphasis>. Each non-terminal in
					 the grammar must have an associated production rule.</para> 
				<para>Non-terminals in EBNF are delimited by angle brackets
					 (<phrase role="code">&lt;</phrase> and 
					 <phrase role="code">&gt;</phrase>). The identifier inside the
					 angle brackets is the name of the non-terminal.</para> 
				<para>Symbols are used to indicate how terminals and non-terminals
					 are grouped together. The following symbols are used in EBNF: 
					 <itemizedlist> 
						  <listitem> 
								<para>Pipe (<phrase role="code">|</phrase>)</para> 
								<para>The pipe is used to indicate an exclusive or. For
									 example the sequence 
									 <phrase role="code">a | b</phrase> means that the
									 result could be 
									 <phrase role="code">a</phrase> or 
									 <phrase role="code">b</phrase> but not both.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Parentheses (<phrase role="code">(</phrase> and 
									 <phrase role="code">)</phrase>)</para> 
								<para>Parentheses are used to force a grouping within
									 the sequence. For example the sequence 
									 <phrase role="code">a (b | c)</phrase> produces the
									 strings 
									 <phrase role="code">ab</phrase> or 
									 <phrase role="code">ac</phrase>, while the sequence
									 
									 <phrase role="code">(a b) | c</phrase> produces the
									 strings 
									 <phrase role="code">ab</phrase> or 
									 <phrase role="code">c</phrase>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Brackets (<phrase role="code">[</phrase> and 
									 <phrase role="code">]</phrase>)</para> 
								<para>Brackets are used to indicate that a given
									 sequence is optional. For example 
									 <phrase role="code">a [ b ]</phrase> means that the
									 result could be 
									 <phrase role="code">a</phrase> or 
									 <phrase role="code">ab</phrase>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Braces (<phrase role="code">{</phrase> and 
									 <phrase role="code">}</phrase>)</para> 
								<para>Braces are used to indicate that a given sequence
									 may appear as many times as desired, including none. For example 
									 <phrase role="code">a { b }</phrase> means that the
									 result could be 
									 <phrase role="code">a</phrase>, or 
									 <phrase role="code">ab</phrase>, or 
									 <phrase role="code">abb</phrase>, etc.,.</para> 
						  </listitem> 
						  <listitem> 
								<para>Double Quotes (<phrase
									 role="code">"</phrase>)</para> 
								<para>Double quotes are used to indicate that a
									 character that would normally be a symbol should be treated as a terminal. For
									 example 
									 <phrase role="code">a "{" b "}"</phrase> means that
									 the result should be 
									 <phrase role="code">a { b }</phrase>.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Every other character in EBNF is a terminal. Terminals should
					 appear in the result exactly as written in the production rules.</para> 
				<para>Production rules consist of a non-terminal followed by the
					 symbol 
					 <phrase role="code">::=</phrase> (which can be read:
					 <emphasis>is defined as</emphasis>) and then a sequence of characters
					 consisting of terminals, non-terminals, and symbols. Non-terminals appearing in
					 the body of a production rule may be replaced with the body of the production
					 rule corresponding to the name of the non-terminal. This process is repeated
					 until there are no non-terminals in the string, and a valid sentence of the
					 language is formed.</para> 
				<para>For example, consider the following simple grammar: 
					 <programlisting>&lt;identifier&gt; ::=
	( _ | &lt;letter&gt; ) { _ | &lt;digit&gt; | &lt;letter&gt; }</programlisting> </para> 
				<para>The non-terminals 
					 <phrase role="code">&lt;letter&gt;</phrase> and 
					 <phrase role="code">&lt;digit&gt;</phrase> have the obvious
					 interpretation. This production rule indicates that an 
					 <phrase role="code">&lt;identifier&gt;</phrase> is defined as
					 an underscore or a letter, followed by any number of characters that can be an
					 underscore, a digit, or a letter. The following strings are valid words in the
					 language described by this grammar: 
					 <programlisting>_Identifier
_2222222
My_Identifier
Foo</programlisting>While the following strings are not words in the language
					 described by this grammar: 
					 <programlisting>12345
Ident#12</programlisting></para> 
				<para>In addition to basic EBNF, the notation used in the guide has
					 the following extensions: 
					 <itemizedlist> 
						  <listitem> 
								<para>Lists</para> 
								<para>The word <emphasis>list</emphasis> appearing at
									 the end of the name of a non-terminal indicates the existence of an implicit
									 production rule given by: 
									 <programlisting>&lt;XYZ list&gt; ::= { &lt;XYZ&gt; }</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Comma separated lists</para> 
								<para>The word <emphasis>commalist</emphasis> appearing
									 at the end of the name of a non-terminal indicates the existence of an implicit
									 production rule given by: 
									 <programlisting>&lt;XYZ commalist&gt; ::= [ &lt;XYZ&gt; {, &lt;XYZ&gt; } ]</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Semi-colon separated lists</para> 
								<para>The word <emphasis>semicolonlist</emphasis>
									 appearing at the end of the name of a non-terminal indicates the existence of
									 an implicit production rule given by: 
									 <programlisting>&lt;XYZ semicolonlist&gt; ::= [ &lt;XYZ&gt; {; &lt;XYZ&gt; } ]</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para>Non-empty lists</para> 
								<para>The word <emphasis>ne</emphasis> appearing at the
									 beginning of the name of a non-terminal with the word
									 <emphasis>list</emphasis>, <emphasis>commalist</emphasis>, or
									 <emphasis>semicolonlist</emphasis> appearing at the end of the non-terminal
									 indicates the existence of an implicit production rule given by: 
									 <programlisting>&lt;ne XYZ list&gt; ::= &lt;XYZ&gt; { &lt;XYZ&gt; }
&lt;ne XYZ commalist&gt; ::= &lt;XYZ&gt; {, &lt;XYZ&gt; }
&lt;ne XYZ semicolonglist&gt; ::= &lt;XYZ&gt; {; &lt;XYZ&gt; }</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These extensions are the same as those used in reference
					 [3].</para> 
				<para>The BNF fragments included in this language guide are
					 somewhat modified in order to facilitate presentation. For a complete BNF
					 reference, refer to the 
					 <ulink url="DRBnfDiagrams.html" type="olinkb">D4 BNF Language
						  Diagrams</ulink>.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGScriptsandExecution"> 
		  <title><indexterm><primary>D4
						  Script</primary></indexterm><indexterm><primary>Scripts</primary></indexterm><indexterm><primary>Execution</primary></indexterm><indexterm><primary>Batch</primary></indexterm><indexterm><primary><phrase
						  role="code"><emphasis
								role="bold">select</emphasis></phrase></primary></indexterm><indexterm><primary><phrase
						  role="code">;</phrase></primary></indexterm>Scripts and Execution</title> 
		  <para> Formally, a D4 script is any string of characters that can be
				formed using the production rules of the D4 grammar. Informally, it is a set of
				instructions that tell the Dataphor Server to perform a particular task or set
				of tasks. A script can be as simple as a single operator invocation that does
				not return a result, or it can be an entire sequence of complicated
				instructions.</para> 
		  <para>Each script is broken down by the compiler into a set of batches.
				Each top-level statement in the script is considered a separate batch, and is
				compiled and executed separately. Each batch is either a statement, i.e. it has
				no return value, or an expression that returns a value. The 
				<phrase role="code"><ulink
					 url="D4LGDataManipulation-SelectStatement.html" type="link"><emphasis
						  role="bold">select</emphasis></ulink></phrase> keyword is used to indicate that
				the results of a given expression should be returned.</para> 
		  <para>The syntax for a D4 script is: 
				<programlisting>&lt;script&gt; ::=
	&lt;statement semicolonlist&gt;</programlisting></para> 
		  <para>Note that the semi-colon in a script is a statement separator. A
				detailed description of the 
				<phrase role="code">&lt;statement&gt;</phrase> production rule is
				given in 
				<ulink url="D4LGLanguageElements-Statements.html"
				type="xref">Statements</ulink>.</para> 
		  <sect1 id="D4LGScriptsandExecution-Connectivity"> 
				<title><indexterm><primary>Call-Level
								Interface</primary></indexterm><indexterm><primary>Execution</primary><secondary>Connectivity</secondary></indexterm>Connectivity</title>
				
				<para>Communication with the Dataphor Server is accomplished
					 through the Call-Level Interface. Connectivity with the server is established
					 by opening a session. This session represents the user context for all
					 subsequent operations against the Dataphor Server. For a detailed description
					 of this interface, refer to the 
					 <ulink url="DDGP1Manager.html" type="olinka">Client Access,
						  Call-Level Interface</ulink>.</para> 
		  </sect1> 
		  <sect1 id="D4LGScriptsandExecution-ErrorHandling"> 
				<title><indexterm><primary>Error
								Handling</primary></indexterm><indexterm><primary>Execution</primary><secondary>Error
								Handling</secondary></indexterm><indexterm><primary>Severity</primary></indexterm>Error
					 Handling</title> 
				<para>The D4 language has built-in facilities for dealing with
					 exception conditions that arise during program execution. These facilities are
					 based on a system-provided type called 
					 <ulink url="T-System.Error.html" type="olinkb"><phrase
						  role="code">System.Error</phrase></ulink>. Values of this type contain various
					 information about the error that occurred such as the error code and the text
					 of the error message. All errors in the D4 language have an associated
					 <emphasis>severity</emphasis>. The possible severities are: 
					 <itemizedlist> 
						  <listitem> 
								<para>Environment</para> 
						  </listitem> 
						  <listitem> 
								<para>System</para> 
						  </listitem> 
						  <listitem> 
								<para>Application</para> 
						  </listitem> 
						  <listitem> 
								<para>User</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>An error with an <emphasis>environment</emphasis> severity
					 indicates that some failure has occurred in the hardware or software
					 environment of the Dataphor Server, for example a disk crash, or operating
					 system failure.</para> 
				<para>The <emphasis>system</emphasis> severity indicates that there
					 is a problem with the Dataphor Server, usually indicating a defect in the
					 software.</para> 
				<para>The <emphasis>application</emphasis> severity level indicates
					 that a problem has occurred which should be correctable by the developer or
					 administrator of the application such as a syntax error or catalog
					 problem.</para> 
				<para>A <emphasis>user</emphasis> severity level indicates that
					 some error has occurred that should be correctable by the user of the
					 application such as an integrity constraint violation, or process logic
					 error.</para> 
				<para>Note that in addition to run-time errors, the D4 compiler
					 will report syntactic or semantic errors. These errors fall into three general
					 categories, all of which are reported at the application severity level: 
					 <itemizedlist> 
						  <listitem> 
								<para>Lexical Errors</para> 
								<para>These errors indicate that the lexical analyzer
									 could not correctly tokenize the input stream.</para> 
						  </listitem> 
						  <listitem> 
								<para>Syntax Errors</para> 
								<para>An error indicating that the given statement is
									 not a valid statement of the D4 language.</para> 
						  </listitem> 
						  <listitem> 
								<para>Compiler Errors</para> 
								<para>An error indicating that some error condition was
									 encountered during the compilation process.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Compiler errors do not necessarily indicate a fatal
					 exception. There are three levels of compiler errors: 
					 <itemizedlist> 
						  <listitem> 
								<para>Warning</para> 
								<para>These indicate that the compiler has detected a
									 condition that may result in a run-time error, or in unexpected behavior. They
									 do not prevent compilation and the resulting statement is still a valid
									 executable plan.</para> 
						  </listitem> 
						  <listitem> 
								<para>Non-Fatal</para> 
								<para>These indicate that the compiler encountered a
									 semantic error such as a type mismatch or unknown identifier, but that the
									 compilation process can continue on the next statement. If any non-fatal errors
									 are encountered, the resulting statement is not a valid executable plan.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Fatal</para> 
								<para>These indicate that the compiler encountered an
									 error condition and could not continue compiling the given statement or set of
									 statements.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>For more information on the error-handling capabilities of
					 the D4 language, refer to 
					 <ulink url="D4LGImperativeStatements-ExceptionHandling.html"
					 type="xref">Exception Handling</ulink>.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGLexicalElements"> 
		  <title><indexterm><primary>Lexical
						  Analyzer</primary></indexterm>Lexical Elements</title> 
		  <para>The lexical elements of the D4 language allow special symbols (or
				tokens) in an input string to be recognized. These tokens help the parser
				determine the syntax of a given statement. A complete BNF reference for the D4
				lexical analyzer can be found in 
				<ulink url="DRBnfDiagrams.html" type="olinkb">D4 BNF Lanquage
					 Diagrams</ulink>.</para> 
		  <sect1 id="D4LGLexicalElements-Whitespace"> 
				<title><indexterm><primary>Whitespace</primary></indexterm>Whitespace</title>
				
				<para>The D4 language, like most computer languages, reserves
					 certain characters as "whitespace". This means that the characters are only
					 used to delimit tokens. The following D4 statements are syntactically
					 equivalent:</para> 
				<para> 
					 <programlisting>X := 5 * 3; 

X:=	5*		3		; 

X := 
5 
* 
3;

X:=5*3;		 </programlisting> </para> 
				<para>The following Unicode character values are considered
					 whitespace in D4: 0x0009 (tab), 0x000a (line feed), 0x000b (vertical tab),
					 0x000c (form feed), 0x000d (carriage return), 0x0085, 0x2028, and
					 0x2029.</para> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-Comments"> 
				<title><indexterm><primary>Comments</primary></indexterm>Comments</title>
				
				<para>Comments are sections of text within D4 code that are ignored
					 by the compiler. Block comments allow for multi-line annotations, whereas line
					 comments are terminated by the line break. Block comments in D4 can be nested,
					 which allows for sections of code to be easily and temporarily "commented out".
					 The following are some examples of D4 comments:</para> 
				<para> 
					 <programlisting>/* This is a multi
   line... /* nested */ ...comment */

X := 5; // Assigns 5 to variable X</programlisting> </para> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-Keywords"> 
				<title><indexterm><primary>Keywords</primary></indexterm><indexterm><primary>Reserved
								words</primary> 
					 </indexterm>Keywords</title> 
				<para>A <emphasis>keyword</emphasis> is a special symbol used by
					 the parser to delimit syntactic structure. For example, the keyword 
					 <phrase role="code"><emphasis
						  role="bold">begin</emphasis></phrase> is used to delimit the beginning of a
					 statement block. To avoid ambiguity while parsing, some keywords are also
					 <emphasis>reserved words</emphasis>. Reserved words are keywords that cannot be
					 used as identifiers because the parser would not be able to distinguish between
					 an identifier and the keyword.</para> 
				<para>The following is a list of all keywords in D4. Keywords with
					 an asterisk (*) denote reserved words. The link provided will show one possible
					 use of the keyword however there may be more. Use the help search to find all
					 uses of a keyword.<simplelist type="vert" columns="4"> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iExtend.html"
									 type="olinka">add</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iAdorn.html"
									 type="olinka">adorn</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">after</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iAggregate.html"
									 type="olinka">aggregate</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-AggregateOperators.html"
									 type="link">aggregation</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"
									 id="O-System.All.html"><ulink url="O-System.All.html"
									 type="olinka">all</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFalterstatement"
									 type="olinka">alter</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iAnd.html" type="olinka">and</ulink></emphasis></phrase></member>
						  
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">apply</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-TypeOperatorClause.html"
									 type="link">as</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGOrders.html" type="link">asc</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">attach</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Objects-ClassDefinitions.html"
									 type="link">attributes</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">before</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-BlocksandScoping.html"
									 type="link">begin</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-BetweenClause.html"
									 type="link">between</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGBreakandContinue.html"
									 type="link">break</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iBrowse.html"
									 type="olinka">browse</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html" type="olinka">by</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFcursorcapabilities"
									 type="olinka">capabilities</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">cascade</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCaseStatement.html"
									 type="link">case</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">change</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Objects-ClassDefinitions.html"
									 type="link">class</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">clear</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFaltercolumndefinition"
									 type="link">column</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryCommitStatement.html"
									 type="link">commit</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-Operators.html"
									 type="link">const</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Constraints.html"
									 type="link">constraint</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGBreakandContinue.html"
									 type="link">continue</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Conversions.html"
									 type="link">conversion</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFcreatestatement"
									 type="olinka">create</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Values-CursorValues.html"
									 type="link">cursor</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes-Defaults.html"
									 type="link">default</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">delete</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGOrders.html" type="link">desc</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">detach</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Devices.html"
									 type="link">device</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Aggregate.html"
									 type="link">distinct</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-ArithmeticExpression.html"
									 type="link">div</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFbinarytableoperator"
									 type="olinka">divide</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGDoWhileStatement.html"
									 type="link">do</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGForStatement.html"
									 type="link">downto</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements.html"
									 type="link">drop</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html"
									 type="olinka">dynamic</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGIfStatement.html"
									 type="link">else</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-BetweenClause.html"
									 type="link">end</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement.html"
									 type="link">except</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGOrders.html" type="link">exclude</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iExists.html"
									 type="olinka">exists</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-FlowControl-ExitStatement.html"
									 type="link">exit</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">explode</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLexicalElements-ParserLiterals-BooleanParserLiterals.html"
									 type="link">false</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-AggregateOperators.html"
									 type="link">finalization</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryFinallyStatement.html"
									 type="link">finally</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGForStatement.html"
									 type="link">for</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-RowExtractor.html"
									 type="link">from</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Types.html"
									 type="link">generic</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">grant</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Aggregate.html"
									 type="link">group</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Having.html"
									 type="link">having</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGIfStatement.html" type="link">if</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iIn.html" type="olinka">in</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html"
									 type="olinka">include</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFindexdefinition"
									 type="olinka">index</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFdevicestoredefinition"
									 type="olinka">indexes</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">inherited</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-AggregateOperators.html"
									 type="link">initialization</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGDataManipulation-InsertStatement.html"
									 type="link">insert</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">intersect</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGDataManipulation-InsertStatement.html"
									 type="link">into</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">invoke</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-TypeOperatorClause.html"
									 type="link">is</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFcursorisolation"
									 type="olinka">isolation</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">join</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGKeys.html" type="link">key</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-OuterJoin.html"
									 type="link">left</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Explode.html"
									 type="link">level</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Conversions-LikeTypes.html"
									 type="link">like</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Types-ListTypes.html"
									 type="link">list</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Join.html"
									 type="link">lookup</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Devices.html"
									 type="link">master</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iMatches.html"
									 type="olinka">matches</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">minus</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"
									 id="O-System.iMod.html"><ulink url="O-System.iMod.html"
									 type="olinka">mod</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Devices.html"
									 type="link">mode</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis
									 role="bold">modify</emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Conversions.html"
									 type="link">narrowing</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"> 
									 <ulink url="D4LGRowConstraints.html"
									 type="link">new</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGNilSemantics.html"
									 type="link">nil</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iNot.html" type="olinka">not</ulink></emphasis></phrase></member>
						  
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Values-TableValues.html"
									 type="link">of</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGRowConstraints.html"
									 type="link">old</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement.html"
									 type="link">on</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-Operators.html"
									 type="link">operator</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iOr.html" type="olinka">or</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGOrders.html" type="link">order</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis
									 role="bold">origin</emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">over</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-Factor.html"
									 type="link">parent</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-RaiseStatement.html"
									 type="link">raise</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGProperties.html" type="link">read</ulink></emphasis></phrase></member>
						  
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Devices.html"
									 type="link">reconciliation</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">recursively</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">redefine</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">reference</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">references</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">remove</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">rename</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGRepeatUntilStatement.html"
									 type="link">repeat</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes-PossibleRepresentations.html"
									 type="link">representation</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">require</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-Operators.html"
									 type="link">result</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Quota.html"
									 type="link">return</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">revert</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">revoke</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-OuterJoin.html"
									 type="link">right</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">role</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-RowExtractor.html"
									 type="link">row</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-OuterJoin.html"
									 type="link">rowexists</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Types-ScalarTypes.html"
									 type="link">scalar</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGDataManipulation-SelectStatement.html"
									 type="link">select</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes-PossibleRepresentations.html"
									 type="link">selector</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Explode.html"
									 type="link">sequence</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Operators-Operators.html"
									 type="link">session</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-References.html"
									 type="link">set</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGOrders.html" type="link">sort</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis
									 role="bold">source</emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes-SpecialValues.html"
									 type="link">special</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFcursortype"
									 type="olinka">static</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGForStatement.html"
									 type="link">step</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFdevicestoredefinition"
									 type="olinka">store</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">table</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4ParserBNF.html#D4ParserBNFtags"
									 type="olinka">tags</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis
									 role="bold">target</emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCaseStatement.html"
									 type="link">then</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">times</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Conversions.html"
									 type="link">to</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGRowConstraints.html"
									 type="link">transition</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="DRD4LexerBNF.html#D4LexerBNFliteral"
									 type="olinka">true</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-ExceptionHandling.html"
									 type="link">try</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes.html"
									 type="link">type</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-ScalarTypes.html"
									 type="link">typeof</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">union</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGRepeatUntilStatement.html"
									 type="link">until</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGDataManipulation-UpdateStatement.html"
									 type="link">update</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">usage</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">user</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Security.html"
									 type="link">users</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Sorts.html"
									 type="link">using</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-EventHandlers.html"
									 type="link">validate</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis
									 role="bold">value</emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-Variables-VariableDeclarationStatement.html"
									 type="link">var</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-TableVariables-Views.html"
									 type="link">view</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCaseStatement.html"
									 type="link">when</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions.html"
									 type="link">where</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
									 type="link">while</ulink></emphasis></phrase></member> 
						  <member><phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGCatalogElements-Conversions.html"
									 type="link">widening</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGLanguageElements-Expressions-LanguageModifiers.html"
									 type="link">with</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGTableExpressions-Without.html"
									 type="link">without</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGProperties.html"
									 type="link">write</ulink></emphasis></phrase></member> 
						  <member>*<phrase role="code"><emphasis role="bold"><ulink
									 url="O-System.iXor.html" type="olinka">xor</ulink></emphasis></phrase></member>
						  
					 </simplelist> </para> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-Symbols"> 
				<title><indexterm><primary>Symbols</primary></indexterm>Symbols</title>
				
				<para>The D4 language also includes several special symbols that
					 are used by the parser to delimit syntatic structure. These include
					 parentheses, brackets, operator symbols, and other characters that have
					 specific meaning within statements of D4. None of these symbols may be used in
					 identifier names.</para> 
				<para>The following are parser-recognized symbols in D4. 
					 <simplelist type="vert" columns="4"> 
						  <member><phrase role="code"><ulink
									 url="O-System.iSubtraction.html" type="olinka">-</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGLexicalElements-ParserLiterals-MoneyParserLiterals.html"
									 type="link">$</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iBitwiseAnd.html" type="olinka">&amp;</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGOperatorInvocation.html" type="link">(</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGOperatorInvocation.html" type="link">)</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iMultiplication.html" type="olinka">*</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iPower.html" type="olinka">**</ulink></phrase></member> 
						  <member><phrase role="code"><ulink url="DRD4LexerBNF.html"
									 type="olinka">,</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGLexicalElements-Identifiers-QualifiedIdentifiers.html"
									 type="link">.</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iDivision.html" type="olinka">/</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGLanguageElements-Variables.html"
									 type="link">:</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGImperativeStatements-Variables-AssignmentStatement.html"
									 type="link">:=</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGScriptsandExecution.html" type="link">;</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iCompare.html" type="olinka">?=</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iIndexer.html" type="olinka">[</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iIndexer.html" type="olinka">]</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iBitwiseXor.html" type="olinka">^</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGLanguageElements-Values-ListValues.html"
									 type="link">{</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iBitwiseOr.html" type="olinka">|</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="D4LGLanguageElements-Values-ListValues.html"
									 type="link">}</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iBitwiseNot.html" type="olinka">~</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iAddition.html" type="olinka">+</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iLess.html" type="olinka">&lt;</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iShiftLeft.html" type="olinka">&lt;&lt;</ulink></phrase></member>
						  
						  <member><phrase role="code"><ulink
									 url="O-System.iInclusiveLess.html"
									 type="olinka">&lt;=</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iNotEqual.html" type="olinka">&lt;&gt;</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iEqual.html" type="olinka">=</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iGreater.html" type="olinka">&gt;</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iInclusiveGreater.html"
									 type="olinka">&gt;=</ulink></phrase></member> 
						  <member><phrase role="code"><ulink
									 url="O-System.iShiftRight.html"
									 type="olinka">&gt;&gt;</ulink></phrase></member> 
					 </simplelist> </para> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-ParserLiterals"> 
				<title><indexterm><primary>Parser
								Literals</primary></indexterm><indexterm><primary>Literals</primary><secondary>Parser
								Literals</secondary></indexterm>Parser Literals</title> 
				<para>A <emphasis>parser literal</emphasis> is a value which is
					 directly understood by the lexer as a token. For example the symbol 
					 <phrase role="code">5</phrase> is a parser literal which
					 represents the 
					 <phrase role="code">System.Integer</phrase> value 5. The
					 following types of parser literals are available in D4: 
					 <itemizedlist> 
						  <listitem> 
								<para>Boolean</para> 
						  </listitem> 
						  <listitem> 
								<para>Integer</para> 
						  </listitem> 
						  <listitem> 
								<para>Decimal</para> 
						  </listitem> 
						  <listitem> 
								<para>Money</para> 
						  </listitem> 
						  <listitem> 
								<para>String</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Here are some examples of parser literals within D4: 
					 <programlisting>"Welcome to the ""community"" website."
'"Hello," she said.'
135
332.12d
31415926535897932e-16
$40.00
<emphasis role="bold">true</emphasis></programlisting> </para> 
				<sect2
				id="D4LGLexicalElements-ParserLiterals-BooleanParserLiterals"> 
					 <title><indexterm><primary>Boolean Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Boolean</secondary></indexterm>Boolean Parser
						  Literals</title> 
					 <para>The boolean parser literal allows values of type 
						  <phrase role="code"><ulink
								url="T-System.Boolean.html" type="olinkb">System.Boolean</ulink></phrase> to be
						  represented directly within D4.</para> 
					 <para>The boolean parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;boolean parser literal&gt; ::=
	<emphasis role="bold">true</emphasis> | <emphasis role="bold">false</emphasis></programlisting></para> 
				</sect2> 
				<sect2
				id="D4LGLexicalElements-ParserLiterals-IntegerParserLiterals"> 
					 <title><indexterm><primary>Integer Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Integer</secondary></indexterm>Integer Parser
						  Literals</title> 
					 <para>The integer parser literal allows values of type 
						  <phrase role="code"><ulink
								url="T-System.Integer.html" type="olinkb">System.Integer</ulink></phrase> to be
						  represented directly within D4. Integer values can be specified as a base 10
						  number using decimal digits, or as a base 16 number using hex digits. Base 16
						  representations must be prefixed with the symbol 
						  <phrase role="code">0x</phrase>.</para> 
					 <para>The integer parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;integer parser literal&gt; ::=
	&lt;digit&gt;{&lt;digit&gt;} | 0x&lt;hexdigit&gt;{&lt;hexdigit&gt;}</programlisting></para> 
				</sect2> 
				<sect2
				id="D4LGLexicalElements-ParserLiterals-DecimalParserLiterals"> 
					 <title><indexterm><primary>Decimal Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Decimal</secondary></indexterm>Decimal Parser
						  Literals</title> 
					 <para>The decimal parser literal allows values of type 
						  <phrase role="code"><ulink
								url="T-System.Decimal.html" type="olinkb">System.Decimal</ulink></phrase> to be
						  represented directly within D4. Note that a sequence of digits alone will be
						  interpreted as a value of type 
						  <phrase role="code">System.Integer</phrase> so the trailing
						  
						  <phrase role="code">d</phrase> must be used.</para> 
					 <para>The decimal parser literal in D4 has the following
						  syntax: 
						  <programlisting>&lt;decimal parser literal&gt; ::=
	&lt;digit&gt;{&lt;digit&gt;}[.{&lt;digit&gt;}][(e|E)[+|-]{&lt;digit&gt;}][d]</programlisting></para> 
				</sect2> 
				<sect2 id="D4LGLexicalElements-ParserLiterals-MoneyParserLiterals">
					 
					 <title><indexterm><primary>Money Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>Money</secondary></indexterm><indexterm><primary><phrase
									 role="code">$</phrase></primary></indexterm>Money Parser Literals</title> 
					 <para>The money parser literal allows values of type 
						  <phrase role="code"><ulink url="T-System.Money.html"
								type="olinkb">System.Money</ulink></phrase> to be represented directly within
						  D4.</para> 
					 <para>The money parser literal in D4 has the following syntax: 
						  <programlisting>&lt;money parser literal&gt; ::=
	$&lt;digit&gt;{&lt;digit&gt;}[.{&lt;digit&gt;}]</programlisting>The 
						  <phrase role="code">$</phrase> symbol is just a symbol for
						  the compiler to identify a data type of money. It does <emphasis>not</emphasis>
						  specifiy the currency used, i.e. dollars.</para> 
				</sect2> 
				<sect2
				id="D4LGLexicalElements-ParserLiterals-StringParserLiterals"> 
					 <title><indexterm><primary>String Parser
									 Literals</primary></indexterm><indexterm><primary>Parser
									 Literals</primary><secondary>String</secondary></indexterm>String Parser
						  Literals</title> 
					 <para>The string parser literal allows values of type 
						  <phrase role="code"><ulink url="T-System.String.html"
								type="olinkb">System.String</ulink></phrase> to be represented directly within
						  D4. Note that the straight single quote character (') or the straight double
						  quote character (") can be used to delimit a string. Do not use curved quote
						  characters. Within the string, the delimiting quote character can be
						  represented by double quoting.</para> 
					 <para>The string parser literal in D4 has the following syntax:
						  
						  <programlisting>&lt;string parser literal&gt; ::=
	""{&lt;character&gt;}"" | '{&lt;character&gt;}'</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-Identifiers"> 
				<title><indexterm><primary>Identifiers</primary></indexterm>Identifiers</title>
				
				<para>Identifiers are user-defined names for catalog objects such
					 as variables and types.</para> 
				<para>D4 identifiers have the following syntax: 
					 <programlisting>&lt;identifier&gt; ::=
	_ | &lt;letter&gt; {_ | &lt;letter&gt; | &lt;digit&gt;}</programlisting></para> 
				<para>Here is an example of a valid D4 identifier: 
					 <programlisting>Customers</programlisting> </para> 
				<sect2 id="D4LGLexicalElements-Identifiers-QualifiedIdentifiers"> 
					 <title><indexterm><primary>Qualified
									 Identifiers</primary></indexterm><indexterm><primary>Identifiers</primary><secondary>Qualified
									 Identifiers</secondary></indexterm><indexterm><primary><phrase
									 role="code">.</phrase></primary></indexterm><indexterm><primary>Namespaces</primary></indexterm><indexterm><primary>Name
									 Resolution</primary></indexterm>Qualified Identifiers</title> 
					 <para>The D4 language uses the concept of namespaces to allow
						  identifiers to be named more completely, yet accessed more concisely. An
						  identifier that utilizes namespaces is called a qualified identifier because it
						  is prefixed by one or more identifiers called qualifiers.</para> 
					 <para>Qualified identifiers have the following syntax: 
						  <programlisting>&lt;qualified identifier&gt; ::=
	[.]{&lt;identifier&gt;.}&lt;identifier&gt;</programlisting></para> 
					 <para>Name resolution with qualified identifiers is based on
						  the notion of <emphasis>name equivalence</emphasis>. A given name is equivalent
						  to another name if and only if it is equal, case-sensitively, to some
						  unqualified version of the name. Thus: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code">A</phrase> is equivalent
										  to 
										  <phrase role="code">A</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">A</phrase> is equivalent
										  to 
										  <phrase role="code">A.A</phrase> and 
										  <phrase role="code">B.A</phrase>, but not 
										  <phrase role="code">A.B</phrase></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">A.A</phrase> is
										  equivalent to 
										  <phrase role="code">A.A</phrase>, but not 
										  <phrase role="code">B.A</phrase></para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>When attempting to resolve a name reference against a
						  list of names such as the set of columns in a table, if the reference is
						  equivalent to more than one name in the list, the reference is considered
						  ambiguous.</para> 
					 <para>The following is an example of a qualified identifier: 
						  <programlisting>MyCompany.MyProduct.Customers</programlisting> </para> 
				</sect2> 
				<sect2
				 id="D4LGLexicalElements-Identifiers-DisambiguatingIdentifiers"> 
					 <title><indexterm><primary>Identifiers</primary><secondary>Disambiguating
									 Identifiers</secondary></indexterm>Disambiguating Identifiers</title> 
					 <para>Unless ambiguous, schema objects can be accessed using
						  their unqualified names. Names must be qualified only to the point where they
						  are no longer ambiguous, but may be qualified more completely if
						  desired.</para> 
					 <para>The following example illustrates the use of namespaces
						  in D4: 
						  <programlisting><emphasis role="bold">var</emphasis> MyCompany.MyProduct.MyVariable : Integer;
<emphasis role="bold">var</emphasis> MyCompany.OtherProduct.MyVariable : Integer;
MyVariable := 5; // Error, MyVariable must be disambiguated
OtherProduct.MyVariable := 5; // Valid
MyCompany.MyProduct.MyVariable := 6; // Also valid </programlisting> </para> 
					 <para>The root of the namespace can be accessed using a dot
						  qualifier with no preceding identifier as follows: 
						  <programlisting><emphasis role="bold">var</emphasis> .I : Integer;
.I := 5; </programlisting> </para> 
					 <!--This is not true anymore. <para>It is an error to create an ambiguous identifier as shown
						  by the following example: 
						  <programlisting><emphasis role="bold">var</emphasis> I : Integer;
<emphasis role="bold">var</emphasis> A.I : Integer; // This is an error </programlisting> </para>-->
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGLexicalElements-Case"> 
				<title><indexterm><primary>Case-Sensitivity</primary><secondary>Of
								D4</secondary></indexterm><indexterm><primary>Pascal-Casing</primary></indexterm>Case</title>
				
				<para>D4 is a case-sensitive language, meaning that the symbols and
					 identifiers read by the compiler will be compared case-sensitively. In other
					 words, the symbol 
					 <phrase role="code">A</phrase> is different than the symbol 
					 <phrase role="code">a</phrase>. The following code sample
					 illustrates this behavior.</para> 
				<para> 
					 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer;
	I := Length("Relational"); // valid reference
	i := Length("Relational"); // unknown identifier
<emphasis role="bold">end</emphasis>; </programlisting> </para> 
				<para>Because D4 is case-sensitive, Alphora recommends the use of
					 Pascal-casing for all identifiers. In Pascal-casing, the first letter of each
					 word in the identifier is capitalized, for example 
					 <phrase role="code">PascalCasing</phrase>. This allows
					 identifiers to have a completely open identifier space because all keywords are
					 all lower case. For example, 
					 <phrase role="code">value</phrase> is not a valid identifier
					 because it conflicts with the reserved word 
					 <phrase role="code"><emphasis
						  role="bold">value</emphasis></phrase>, but 
					 <phrase role="code">Value</phrase> is a valid
					 identifier.</para> 
				<para><indexterm><primary>Case-Sensitivity</primary><secondary>Of
								SQL-based Systems</secondary></indexterm>Note: most SQL-based systems are
					 case-insensitive, so be careful not to rely on casing for identifier
					 resolution, as it could lead to problems when translating into the various
					 dialects of SQL.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGLanguageElements"> 
		  <title>Language Elements</title> 
		  <para>The D4 language is built from six fundamental elements. These
				elements provide the building blocks for all the functionality of the D4
				language. 
				<itemizedlist> 
					 <listitem> 
						  <para>Types</para> 
					 </listitem> 
					 <listitem> 
						  <para>Values</para> 
					 </listitem> 
					 <listitem> 
						  <para>Variables</para> 
					 </listitem> 
					 <listitem> 
						  <para>Operators</para> 
					 </listitem> 
					 <listitem> 
						  <para>Expressions</para> 
					 </listitem> 
					 <listitem> 
						  <para>Statements</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>The following sections discuss each element in detail.</para> 
		  <sect1 id="D4LGLanguageElements-Types"> 
				<title><indexterm><primary>Types</primary></indexterm><indexterm><primary>Data
								Types</primary><see>Types</see></indexterm>Types</title> 
				<para>Data types provide a mechanism for describing classes of
					 values and allow the compiler to verify the correctness of operations against
					 those values. D4 is a strongly typed language, meaning that every variable,
					 value, and argument has a type, and only values of the appropriate type may be
					 used in a given context. For example, only values of type 
					 <phrase role="code">System.Integer</phrase> can be assigned to
					 a variable of declared type 
					 <phrase role="code">System.Integer</phrase>.</para> 
				<para> A type is a named set of values. Any given value has a type
					 associated with it, for example, 
					 <phrase role="code">1</phrase> is a value of type 
					 <phrase role="code">System.Integer</phrase>, and 
					 <phrase role="code"><emphasis role="bold">table</emphasis> {
						  <emphasis role="bold">row</emphasis> { 5 ID } }</phrase> is a table value with
					 type 
					 <phrase role="code"><emphasis role="bold">table</emphasis> { ID
						  : System.Integer }</phrase>. There are several different categories of types,
					 each of which describes a specific kind of value. D4 supports the following
					 categories of types: Scalar, Row, Table, List, and Cursor.</para> 
				<indexterm><primary>Generic</primary></indexterm><indexterm><primary>Types</primary><secondary>Generic</secondary></indexterm>
				
				<indexterm><primary>Type Specifiers</primary></indexterm> 
				<para>Types are specified in D4 using <emphasis>type
					 specifiers</emphasis>. Type specifiers have the following syntax: 
					 <programlisting>&lt;type specifier&gt; ::=
	<emphasis role="bold">generic</emphasis> |
	&lt;scalar type specifier&gt; |
	&lt;row type specifier&gt; |
	&lt;table type specifier&gt; |
	&lt;list type specifier&gt; |
	&lt;cursor type specifier&gt; |
	&lt;typeof type specifier&gt;

&lt;typeof type specifier&gt; ::=
	<emphasis role="bold">typeof</emphasis>"("&lt;expression&gt;")"</programlisting></para> 
				<para>Generic types allow operators to take as arguments values of
					 some category of type. For example, an operator may be able to operate on any
					 scalar value. The generic scalar type 
					 <phrase role="code">System.Scalar</phrase> allows such an
					 operator to be defined. This type is specified using the keyword 
					 <phrase role="code"><emphasis
						  role="bold">scalar</emphasis></phrase> as the type specifier. For information
					 on how to specify the generic type for each category of type, see the section
					 for that type category. The keyword 
					 <phrase role="code"><emphasis
						  role="bold">generic</emphasis></phrase> can be used to specify that an operator
					 may take as argument a value of any type.</para> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">typeof</emphasis></phrase> system operator can be used to select
					 the type of an arbitrary expression.</para> 
				<sect2 id="D4LGLanguageElements-Types-SystemDataTypes"> 
					 <title><indexterm><primary>System Data
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>System
									 Data Types</secondary></indexterm>System Data Types</title> 
					 <para>The descriptions of the date and time types make use of
						  the concept of a <emphasis>tick</emphasis>. A tick is a length of time equal to
						  100 nanoseconds. The internal representation sof the date and time data types
						  all use a 64-bit integer representing a number of ticks.</para> 
					 <para>The following scalar data types are made available by the
						  Dataphor Server: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="D4LGCatalogElements-ScalarTypes.html"
												type="link">System.Scalar</ulink></phrase></para> 
									 <para><phrase role="code">System.Scalar</phrase> is
										  the set of all possible scalar values. The type constraint for scalar is simply
										  
										  <phrase role="code"><emphasis
												role="bold">true</emphasis></phrase>. All scalar types are defined as some
										  subset of the values in the scalar type.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Decimal.html"
												type="olinkb">System.Decimal</ulink></phrase></para> 
									 <para><phrase role="code">System.Decimal</phrase>
										  is the set of all possible decimal numbers. Values of this type are represented
										  physically by a 96-bit signed scaled integer, so in practice, the available
										  values are negative 79,228,162,514,264,337,593,543,950,335
										  (-2<superscript>96</superscript>-1) through positive
										  79,228,162,514,264,337,593,543,950,335
										  (2<superscript>96</superscript>-1).</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Long.html" type="olinkb">System.Long</ulink></phrase></para> 
									 <para><phrase role="code">System.Long</phrase> is
										  the set of all integer values in the range negative 9,223,372,036,854,775,808
										  (-2<superscript>63</superscript>) through positive 9,223,372,036,854,775,807
										  (2<superscript>63</superscript>-1). The physical representation for values of
										  this type is a signed 64-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase
										  role="code">System.Integer</phrase></para> 
									 <para><phrase role="code"><ulink
												url="T-System.Integer.html" type="olinkb">System.Integer</ulink></phrase> is
										  the set of all integer values in the range negative 2,147,483,648
										  (-2<superscript>31</superscript>) through positive 2,147,483,647
										  (2<superscript>31</superscript>-1). The physical representation for values of
										  this type is a signed 32-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Short.html" type="olinkb">System.Short</ulink></phrase></para> 
									 <para><phrase role="code">System.Short</phrase> is
										  the set of all integer values in the range negative 32768
										  (-2<superscript>15</superscript>) through positive 32767
										  (2<superscript>15</superscript>-1). The physical representation for values of
										  this type is a signed 16-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Byte.html" type="olinkb">System.Byte</ulink></phrase></para> 
									 <para><phrase role="code">System.Byte</phrase> is
										  the set of all integer values in the range 0 through positive 255
										  (2<superscript>8</superscript>-1). The physical representation for values of
										  this type is an unsigned 8-bit integer.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Boolean.html"
												type="olinkb">System.Boolean</ulink></phrase></para> 
									 <para><phrase role="code">System.Boolean</phrase>
										  consists of the truth values 
										  <phrase role="code"><emphasis
												role="bold">true</emphasis></phrase> and 
										  <phrase role="code"><emphasis
												role="bold">false</emphasis></phrase>.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.String.html" type="olinkb">System.String</ulink></phrase></para> 
									 <para><phrase role="code">System.String</phrase> is
										  the set of all character strings. The physical representation for values of
										  this type is a Unicode string with a maximum length of
										  2<superscript>31</superscript>-1. The comparison operators for this type are
										  defined case-sensitively.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Guid.html" type="olinkb">System.Guid</ulink></phrase></para> 
									 <para><phrase role="code">System.Guid</phrase> is
										  the set of all possible Globally Unique Identifiers (GUIDs). The physical
										  representation for values of this type is a 128-bit unsigned integer. The
										  operator 
										  <phrase role="code">NewGuid()</phrase>
										  generates a new globally unique identifier.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.TimeSpan.html"
												type="olinkb">System.TimeSpan</ulink></phrase></para> 
									 <para><phrase role="code">System.TimeSpan</phrase>
										  is the set of all possible lengths of time. The physical representation for
										  values of this type is a 64-bit signed integer representing the number of ticks
										  in the time value. This means that the range of values for this type is from
										  negative 10675199 days, 2 hours, 48 minutes, 5.4775808 seconds through positive
										  10675199 days, 2 hours, 48 minutes, 5.4775807 seconds. The granularity for
										  values of this type is one tick.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.DateTime.html"
												type="olinkb">System.DateTime</ulink></phrase></para> 
									 <para> 
										  <phrase role="code">System.DateTime</phrase> is
										  the set of all possible dates, with a time component specified, from a fixed
										  point. The physical representation for values of this type is a 64-bit signed
										  integer representing the number of ticks since 12:00 midnight, January 1, 1
										  C.E. (Common Era) in the Gregorian calendar. This means that the range of
										  values for this type is from 12:00:00 midnight, January 1, 0001 C.E. to
										  11:59:59 P.M., December 31, 9999 C.E. The granularity for values of this type
										  is 1 second. 
										  <footnote id="D4LGDataTypeDateTimeFootnote"> 
												<para>When mapping date and time values
													 into other systems, this range is sometimes considerably reduced. In order to
													 allow for consistent use of date and time values within D4, the concept of
													 <emphasis>acceptable range</emphasis> is introduced as a guideline. All devices
													 that ship with the Dataphor product are capable of storing values within the
													 acceptable ranges for these types. For more information on acceptable range,
													 see 
													 <ulink url="DDGScalarTypeMapping.html"
													  type="olinka"><citetitle>Scalar Type Mapping</citetitle></ulink>.</para> 
										  </footnote></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Date.html" type="olinkb">System.Date</ulink></phrase></para> 
									 <para> 
										  <phrase role="code">System.Date</phrase> is the
										  set of all possible dates from a fixed point. The physical representation for
										  values of this type is a 64-bit signed integer representing the number of ticks
										  since January 1, 1 C.E. (Common Era) in the Gregorian calendar. This means that
										  the range of values for this type is from January 1, 0001 C.E. to December 31,
										  9999 C.E.<footnoteref linkend="D4LGDataTypeDateTimeFootnote"/></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Time.html" type="olinkb">System.Time</ulink></phrase></para> 
									 <para><phrase role="code">System.Time</phrase> is
										  the set of all possible times. The physical representation for values of this
										  type is a 64-bit signed integer representing the number of ticks since 12:00
										  midnight. This means that the range of values for this type is from 12:00:00
										  midnight to 11:59:59 P.M. The granularity for values of this type is 1
										  second.<footnoteref linkend="D4LGDataTypeDateTimeFootnote"/></para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Money.html" type="olinkb">System.Money</ulink></phrase></para> 
									 <para><phrase role="code">System.Money</phrase> is
										  the set of all monetary values in the range negative
										  $79,228,162,514,264,337,593,543,950,335 (-$2<superscript>96</superscript>-1)
										  through positive $79,228,162,514,264,337,593,543,950,335
										  ($2<superscript>96</superscript>-1). The physical representation for values of
										  this type is 96-bit signed scaled integer.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Binary.html" type="olinkb">System.Binary</ulink></phrase></para> 
									 <para><phrase role="code">System.Binary</phrase> is
										  the set of all byte streams of data with length less than or equal to
										  2,147,483,647 (2<superscript>31</superscript>-1).</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="T-System.Error.html" type="olinkb">System.Error</ulink></phrase></para> 
									 <para><phrase role="code">System.Error</phrase> is
										  the set of all error values. Values of this type are used to implement the
										  exception-handling mechanisms of D4.</para> 
								</listitem> 
						  </itemizedlist> </para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-TypeConversions"> 
					 <title><indexterm><primary>Type
									 Conversions</primary></indexterm><indexterm><primary>Types</primary><secondary>Type
									 Conversions</secondary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Type
									 Conversions</secondary></indexterm><indexterm><primary>Conversions</primary></indexterm><indexterm><primary>Implicit
									 Conversions</primary></indexterm>Type Conversions</title> 
					 <para>A conversion operator is a unary operator which converts
						  a value from one type to another. For example, the operator 
						  <phrase role="code">ToString(Integer)</phrase> converts a
						  given integer value into the string represntation of that value. In order to
						  facilitate the definition of new types while re-using the operators defined for
						  existing types, the D4 language allows for the definition of <emphasis>implicit
						  conversions</emphasis>. An implicit conversion specifies that values of some
						  type are implicitly convertable to values of another type. For more information
						  on implicit conversions, refer to 
						  <ulink url="D4LGCatalogElements-Conversions.html"
							type="xref">Conversions</ulink>.</para> 
					 <para> The following matrix describes the validity and
						  availabity of conversion operators. The presence of an E indicates the
						  existence of an operator of the form ToXXX(AValue : YYY) where XXX represents
						  the name of the data type across the table, and YYY represents the name of the
						  data type down the table, which can be used to perform the desired conversion.
						  The presence of a W indicates that a widening conversion operator exists, and
						  that the compiler will implicitly perform the conversion as needed. The
						  presence of an N indicates that a narrowing conversion operator exists, and
						  that the compiler will implicitly perform the conversion as needed. Note that
						  this table only identifies the default conversions. New operators and implicit
						  conversions may be defined to change this behavior.</para> 
					 <para> 
						  <informaltable> 
								<tgroup cols="14"><tbody> 
										  <row><entry>From\To</entry><entry>Boolean</entry><entry>Byte</entry><entry>Short</entry><entry>Integer</entry><entry>Long</entry><entry>Decimal</entry><entry>Money</entry><entry>String</entry><entry>DateTime</entry><entry>Date</entry><entry>Time</entry><entry>TimeSpan</entry><entry>Guid</entry>
												
										  </row> 
										  <row><entry>Boolean</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Byte</entry><entry>E</entry><entry>N/A</entry><entry>W</entry><entry>W</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Short</entry><entry>E</entry><entry>N</entry><entry>N/A</entry><entry>W</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Integer</entry><entry>E</entry><entry>N</entry><entry>N</entry><entry>N/A</entry><entry>W</entry><entry>W</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Long</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N</entry><entry>N/A</entry><entry>W</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Decimal</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Money</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>String</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry><entry>E</entry>
												
										  </row> 
										  <row><entry>DateTime</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>N/A</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Date</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>W</entry><entry>N/A</entry><entry>-</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Time</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>N/A</entry><entry>-</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>TimeSpan</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>N/A</entry><entry>-</entry>
												
										  </row> 
										  <row><entry>Guid</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>E</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>N/A</entry>
												
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-ScalarTypes"> 
					 <title><indexterm><primary>Scalar Types</primary><secondary>As
									 Language
									 Elements</secondary></indexterm><indexterm><primary>Types</primary><secondary>Scalar
									 Types</secondary></indexterm>Scalar Types</title> 
					 <para>Scalar types provide a mechanism for defining and
						  manipulating the basic units of data in D4. Scalar types are types with no
						  user-visible components. This is in contrast to a table type, for example, in
						  which the structure of the value is evident, namely the columns of the table.
						  In other words, scalar types are <emphasis>atomic</emphasis> or
						  <emphasis>encapsulated</emphasis>. Note that the term
						  <emphasis>encapsulated</emphasis> is really synonymous with
						  <emphasis>scalar</emphasis> and as such we do not make use of it.</para> 
					 <para><indexterm><primary>Type
									 Specifiers</primary><secondary>Scalar Type
									 Specifier</secondary></indexterm>Scalar type specifiers have the following
						  syntax: 
						  <programlisting>&lt;scalar type specifier&gt; ::=
	[<emphasis role="bold">generic</emphasis>] <emphasis role="bold">scalar</emphasis> | &lt;scalar type name&gt;</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">scalar</emphasis></phrase> keyword as a type specifier indicates
						  the generic scalar type 
						  <phrase role="code">System.Scalar</phrase>. The generic
						  scalar type consists of all possible scalar values. Any given scalar value will
						  be of some specific scalar type.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGCatalogElements-ScalarTypes.html"
							type="link"> Catalog Elements, Scalar Types</ulink> | 
						  <ulink url="DRSystemLibrary-ScalarTypes.html"
							type="olinka">Dataphor Reference, Scalar Types</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-RowTypes"> 
					 <title><indexterm><primary>Row
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Row
									 Types</secondary></indexterm>Row Types</title> 
					 <para>Row types describe values that are sets of named values.
						  A row type has a <emphasis>heading</emphasis> which describes the columns of
						  the row. Each column has a unique name and an associated type.</para> 
					 <para><indexterm><primary>Type
									 Specifiers</primary><secondary>Row Type Specifier</secondary></indexterm>Row
						  type specifiers have the following syntax: 
						  <programlisting>&lt;row type specifier&gt; ::=
	[<emphasis role="bold">generic</emphasis>] <emphasis role="bold">row</emphasis>["{"&lt;named type specifier commalist&gt;"}"]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The type specifier 
						  <phrase role="code"><emphasis
								role="bold">row</emphasis></phrase> indicates the generic row type 
						  <phrase role="code">System.Row</phrase>. The generic row
						  type consists of all possible row values. Any given row value will be of some
						  specific row type.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Values-RowValues.html"
							type="xref">Row Values</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-TableTypes"> 
					 <title><indexterm><primary>Table
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Table
									 Types</secondary></indexterm>Table Types</title> 
					 <para>Table types provide a mechanism for describing table
						  values, the basic unit of persistence in D4. A table type has a
						  <emphasis>heading</emphasis> which describes the columns of the table. Each
						  column has a unique name and an associated type.</para> 
					 <para><indexterm><primary>Type
									 Specifiers</primary><secondary>Table Type
									 Specifier</secondary></indexterm>Table type specifiers have the following
						  syntax: 
						  <programlisting>&lt;table type specifier&gt; ::=
	[<emphasis role="bold">generic</emphasis>] <emphasis role="bold">table</emphasis>["{"&lt;named type specifier commalist&gt;"}"]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The type specifier 
						  <phrase role="code"><emphasis
								role="bold">table</emphasis></phrase> indicates the generic table type 
						  <phrase role="code">System.Table</phrase>. The generic
						  table type consists of all possible table values. Any given table value will be
						  of some specific table type.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Values-TableValues.html"
							type="xref"> Table Values</ulink> | 
						  <ulink url="D4LGCatalogElements-TableVariables.html"
							type="xref">Table Variables</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-ListTypes"> 
					 <title><indexterm><primary>List
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>List
									 Types</secondary></indexterm>List Types</title> 
					 <para>List types provide a mechanism for describing arbitrary
						  dynamic-length lists of values of the same type.</para> 
					 <para><indexterm><primary>Type
									 Specifiers</primary><secondary>List Type Specifier</secondary></indexterm>List
						  type specifiers have the following syntax: 
						  <programlisting>&lt;list type specifier&gt; ::=
	[<emphasis role="bold">generic</emphasis>] <emphasis role="bold">list</emphasis>["("&lt;type specifier&gt;")"]</programlisting></para> 
					 <para>The type specifier 
						  <phrase role="code"><emphasis
								role="bold">list</emphasis></phrase> indicates the generic list type 
						  <phrase role="code">System.List</phrase>. The generic list
						  type consists of all possible list values. Any given list value will be of some
						  specific list type.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Values-ListValues.html"
							type="xref"> List Values</ulink> | 
						  <ulink
							url="D4LGLanguageElements-Expressions-IndexerExpression.html"
							type="xref">Indexer Expressions</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Types-CursorTypes"> 
					 <title><indexterm><primary>Cursor
									 Types</primary></indexterm><indexterm><primary>Types</primary><secondary>Cursor
									 Types</secondary></indexterm>Cursor Types</title> 
					 <para>Cursor types provide a mechanism for dealing with the
						  results of a table expression a row at a time. Cursor types deal with a
						  specific table type.</para> 
					 <para><indexterm><primary>Type
									 Specifiers</primary><secondary>Cursor Type
									 Specifier</secondary></indexterm>Cursor type specifiers have the following
						  syntax: 
						  <programlisting>&lt;cursor type specifier&gt; ::=
	[<emphasis role="bold">generic</emphasis>] <emphasis role="bold">cursor</emphasis>["("&lt;type specifier&gt;")"]</programlisting></para> 
					 <para>The type specifier 
						  <phrase role="code"><emphasis
								role="bold">cursor</emphasis></phrase> indicates the generic cursor type 
						  <phrase role="code">System.Cursor</phrase>. The generic
						  cursor type consists of all possible cursor values. Any given cursor value will
						  be of some specific cursor type.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Values-CursorValues.html"
							type="xref"> Cursor Values</ulink> | 
						  <ulink
							url="D4LGDataManipulation-SelectStatement-CursorType.html" type="xref">Cursor
								Type</ulink></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGLanguageElements-Values"> 
				<title><indexterm><primary>Values</primary></indexterm>Values</title>
				
				<para>A <emphasis>value</emphasis> is an individual constant that
					 has no location in time or space [3]. A value cannot be updated. Values may be
					 as simple as the integer constant 3, or as complex as a list of table values.
					 Values are the mechanism for data representation in D4.</para> 
				<para> Values are introduced into D4 expressions and statements
					 through the use of special operators called <emphasis><ulink
					 url="D4LGSelector.html" type="link">selectors</ulink></emphasis>. 
					 <ulink url="D4LGLexicalElements-ParserLiterals.html"
					  type="link">Parser literals</ulink> are a kind of built-in selector for certain
					 system data types. For example, the parser literal 
					 <phrase role="code">1</phrase> is a selector for the 
					 <phrase role="code">System.Integer</phrase> value 
					 <phrase role="code">1</phrase>. Similarly, 
					 <phrase role="code"><emphasis role="bold">row</emphasis> { 5 ID
						  }</phrase> is a selector for the row value containing a column named 
					 <phrase role="code">ID</phrase> with the 
					 <phrase role="code">System.Integer</phrase> value 
					 <phrase role="code">5</phrase>.</para> 
				<para><indexterm><primary>Selectors</primary></indexterm>Non-scalar
					 selectors in D4 have the following syntax: 
					 <programlisting>&lt;selector&gt; ::=
	&lt;row selector&gt; |
	&lt;table selector&gt; |
	&lt;list selector&gt; |
	&lt;cursor selector&gt;</programlisting></para> 
				<sect2 id="D4LGLanguageElements-Values-ScalarValues"> 
					 <title><indexterm><primary>Scalar
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Scalar
									 Values</secondary></indexterm>Scalar Values</title> 
					 <para>A scalar value is a value with no user-visible
						  components. The type of any scalar value is a scalar type, specifically. Some
						  possible scalar values include 
						  <phrase role="code">5</phrase>, 
						  <phrase role="code">"String Value"</phrase> or 
						  <phrase role="code">DateTime(2002, 8, 29)</phrase>. In each
						  case, the value described is an atomic value, in that it cannot be broken down
						  into smaller components without ceasing to be a value of the type in question.
						  For a detailed discussion of scalar values, see the discussion in the Catalog
						  Elements chapter on 
						  <ulink url="D4LGCatalogElements-ScalarTypes.html"
							type="xref">Scalar Types</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Types-ScalarTypes.html"
							type="xref"> Scalar Types</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Values-RowValues"> 
					 <title><indexterm><primary>Row
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Row
									 Values</secondary></indexterm>Row Values</title> 
					 <para>A row value is a set of named columns, each with a
						  specified type. The type of a row value is a row type. Each column in the row
						  type has a corresponding value in the row value of the type specified by the
						  column.</para> 
					 <para>If a type specifier is not provided for the row selector,
						  the type of the row is based on the types of all the columns in the row
						  selector. If a type specifier is provided, then the expressions given provide
						  values for the specified columns of the row. Any columns of the row that do not
						  have a value provided will be set to 
						  <phrase role="code">nil</phrase>.</para> 
					 <para><indexterm><primary>Row
									 Selector</primary></indexterm><indexterm><primary>Selectors</primary><secondary>Row
									 Selector</secondary></indexterm>Row selectors have the following syntax: 
						  <programlisting>&lt;row selector&gt; ::=
	<emphasis role="bold">row</emphasis>
		[<emphasis role="bold">of</emphasis> (("{"&lt;named type specifier commalist&gt;"}") | &lt;typeof type specifier&gt;)] 
		"{"&lt;named expression term commalist&gt;"}"
	
&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;

&lt;named expression term&gt; ::=
	&lt;expression term&gt; &lt;column name&gt; &lt;metadata&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>
						  production rule see 
						  <ulink url="D4LGLanguageElements-Types.html"
							type="xref">Types</ulink></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;expression&nbsp;term&gt;</phrase>
						  production rule see 
						  <ulink url="D4LGLanguageElements-Expressions.html"
							type="xref">Expressions</ulink>.</para> 
					 <para>The following example illustrates the use of the row
						  selector: 
						  <programlisting><emphasis role="bold">select row</emphasis> { 53 Age, "Green" EyeColor };
<emphasis role="bold">select row of</emphasis> { Age : Integer, EyeColor : String } { };</programlisting> </para> 
					 <para>For more information on using row values in D4, see 
						  <ulink
							url="DDGModelingProcessLogic-ValuesandVariables-UsingRows.html"
							type="olinka">Using Rows</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Types-RowTypes.html"
							type="xref">Row Types</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Values-TableValues"> 
					 <title><indexterm><primary>Table
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Table
									 Values</secondary></indexterm>Table Values</title> 
					 <para> Table values are sets of row values, where each row is
						  of the same type. The heading of the table type is a set of uniquely named
						  columns and the types on which they are defined. All rows within a table value
						  must have the same heading as the table type. Note that a table value is a set
						  of row values, meaning that no two rows in the table are ever permitted to have
						  the same value for all columns. In practice, this constraint is usually
						  enforced by defining a key on some subset of the columns in the table. If a key
						  constraint is not defined in the table selector, or create table statement, the
						  key defaults to all columns in the table 
						  <footnote> 
								<para>More precisely, the key is created for all
									 columns of the table that are defined on types for which a comparison operator
									 is defined.</para> 
						  </footnote>.</para> 
					 <para>If the optional type specifier clause is not provided as
						  part of the table selector expression, the type of the resulting table value
						  will be inferred from the type of the first row expression in the table
						  selector. Once the type of the table selector has been specified, either with
						  the of clause, or by inference from the first row expression, the names of
						  columns in subsequent row selectors may be omitted as a shorthand. Of course,
						  if names are not specified, the expressions in the row selector must appear in
						  the same order as the heading for the table. If names are specified for the
						  expressions in a particular row selector, then the columns may appear in any
						  order.</para> 
					 <para><indexterm><primary>Table
									 Selector</primary></indexterm><indexterm><primary>Selectors</primary><secondary>Table
									 Selector</secondary></indexterm>Table selectors have the following syntax: 
						  <programlisting>&lt;table selector&gt; ::=
	<emphasis role="bold">table</emphasis> 
		[<emphasis role="bold">of</emphasis> (("{"&lt;named type specifier commalist&gt;"}") | &lt;typeof type specifier&gt;)] 
		"{"&lt;table selector item commalist&gt;"}"
	
&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;

&lt;table selector item&gt; ::=
	&lt;expression&gt; |
	&lt;key definition&gt;</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>
						  production rule see 
						  <ulink url="D4LGLanguageElements-Types.html"
							type="xref">Types</ulink></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;expression&gt;</phrase> production
						  rule see 
						  <ulink url="D4LGLanguageElements-Expressions.html"
							type="xref">Expressions</ulink>.</para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;key&nbsp;definition&gt;</phrase>
						  production rule see 
						  <ulink url="D4LGKeys.html">Keys</ulink>.</para> 
					 <para>The following example illustrates the use of the table
						  selector: 
						  <programlisting><emphasis role="bold">select table</emphasis> 
{
	<emphasis role="bold">row</emphasis> { 3.14d DecimalNumber },
	<emphasis role="bold">row</emphasis> { 2.3d },
	<emphasis role="bold">row</emphasis> { 2.7d }
};

<emphasis role="bold">select table of</emphasis> { DecimalNumber : Decimal } { };</programlisting></para> 
					 <para>For more information on using table values in D4, see 
						  <ulink url="D4LGTableExpressions.html" type="xref">Table
								Operators</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGLanguageElements-Types-TableTypes.html"
							type="xref">Table Types</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Values-ListValues"> 
					 <title><indexterm><primary>List
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>List
									 Values</secondary></indexterm><indexterm><primary><phrase
									 role="code">{}</phrase> - List Selector</primary></indexterm>List
						  Values</title> 
					 <para> List values are lists of values of the same type. Each
						  item in the list is addressable through an indexer by its ordinal position in
						  the list. Lists are allowed to contain duplicate values.</para> 
					 <para><indexterm><primary>List
									 Selector</primary></indexterm><indexterm><primary>Selectors</primary><secondary>List
									 Selector</secondary></indexterm>List selectors have the following syntax: 
						  <programlisting>&lt;list selector&gt; ::=
	[&lt;list type specifier&gt;]"{"&lt;expression&gt;"}"</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;expression&gt;</phrase> production
						  rule see 
						  <ulink url="D4LGLanguageElements-Expressions.html"
							type="xref">Expressions</ulink>.</para> 
					 <para>For more information on using list values in D4, see 
						  <ulink
							url="DDGModelingProcessLogic-ValuesandVariables-UsingLists" type="olinka">Using
								Lists</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink
							url="D4LGLanguageElements-Types-ListTypes.html" type="xref">List Types</ulink>
						  | 
						  <ulink
							url="D4LGLanguageElements-Expressions-IndexerExpression.html"
							type="xref">Indexer Expressions</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Values-CursorValues"> 
					 <title><indexterm><primary>Cursor
									 Values</primary></indexterm><indexterm><primary>Values</primary><secondary>Cursor
									 Values</secondary></indexterm>Cursor Values</title> 
					 <para>Cursor values are values that provide row-at-a-time
						  cursor style access to table values. Selecting a cursor value allocates system
						  resources that must be released by calling 
						  <phrase role="code"><ulink url="O-System.Close.html"
								type="olinka">Close()</ulink></phrase> on the cursor. For a detailed
						  description of the operators available for cursors, see 
						  <ulink
							url="DDGModelingProcessLogic-ValuesandVariables-UsingCursors.html"
							type="olinka">Using Cursors</ulink>.</para> 
					 <para><indexterm><primary>Cursor
									 Selector</primary></indexterm><indexterm><primary>Selectors</primary><secondary>Cursor
									 Selector</secondary></indexterm>Cursor selectors have the following syntax: 
						  <programlisting>&lt;cursor selector&gt; ::=
	<emphasis role="bold">cursor</emphasis>"("&lt;cursor definition&gt;")"</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;cursor&nbsp;definition&gt;</phrase>
						  production rule see the select statement syntax in 
						  <ulink
							url="D4LGDataManipulation-SelectStatement.html" type="link">Select
								Statement</ulink>.</para> 
					 <para>For more information on using cursor values in D4, see 
						  <ulink
							url="DDGModelingProcessLogic-ValuesandVariables-UsingCursors.html"
							type="olinka">Using Cursors</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="DDGP1Cursor.html" type="olinka">Cursor,
								CLI</ulink> | 
						  <ulink
							url="D4LGLanguageElements-Expressions-IndexerExpression.html"
							type="xref">Indexer Expressions</ulink></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGLanguageElements-Variables"> 
				<title><indexterm><primary>Variables</primary></indexterm><indexterm><primary>Variable
								Declaration Statement</primary></indexterm><indexterm><primary>Variable
								Initializer</primary></indexterm><indexterm><primary>Initializer</primary></indexterm><indexterm><primary>Uninitialized
								Variable</primary></indexterm>Variables</title> 
				<para>A variable is a container for an appearance of a value [3].
					 Variables do have location in space and time, and the value of any given
					 variable at any given point can change. This is not to say that the value
					 changed, but that the variable contains a different value. </para> 
				<para>Variables are declared to be of some type, and this type
					 determines what values the variable can contain. For example, a variable of
					 declared type 
					 <phrase role="code">System.Integer</phrase> can only contain
					 values that are of type 
					 <phrase role="code">System.Integer</phrase>. This is enforced
					 by the compiler.</para> 
				<para>An important point about variables in a database management
					 system is that tables are variables. The type of such a variable is a table
					 type, and the value at any given point is a table value of that same type.
					 Conceptually then, all the manipulative operators of the language such as 
					 <phrase role="code"><emphasis
						  role="bold">insert</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">update</emphasis></phrase>, and 
					 <phrase role="code"><emphasis
						  role="bold">delete</emphasis></phrase> are just shorthands for some equivalent
					 assignment statement. Tables might then more appropriately have been called
					 <emphasis><ulink url="D4LGCatalogElements-TableVariables.html"
					 type="xref">table variables</ulink></emphasis>, and indeed we refer to them as
					 such throughout the documentation, but for reasons of brevity and familiarity
					 in the language, we chose the more traditional name 
					 <phrase role="code"><emphasis
						  role="bold">table</emphasis></phrase>.</para> 
				<para><ulink
					 url="D4LGImperativeStatements-Variables-VariableDeclarationStatement.html"
					 type="xref">Variable declaration</ulink> in D4 has the following syntax: 
					 <programlisting>&lt;variable declaration statement&gt; ::=
	<emphasis role="bold">var</emphasis> &lt;ne variable definition commalist&gt;
	
&lt;variable definition&gt; ::=
	&lt;qualified identifier&gt; [: &lt;type specifier&gt;] [:= &lt;expression&gt;]</programlisting></para> 
				<para>The optional 
					 <phrase role="code">&lt;expression&gt;</phrase> specifies an
					 initial value for the variable. If no initial value is specified, the type of
					 the variable is used to determine a default value for the variable. If no
					 default value is specified as part of the type definition, the variable is said
					 to be <emphasis>uninitialized</emphasis> or <emphasis><ulink
					 url="D4LGNilSemantics.html" type="link">nil</ulink></emphasis>.</para> 
				<para>Note that the 
					 <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase> in a 
					 <phrase role="code">&lt;variable&nbsp;definition&gt;</phrase>
					 is optional if an initial value is given. In this case, the type of the
					 variable is defined to be the result type of the initial value. For example,
					 the statement: 
					 <programlisting><emphasis role="bold">var</emphasis> LInteger := 5;</programlisting>declares a variable of type 
					 <phrase role="code">System.Integer</phrase> named 
					 <phrase role="code">LInteger</phrase> and assigns it the
					 integer value 
					 <phrase role="code">5</phrase>.</para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;qualified&nbsp;identifier&gt;</phrase>
					 production rule see 
					 <ulink url="D4LGLexicalElements-Identifiers.html"
					  type="xref">Identifiers</ulink>.</para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>
					 production rule see 
					 <ulink url="D4LGLanguageElements-Types.html"
					  type="xref">Types</ulink>.</para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;expression&gt;</phrase> production rule
					 see 
					 <ulink url="D4LGLanguageElements-Expressions.html"
					  type="xref">Expressions</ulink>.</para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para> 
					 <ulink url="D4LGImperativeStatements-Variables.html"
					  type="xref">Variables</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGLanguageElements-Operators"> 
				<title><indexterm><primary>Operators</primary><secondary>As
								Language ElementsDAEDAE</secondary></indexterm>Operators</title> 
				<para> D4 operators are executable, pre-compiled subroutines. They
					 may be explicitly called, invoked using a built-in operator such as 
					 <phrase role="code">+</phrase>, or attached to events caused by
					 actions such as data manipulation.</para> 
				<para>The Dataphor Server provides extensive libraries for
					 performing basic manipulation of values of the system data types. These
					 operators are covered in detail in the various library references in the
					 Dataphor Reference. These operators are known as
					 <emphasis>system-provided</emphasis> operators, but the distinction has no
					 affect on functionality.</para> 
				<para>A given D4 operator may be built-in, such as the 
					 <phrase role="code">+</phrase> operator. This means that the
					 operator is recognized by the parser and the invocation has special syntax.
					 With very few exceptions, such as the 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> operator, a parser-recognized invocation
					 has an equivalent standard invocation. For example, the following invocations
					 are equivalent: 
					 <programlisting>5 + 5
iAddition(5, 5)</programlisting></para> 
				<para>A given D4 operator may be host-implemented (or external).
					 This indicates that the implementation of the operator is not a block of D4
					 statements, but an external routine referenced via a class definition.</para> 
				<para>Like 
					 <ulink url="D4LGLanguageElements-Expressions"
					  type="xref">expressions</ulink>, every D4 operator has the following
					 characteristics<indexterm><primary>Characteristics</primary><secondary>Operator</secondary></indexterm><indexterm><primary>Operator</primary><secondary>Characteristics</secondary></indexterm>
					 which determine its behavior within the Dataphor Server: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Literal</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Literal</secondary><tertiary>Operators</tertiary></indexterm>
								
								<para>Literal</para> 
								<para>A <emphasis>literal</emphasis> operator is one
									 which does not reference global state, i.e. it does not reference any table
									 variable in the database. In other words, a literal operator is one which could
									 be evaluated at compile-time.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Functional</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Functional</secondary><tertiary>Operators</tertiary></indexterm>
								
								<para>Functional</para> 
								<para>A <emphasis>functional</emphasis> operator is one
									 which does not change global state, i.e. it does not update any table variable
									 in the database. Functional operators are required in certain contexts such as
									 constraint expressions.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Deterministic</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Deterministic</secondary><tertiary>Operators</tertiary></indexterm>
								
								<para>Deterministic</para> 
								<para>A <emphasis>deterministic</emphasis> operator is
									 one which always returns the same value for the same set of inputs.
									 Deterministic operators are required in certain contexts such as constraint
									 expressions.</para> 
						  </listitem> 
						  <listitem><indexterm><primary>Repeatable</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Repeatable</secondary><tertiary>Operators</tertiary></indexterm>
								
								<para>Repeatable</para> 
								<para>A <emphasis>repeatable</emphasis> operator is one
									 which always returns the same value for the same set of inputs within the same
									 transaction context. Note that if an operator is deterministic, it is also
									 repeatable, but that a non-deterministic operator may or may not be repeatable.
									 For example, both 
									 <phrase role="code">DateTime()</phrase> and 
									 <phrase role="code">Random()</phrase> are
									 non-deterministic operators, but 
									 <phrase role="code">DateTime()</phrase> is
									 repeatable within a given transaction (in other words, when invoked within a
									 transaction 
									 <phrase role="code">DateTime()</phrase> will always
									 return the start time of the transaction) whereas 
									 <phrase role="code">Random()</phrase> will in
									 general return a different value on successive invocations within a
									 transaction.</para> 
								<para>As with deterministic operators, repeatable
									 operators are required in certain contexts such as restriction
									 conditions.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Nilable</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Nilable</secondary><tertiary>Operators</tertiary></indexterm>
								
								<para>Nilable</para> 
								<para>A <emphasis>nilable</emphasis> operator is one
									 which may return a <emphasis><ulink url="D4LGNilSemantics.html"
									 type="link">nil</ulink></emphasis>, or no value, at run-time.</para> 
						  </listitem> 
						  <listitem><indexterm><primary>Order-Dependent</primary><secondary>Aggregate
										  Operator
										  Characteristic</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Order-dependent</secondary></indexterm>
								
								<para>Order-dependent</para> 
								<para>An <emphasis>order-dependent</emphasis> aggregate
									 operator is one whose semantics depend on the order in which the rows of the
									 input are aggregated. If an aggregate operator is marked order-dependent, the
									 compile will issue a warning if the actual argument to that operator is not
									 well-ordered (ordered by at least a key).</para> 
						  </listitem> 
						  <listitem><indexterm><primary>Order
										  Preserving</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Order
										  Preserving</secondary><tertiary>Operators</tertiary></indexterm> 
								<para>Order Preserving</para> 
								<para>An <emphasis>order preserving</emphasis> operator
									 is one which preserves the ordering semantics of the value. Formally, a unary
									 operator 
									 <phrase role="code">O</phrase> with argument type 
									 <phrase role="code">Ta</phrase> and result type 
									 <phrase role="code">Tr</phrase> is order preserving
									 if for every pair of values 
									 <phrase role="code">V1</phrase> and 
									 <phrase role="code">V2</phrase> of type 
									 <phrase role="code">Ta</phrase> for which the
									 expression 
									 <phrase role="code">V1&nbsp;&gt;=&nbsp;V2</phrase>
									 evaluates to true, the expression 
									 <phrase
									  role="code">O(V1)&nbsp;&gt;=&nbsp;O(V2)</phrase> also evaluates to true.</para>
								
						  </listitem> 
					 </itemizedlist></para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para> 
					 <ulink url="D4LGCatalogElements-Operators.html"
					  type="link">Catalog Elements, Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGLanguageElements-Statements"> 
				<title><indexterm><primary>Statements</primary></indexterm><indexterm><primary>Data
								Definition Language</primary></indexterm><indexterm><primary>Data Manipulation
								Language</primary></indexterm><indexterm><primary>Imperative
								Statements</primary></indexterm>Statements</title> 
				<para>A statement is the fundamental unit of execution in D4. All
					 statements of D4 fall into three basic categories: 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para>Data Definition Language (DDL)</para> 
						  </listitem> 
						  <listitem> 
								<para>Data Manipulation Language (DML)</para> 
						  </listitem> 
						  <listitem> 
								<para>Imperative</para> 
						  </listitem> 
					 </itemizedlist> </para> 
				<para>Data Definition Language statements are concerned with
					 describing the structure of the database. They allow for the creation,
					 alteration, and destruction of catalog level objects. These statements are
					 discussed in 
					 <ulink url="D4LGCatalogElements.html" type="xref">Catalog
						  Elements</ulink>.</para> 
				<para>Data Manipulation Language statements allow for the retrieval
					 and modification of the data in the database. These include 
					 <phrase role="code"><emphasis
						  role="bold">select</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">insert</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">update</emphasis></phrase>, and 
					 <phrase role="code"><emphasis
						  role="bold">delete</emphasis></phrase>, and are discussed in 
					 <ulink url="D4LGDataManipulation.html" type="xref">Data
						  Manipulation</ulink>.</para> 
				<para>Imperative statements provide the execution framework for the
					 D4 language. These statements provide functionality such as variable
					 declaration, flow control, and exception handling. These statements are
					 discussed in detail in 
					 <ulink url="D4LGImperativeStatements.html"
					  type="xref">Imperative Statements</ulink>.</para> 
				<para>Statements in D4 have the following syntax: 
					 <programlisting>&lt;statement&gt; ::=
	&lt;dml statement&gt; |
	&lt;ddl statement&gt; |
	&lt;imperative statement&gt;	</programlisting></para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;ddl&nbsp;statement&gt;</phrase>
					 production rule see 
					 <ulink url="D4LGCatalogElements.html" type="xref">Catalog
						  Elements</ulink>.</para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;dml&nbsp;statement&gt;</phrase>
					 production rule see 
					 <ulink url="D4LGDataManipulation.html" type="xref">Data
						  Manipulation</ulink>.</para> 
				<para>For a detailed description of the 
					 <phrase role="code">&lt;imperative&nbsp;statement&gt;</phrase>
					 production rule see 
					 <ulink url="D4LGImperativeStatements.html"
					  type="xref">Imperative Statements</ulink>.</para> 
		  </sect1> 
		  <sect1 id="D4LGLanguageElements-Expressions"> 
				<title><indexterm><primary>Expressions</primary></indexterm>Expressions</title>
				
				<para>A D4 expression is a statement that returns a result. This
					 includes 
					 <ulink url="D4LGLexicalElements-ParserLiterals.html"
					  type="xref">parser literals</ulink> and 
					 <ulink url="D4LGOperatorInvocation.html" type="link">operator
						  invocations</ulink>. The result of evaluating any given expression is either a
					 value or <emphasis><ulink url="D4LGNilSemantics.html"
					 type="link">nil</ulink></emphasis>. Expressions are built according to the 
					 <ulink url="D4LGLanguageElements-Expressions.html"
					  type="link"><phrase role="code">&lt;expression&gt;</phrase> production
						  rule</ulink>. The following are examples of valid D4 expressions. 
					 <programlisting>5
6 * 42
<emphasis role="bold">true</emphasis> <emphasis role="bold">and</emphasis> <emphasis role="bold">not</emphasis> (Length(MyName) = 0)</programlisting> </para> 
				<para>Just like 
					 <ulink url="D4LGLanguageElements-Operators.html"
					  type="xref">operators</ulink>, every D4 expression has the following
					 characteristics<indexterm><primary>Characteristics</primary><secondary>Expression</secondary></indexterm><indexterm><primary>Expression</primary><secondary>Characteristics</secondary></indexterm>
					 which determine its behavior within the Dataphor Server: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Literal</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Literal</secondary><tertiary>Expressions</tertiary></indexterm>
								
								<para>Literal</para> 
								<para>An expression is <emphasis>literal</emphasis> if
									 it consists entirely of parser literals and literal operator invocations. As
									 noted before, a literal expression can be evaluated at compile-time. The type
									 and value of literals is fixed for all time [3]. Any given invocation is
									 literal if its arguments (if any) are all literals in turn [3]. Clearly, any
									 expression which references any table variables in the database is not
									 literal.</para> 
								<para>The following are some examples of expressions,
									 some of which are literal: 
									 <programlisting>Days(720500d) // literal 
-5231&nbsp;// literal
Length(MyString) // not literal
Error("Error: " + AMessage) // not literal </programlisting> </para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Functional</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Functional</secondary><tertiary>Expressions</tertiary></indexterm>
								
								<para>Functional</para> 
								<para>An expression is <emphasis>functional</emphasis>
									 if it makes no change to any table variables in the database, and makes no
									 calls to non-functional operators.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Deterministic</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Deterministic</secondary><tertiary>Expressions</tertiary></indexterm>
								
								<para>Deterministic</para> 
								<para>An expression is
									 <emphasis>deterministic</emphasis> if it makes no calls to non-deterministic
									 operators.</para> 
						  </listitem> 
						  <listitem><indexterm><primary>Repeatable</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Repeatable</secondary><tertiary>Expressions</tertiary></indexterm>
								
								<para>Repeatable</para> 
								<para>An expression is <emphasis>repeatable</emphasis>
									 if it makes no calls to non-repeatable operators.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Nilable</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Nilable</secondary><tertiary>Expressions</tertiary></indexterm>
								
								<para>Nilable</para> 
								<para>An expression is <emphasis>nilable</emphasis> if
									 it may result in a <emphasis><ulink url="D4LGNilSemantics.html"
									 type="link">nil</ulink></emphasis>. In general, expressions are nilable if they
									 make calls to nilable operators, contain references to nilable columns, or
									 contain the 
									 <phrase role="code"><emphasis
										  role="bold">nil</emphasis></phrase> reserved word. Some operators such as 
									 <phrase role="code">IsNil</phrase> will never
									 result in a nil.</para> 
						  </listitem> 
						  <listitem><indexterm><primary>Order
										  Preserving</primary><secondary>Expressions</secondary></indexterm><indexterm><primary>Characteristics</primary><secondary>Order
										  Preserving</secondary><tertiary>Expressions</tertiary></indexterm> 
								<para>Order Preserving</para> 
								<para>An expression is
									 <emphasis>order-preserving</emphasis> if it preserves the comparison semantics
									 of the value of its argument. In general, an expression is order-preserving if
									 it consists entirely of context-literal expressions and invocations of
									 order-preserving operators.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>These characteristics are fixed by the compiler and are
					 determined by the elements of the expression. For example, an expression
					 containing an invocation of a non-deterministic operator is itself
					 non-deterministic.</para> 
				<para>D4 expressions have the following syntax: 
					 <programlisting>&lt;expression&gt; ::= 
	&lt;modified expression term&gt; &lt;table operator clause list&gt;

&lt;modified expression term&gt; ::=
	&lt;expression term&gt; [&lt;language modifiers&gt;]

&lt;expression term&gt; ::= 
	&lt;binary expression&gt; &lt;ternary or type operator clause list&gt;

&lt;ternary or type operator clause&gt; ::=
	&lt;between clause&gt; |
	&lt;type operator clause&gt;</programlisting></para> 
				<para>For a detailed description of the 
					 <phrase
					  role="code">&lt;table&nbsp;operator&nbsp;clause&gt;</phrase> production rule
					 see 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink>.</para> 
				<sect2 id="D4LGNilSemantics"> 
					 <title><indexterm><primary>Nil
									 Semantics</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Nil
									 Semantics</secondary></indexterm><indexterm><primary>Null - Nil
									 Semantics</primary></indexterm><indexterm><primary>IfNil - Nil
									 Semantics</primary></indexterm><indexterm><primary>IsNil - Nil
									 Semantics</primary></indexterm> Nil Semantics</title> 
					 <para>Evaluating any given expression may result in
						  <emphasis>nil</emphasis>. Nil is a placeholder indicating that evaluation of
						  the expression did not return a value. The reserved word 
						  <phrase role="code"><emphasis
								role="bold">nil</emphasis></phrase> can be used within an expression to produce
						  this placeholder. The compiler-defined nilable characteristic is used to
						  determine whether or not a given expression could result in a nil at run-time.
						  </para> 
					 <para>In general, most operators will result in a nil if any of
						  their arguments are nil. For specific information on the nil-handling
						  characteristics of an operator, refer to the documentation for that operator.
						  The following operators are specifically included for handling nil results: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="O-System.IsNil.html" type="olinka">IsNil(<emphasis
													 role="bold">generic</emphasis>) : Boolean</ulink></phrase></para> 
									 <para>Returns true if the result of evaluating the
										  given expression is nil, false otherwise.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code"><ulink
												url="O-System.IfNil.html" type="olinka">IfNil(<emphasis
													 role="bold">generic</emphasis>, <emphasis role="bold">generic</emphasis>) :
													 <emphasis role="bold">generic</emphasis></ulink></phrase></para> 
									 <para>Returns the result of evaluating the first
										  expression if the result is not nil, otherwise returns the result of evaluating
										  the second expression.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Note that while 
						  <phrase role="code">IsNil</phrase> is guaranteed to return
						  a value, 
						  <phrase role="code">IfNil</phrase> could still return a nil
						  if the second expression is nilable.</para> 
					 <para>Nils may be introduced by the following elements within a
						  given expression: 
						  <itemizedlist> 
								<listitem> 
									 <para>Explicit reference via the 
										  <phrase role="code"><emphasis
												role="bold">nil</emphasis></phrase> reserved word.</para> 
								</listitem> 
								<listitem> 
									 <para>Reference to a nilable column of a table or
										  row.</para> 
								</listitem> 
								<listitem> 
									 <para>Reference to an uninitialized
										  variable.</para> 
								</listitem> 
								<listitem> 
									 <para>Invocation of an aggregate operator other
										  than 
										  <phrase role="code">Count</phrase> on an empty
										  set.</para> 
								</listitem> 
								<listitem> 
									 <para>Invocation of a row extractor on an empty
										  set.</para> 
								</listitem> 
								<listitem> 
									 <para>Invocation of a column extractor on a
										  row-valued expression that evaluates to nil.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>When nils are used as the arguments to comparison
						  operators (<phrase role="code">=</phrase>, 
						  <phrase role="code">&lt;&gt;</phrase>, 
						  <phrase role="code">&lt;</phrase>, 
						  <phrase role="code">&gt;</phrase>, 
						  <phrase role="code">&lt;=</phrase>, 
						  <phrase role="code">&gt;=</phrase>, and 
						  <phrase role="code">?=</phrase>) the result is not true or
						  false, but nil, even if both arguments are nil. In other words, the result of
						  evaluating the expression 
						  <phrase role="code"><emphasis role="bold">nil</emphasis> =
								<emphasis role="bold">nil</emphasis></phrase> is nil.</para> 
					 <para>When performing row-level comparisons, if both rows have
						  no value for the same columns, the columns are considered equal. In other
						  words, column equality between rows is defined as: 
						  <phrase role="code">(IsNil(<emphasis
								role="bold">left</emphasis>.<emphasis role="bold">value</emphasis>) and
								IsNil(<emphasis role="bold">right</emphasis>.<emphasis
								role="bold">value</emphasis>)) or (<emphasis
								role="bold">left</emphasis>.<emphasis role="bold">value</emphasis> =
								<emphasis role="bold">right</emphasis>.<emphasis
								role="bold">value</emphasis>)</phrase>.</para> 
					 <para>This definition of row equality in the presence of nils
						  is used throughout D4 whenever row comparison is required: 
						  <itemizedlist> 
								<listitem> 
									 <para>Key constraint expressions</para> 
								</listitem> 
								<listitem> 
									 <para>Reference constraints</para> 
								</listitem> 
								<listitem> 
									 <para>Projection (<phrase role="code"><emphasis
												role="bold">over</emphasis></phrase> and 
										  <phrase role="code"><emphasis
												role="bold">remove</emphasis></phrase>)</para> 
								</listitem> 
								<listitem> 
									 <para>Union (<phrase role="code"><emphasis
												role="bold">union</emphasis></phrase>)</para> 
								</listitem> 
								<listitem> 
									 <para>Difference (<phrase role="code"><emphasis
												role="bold">minus</emphasis></phrase>)</para> 
								</listitem> 
								<listitem> 
									 <para>Aggregation (<phrase role="code"><emphasis
												role="bold">group</emphasis></phrase>)</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>When nils are encountered in table level operations such
						  as 
						  <phrase role="code"><emphasis
								role="bold">where</emphasis></phrase>, they are considered equivalent to false.
						  When constraint expressions evaluate to nil, the constraint is considered
						  satisfied.</para> 
					 <para>When nils are used as the arguments to logical operators
						  (<phrase role="code"><emphasis role="bold">and</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">or</emphasis></phrase>, and 
						  <phrase role="code"><emphasis
								role="bold">not</emphasis></phrase>) the result depends on the operator
						  invoked, as shown in the following tables.</para> 
					 <para>The following table displays the results of evaluating 
						  <phrase role="code"><emphasis
								role="bold">and</emphasis></phrase>: 
						  <informaltable> 
								<tgroup cols="4"><colspec colnum="1" colname="col1"
									 colwidth="*"/><colspec colnum="2" colname="col2" colwidth="*"/><colspec
									 colnum="3" colname="col3" colwidth="*"/><colspec colnum="4" colname="col4"
									 colwidth="*"/><thead> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis
														  role="bold">and</emphasis></phrase></entry><entry colname="col2"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col3"><phrase role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry> 
										  </row></thead><tbody> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry><entry colname="col3"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col2"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col3"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">false</emphasis></phrase></entry><entry
												colname="col3"><phrase role="code"><emphasis
														  role="bold">false</emphasis></phrase></entry><entry
												colname="col4"><phrase role="code"><emphasis
														  role="bold">false</emphasis></phrase></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The following table displays the results of evaluating 
						  <phrase role="code"><emphasis
								role="bold">or</emphasis></phrase>: 
						  <informaltable> 
								<tgroup cols="4"><colspec colnum="1" colname="col1"
									 colwidth="*"/><colspec colnum="2" colname="col2" colwidth="*"/><colspec
									 colnum="3" colname="col3" colwidth="*"/><colspec colnum="4" colname="col4"
									 colwidth="*"/><thead> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">or</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry><entry colname="col3"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry> 
										  </row></thead><tbody> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry><entry colname="col3"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col4"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col2"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col3"><phrase role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">nil</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry><entry colname="col3"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col4"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The following table displays the results of evaluating 
						  <phrase role="code"><emphasis
								role="bold">not</emphasis></phrase>: 
						  <informaltable> 
								<tgroup cols="2"><colspec colnum="1"
									 colname="col1"/><colspec colnum="2" colname="col2" colwidth="*"/><thead> 
										  <row><entry
												colname="col1">Argument</entry><entry colname="col2">Result</entry> 
										  </row></thead><tbody> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">true</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">false</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis
														  role="bold">nil</emphasis></phrase></entry><entry colname="col2"><phrase
													 role="code"><emphasis role="bold">nil</emphasis></phrase></entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code"><emphasis role="bold">false</emphasis></phrase></entry><entry
												colname="col2"><phrase role="code"><emphasis
														  role="bold">true</emphasis></phrase></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink url="O-System.IfNil.html" type="olinka">IfNil -
								Nil-Handling Operator</ulink> | 
						  <ulink url="O-System.IsNil.html" type="olinka">IsNil -
								Nil-Handling Operator</ulink></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-OperatorPrecedence"> 
					 <title><indexterm><primary>Operator
									 Precedence</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Operator
									 Precedence</secondary></indexterm><indexterm><primary><phrase
									 role="code">()</phrase> (Operator Precedence)</primary></indexterm>Operator
						  Precedence</title> 
					 <para>Because many of the built-in operators in D4 are in-fix
						  or post-fix operators, operator precedence must be used to determine the order
						  of operations. Operators with a higher precedence will take arguments before
						  operators with a lower precedence. For example, the expression 
						  <phrase role="code">2 + 2 * 4</phrase> is evaluated as 
						  <phrase role="code">2 + (2 * 4)</phrase> because
						  multiplication has a higher precedence than addition. Operators with the same
						  precedence are left-associative, except for exponentiation, which is
						  right-associative. For example, the expression 
						  <phrase role="code">2 ** 3 ** 2</phrase> is evaluated as 
						  <phrase role="code">2 ** (3 ** 2)</phrase>, but 
						  <phrase role="code">100 / 2 / 10</phrase> is evaluated as 
						  <phrase role="code">(100 / 2) / 10</phrase>. Order of
						  operation and associativity in an expression can always be forced using
						  parentheses (<phrase role="code">(</phrase> and 
						  <phrase role="code">)</phrase>).</para> 
					 <para> The following table lists the built-in operators of D4
						  in order of precedence from highest to lowest: 
						  <informaltable> 
								<tgroup cols="2">
									 <colspec colwidth="*" colname="col1" colnum="1"/>
									 <colspec colwidth="*" colname="col2" colnum="2"/> 
									 <thead> 
										  <row> 
												<entry colname="col1">Operator(s)</entry> 
												<entry colname="col2">Description</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry colname="col1"><phrase role="code">.
														  []</phrase></entry> 
												<entry colname="col2">Qualifier or
													 Indexer</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase role="code">~
														  +</phrase>(unary) 
													 <phrase role="code">-</phrase>(unary) 
													 <phrase role="code"><emphasis
														  role="bold">not exists</emphasis></phrase></entry> 
												<entry colname="col2">Unary</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code">**</phrase> </entry> 
												<entry
												 colname="col2">Exponentiation</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase role="code">*
														  / <emphasis role="bold">div mod</emphasis></phrase></entry> 
												<entry
												 colname="col2">Multiplicative</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase role="code">+
														  -</phrase> </entry> 
												<entry colname="col2">Additive</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase role="code">=
														  &lt;&gt; &lt; &gt; &lt;= &gt;= ?=</phrase> </entry> 
												<entry colname="col2">Comparison</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase role="code">^
														  &amp; | &lt;&lt; &gt;&gt;</phrase> </entry> 
												<entry colname="col2">Bitwise
													 Binary</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code"><emphasis role="bold">and</emphasis></phrase> </entry> 
												<entry colname="col2">Logical And</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code"><emphasis role="bold">in or xor like matches between is
														  as</emphasis></phrase></entry> 
												<entry colname="col2">Logical Binary or
													 Ternary or Type Operator</entry> 
										  </row> 
										  <row> 
												<entry colname="col1"><phrase
													 role="code"><emphasis role="bold">where over remove add rename {} group return
														  explode adorn redefine union minus intersect join times having
														  without</emphasis></phrase></entry> 
												<entry colname="col2">Relational</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-LanguageModifiers"> 
					 <title><indexterm><primary>Language
									 Modifiers</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Language
									 Modifiers</secondary></indexterm>Language Modifiers</title> 
					 <para>Language modifiers in D4 allow for developer input to the
						  compilation process. They are basically compile-time arguments to the statement
						  or expression on which they appear. The following table describes the available
						  modifiers and the contexts in which they are available: 
						  <informaltable> 
								<tgroup cols="3"><colspec colnum="1" colname="col1"
									 colwidth=".75*"/><colspec colnum="2" colname="col2" colwidth=".75*"/><colspec
									 colnum="3" colname="col3" colwidth="*"/><thead> 
										  <row><entry
												colname="col1">Modifier</entry><entry colname="col2">Context</entry><entry
												colname="col3">Description</entry> 
										  </row></thead><tbody> 
										  <row><entry colname="col1"><phrase
													 role="code">ShouldSupport</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Indicates whether or not the Dataphor
													 Server should attempt to provide support for the expression on any
													 device.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IgnoreUnsupported</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Indicates that the compiler should
													 suppress warnings that the given expression is unsupported on any
													 device.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsLiteral</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Overrides the literal characteristic
													 inferred by the compiler.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsFunctional</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Overrides the functional characteristic
													 inferred by the compiler.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsDeterministic</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Overrides the deterministic
													 characteristic inferred by the compiler.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsRepeatable</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Overrides the repeatable characteristic
													 inferred by the compiler.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsNilable</phrase></entry><entry colname="col2">Any
													 expression</entry><entry colname="col3">Overrides the nilable characteristic
													 inferred by the compiler.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">ShouldCheckConcurrency</phrase></entry><entry colname="col2">Any
													 table-valued expression</entry><entry colname="col3">Indicates whether the
													 query processor should check concurrency at this level. Note that this is only
													 a switch for use in turning off a concurrency check. It cannot force a
													 concurrency check where the compiler has decided that one is not necessary due
													 to isolation levels and other factors.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">[(Left | Right).]ShouldTranslate</phrase></entry><entry
												colname="col2">Any table-valued expression</entry><entry
												colname="col3">Indicates whether or not the expression should be translated
													 into an application transaction context.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">[(Left | Right).]Propagate(Insert | Update |
														  Delete)</phrase></entry><entry colname="col2">Any table-valued
													 expression</entry><entry colname="col3">Indicates whether or not the specified
													 modification (<phrase role="code">Insert</phrase>, 
													 <phrase role="code">Update</phrase>, or
													 
													 <phrase role="code">Delete</phrase>)
													 should be propagated. These modifiers can be used to control view update
													 semantics.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">[(Left | Right).]Propagate(Default | Validate |
														  Change)</phrase></entry><entry colname="col2">Any table-valued
													 expression</entry><entry colname="col3">Indicates whether or not the specified
													 propsable (<phrase role="code">Default</phrase>, 
													 <phrase role="code">Validate</phrase>,
													 or 
													 <phrase role="code">Change</phrase>)
													 should be propagated. These modifiers can be used to control view proposable
													 semantics.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">EnforcePredicate</phrase></entry><entry colname="col2">Any 
													 <phrase role="code">where</phrase>, 
													 <phrase role="code">minus</phrase>, 
													 <phrase role="code">union</phrase>, 
													 <phrase role="code">return</phrase>, or
													 
													 <phrase role="code">join</phrase>
													 expression.</entry><entry colname="col3">Indicates whether the predicate of the
													 resulting view should be enforced for data modifications.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">IsTimes</phrase></entry><entry colname="col2">Any natural 
													 <phrase
													  role="code">join</phrase></entry><entry colname="col3">Indicates that the
													 natural join is intended to be performed without common columns and suppresses
													 the warning that the compiler would otherwise give.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">Retrieve(Left | Right)</phrase></entry><entry colname="col2">Any 
													 <phrase role="code">join</phrase>,
													 natural or conditioned, inner or outer</entry><entry colname="col3">Indicates
													 whether a change to the left join key columns should cause the right side to be
													 retrieved, and vice versa.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">Clear(Left | Right)</phrase></entry><entry colname="col2">Any 
													 <phrase role="code">join</phrase>,
													 natural or conditioned, inner or outer</entry><entry colname="col3">Indicates
													 whether the absence of a row in the database corresponding to the new values
													 for the left join key columns should clear the right side of the join, and vice
													 versa.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">Coordinate(Left | Right)</phrase></entry><entry colname="col2">Any 
													 <phrase role="code">join</phrase>,
													 natural or conditioned, inner or outer</entry><entry colname="col3">Indicates
													 whether a change in the left join key columns should set the values for the
													 right join key columns, and vice versa.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">UpdateLeftToRight</phrase></entry><entry colname="col2">Any 
													 <phrase role="code">join</phrase>,
													 natural or conditioned, inner or outer</entry><entry colname="col3">Indicates
													 whether a data modification should be performed on the left side first. By
													 default, this is determined based on the cardinality of the join.</entry> 
										  </row> 
										  <row><entry colname="col1"><phrase
													 role="code">(Any | All)Of</phrase></entry><entry colname="col2">Any outer 
													 <phrase role="code">join</phrase>,
													 natural or conditioned</entry><entry colname="col3">Determines what columns in
													 the outer side of the join constitute the existence of a row in that side. Row
													 existence is defined as having a value for any column in the 
													 <phrase role="code">AnyOf</phrase>
													 modifier, and all columns in the 
													 <phrase role="code">AllOf</phrase>
													 modifier, if specified. By default, the 
													 <phrase role="code">AnyOf</phrase>
													 modifier is set to all non-join-key columns in the outer side, and the 
													 <phrase role="code">AllOf</phrase>
													 modifier is empty.</entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The syntax for language modifiers in D4 is: 
						  <programlisting>&lt;language modifiers&gt; ::=
 <emphasis role="bold">with</emphasis> "{"&lt;ne language modifier commalist&gt;"}"

&lt;language modifier&gt; ::=
	&lt;language modifier name&gt; = &lt;language modifier value&gt;

&lt;language modifier name&gt; ::=
	&lt;qualified identifier&gt;

&lt;language modifier value&gt; ::=
	&lt;string&gt;</programlisting></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-BetweenClause"> 
					 <title><indexterm><primary><phrase role="code"><emphasis
										  role="bold">between</emphasis></phrase></primary></indexterm><indexterm><primary>Expressions</primary><secondary><phrase
									 role="code"><emphasis
										  role="bold">between</emphasis></phrase></secondary></indexterm><indexterm><primary>Comparison
									 Operators</primary><secondary><phrase role="code"><emphasis
										  role="bold">between</emphasis></phrase></secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
									 role="code"><emphasis
										  role="bold">between</emphasis></phrase></secondary></indexterm>Between
						  Clause</title> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">between</emphasis></phrase> operator is a ternary operator which
						  allows a value to be tested against a range of values of the same type. The
						  expression is logically equivalent to inclusive comparisons against the bounds
						  of the range. For example: 
						  <programlisting>A <emphasis role="bold">between</emphasis> B <emphasis role="bold">and</emphasis> C</programlisting>is logically equivalent to: 
						  <programlisting>A &gt;= B <emphasis role="bold">and</emphasis> A &lt;= C</programlisting></para> 
					 <para>The D4 compiler substitutes invocations of the between
						  operator for the equivalent inclusive comparison operator invocations.</para> 
					 <para>The between clause in D4 has the following syntax: 
						  <programlisting>&lt;between clause&gt; ::=
	<emphasis role="bold">between</emphasis> &lt;arithmetic expression&gt; <emphasis role="bold">and</emphasis> &lt;arithmetic expression&gt;</programlisting></para> 
					 <example> 
						  <title>Using Between</title> 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">where</emphasis> Name <emphasis role="bold">between</emphasis> "Je" <emphasis role="bold">and</emphasis> "Jo";</programlisting> 
						  <programlisting>ID Name
-- ----
4  Jeff
6  Jeff
1  Jim</programlisting> 
					 </example> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-TypeOperatorClause"> 
					 <title><indexterm><primary>Type Operator
									 Clause</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Type
									 Operator
									 Clause</secondary></indexterm><indexterm><primary>Casting</primary></indexterm><indexterm><primary>Type
									 Testing</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
										  role="bold">is</emphasis></phrase> - Type Testing
									 Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
									 role="code"><emphasis
										  role="bold">is</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
									 role="code"><emphasis role="bold">as</emphasis></phrase> - Type Casting
									 Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
									 role="code"><emphasis
										  role="bold">as</emphasis></phrase></secondary></indexterm>Type Operator
						  Clause</title> 
					 <para>Type operators allow for run-time type testing to be
						  performed. These operators are system-provided and cannot be overloaded.</para>
					 
					 <para>The type operator clause in D4 has the following syntax: 
						  <programlisting>&lt;type operator clause&gt; ::=
	&lt;type operator&gt; &lt;type specifier&gt;
	
&lt;type operator&gt; ::=
	<emphasis role="bold">is</emphasis> | <emphasis role="bold">as</emphasis></programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">is</emphasis></phrase> operator returns a boolean value indicating
						  whether the given value is of the provided type. If the type of the given value
						  is equal to the provided type the invocation returns true, otherwise it returns
						  false.</para> 
					 <para>The 
						  <phrase role="code"><emphasis
								role="bold">as</emphasis></phrase> operator casts the given value to the
						  provided type. An invocation of 
						  <phrase role="code"><emphasis
								role="bold">as</emphasis></phrase> will fail at run-time if the given value is
						  not of the provided type, i.e. if an invocation of 
						  <phrase role="code"><emphasis
								role="bold">is</emphasis></phrase> would return false. The value returned from
						  an 
						  <phrase role="code"><emphasis
								role="bold">as</emphasis></phrase> invocation is guaranteed to be of the
						  provided type.</para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>
						  production rule see 
						  <ulink url="D4LGLanguageElements-Types.html"
							type="xref">Types</ulink>.</para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-BinaryExpression"> 
					 <title><indexterm><primary>Binary
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Binary
									 Expression</secondary></indexterm>Binary Expression</title> 
					 <para>Binary expressions in D4 have the following syntax: 
						  <programlisting>&lt;binary expression&gt; ::=
	&lt;arithmetic expression&gt; {&lt;binary operator&gt; &lt;arithmetic expression&gt;}

&lt;binary operator&gt; ::=
	<emphasis role="bold">and</emphasis> | <emphasis role="bold">or</emphasis> | <emphasis role="bold">xor</emphasis> | <emphasis role="bold">like</emphasis> | <emphasis role="bold">matches</emphasis> | <emphasis role="bold">in</emphasis>
	^ | &amp; | "|" | "&lt;&lt;" | "&gt;&gt;" |
	= | "&lt;&gt;" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | ?=</programlisting></para> 
					 <para>These operators are system-provided for the system data
						  types where appropriate, but may be overloaded for other types by using the
						  operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">and</emphasis></phrase></entry> 
												<entry><phrase role="code"><ulink
														  url="O-System.iAnd.html" type="olinka">iAnd</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">or</emphasis></phrase></entry><entry><phrase
													 role="code"><ulink url="O-System.iOr.html"
														  type="olinka">iOr</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">xor</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iXor.html" type="olinka">iXor</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">like</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iLike.html" type="olinka">iLike</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">matches</emphasis></phrase></entry><entry><phrase
													 role="code"><ulink url="O-System.iMatches.html"
														  type="olinka">iMatches</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">in</emphasis></phrase></entry><entry><phrase
													 role="code"><ulink url="O-System.iIn.html" type="olinka"><ulink
																url="O-System.iIn.html" type="olinka">iIn</ulink></ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">^</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iBitwiseXor.html"
														  type="olinka">iBitwiseXor</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&amp;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iBitwiseAnd.html"
														  type="olinka">iBitwiseAnd</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">|</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iBitwiseOr.html"
														  type="olinka">iBitwiseOr</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&lt;&lt;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iShiftLeft.html"
														  type="olinka">iShiftLeft</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&gt;&gt;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iShiftRight.html"
														  type="olinka">iShiftRight</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">=</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iEqual.html" type="olinka">iEqual</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&lt;&gt;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iNotEqual.html" type="olinka">iNotEqual</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&lt;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iLess.html" type="olinka">iLess</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&gt;</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iGreater.html" type="olinka">iGreater</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&lt;=</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iInclusiveLess.html"
														  type="olinka">iInclusiveLess</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">&gt;=</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iInclusiveGreater.html"
														  type="olinka">iInclusiveGreater</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">?=</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iCompare.html" type="olinka">iCompare</ulink></phrase></entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para><indexterm><primary>Comparison
									 Operators</primary><secondary>Resolution</secondary></indexterm>For the
						  comparison operators (<phrase role="code">=</phrase>, 
						  <phrase role="code">&lt;&gt;</phrase>, 
						  <phrase role="code">&lt;</phrase>, 
						  <phrase role="code">&gt;</phrase>, 
						  <phrase role="code">&lt;=</phrase>, 
						  <phrase role="code">&gt;=</phrase>, and 
						  <phrase role="code">?=</phrase>) the compiler will attempt
						  to resolve the operators as closely as possible. All types must have an equal
						  comparison defined. From this, the compiler can provide a not equal comparison
						  operator using the logical not. In addition to the equal operator, if a less
						  operator is provided, the compiler can provide the rest of the comparison
						  operators. </para> 
					 <para>The 
						  <phrase id="O-System.iCompare.html"
							role="code">iCompare</phrase> operator (<phrase role="code">?=</phrase>) is
						  shorthand for a compare operation defined to be equivalent to a conditional
						  expression: 
						  <programlisting>A ?= B</programlisting>is logically equivalent to: 
						  <programlisting><emphasis role="bold">if</emphasis> A = B <emphasis role="bold">then</emphasis> 0 <emphasis role="bold">else</emphasis> <emphasis role="bold">if</emphasis> A &lt; B <emphasis role="bold">then</emphasis> -1 <emphasis role="bold">else</emphasis> 1</programlisting></para> 
					 <para>If a given type only has a compare operator defined, the
						  compiler will provide equivalent formulations of the rest of the comparison
						  operators using invocations of the compare operator.</para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-ArithmeticExpression"> 
					 <title><indexterm><primary>Arithmetic
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Arithmetic
									 Expression</secondary></indexterm>Arithmetic Expression</title> 
					 <para>Arithmetic expressions in D4 have the following syntax: 
						  <programlisting>&lt;arithmetic expression&gt; ::=
	&lt;unary expression&gt; {&lt;arithmetic operator&gt; &lt;unary expression&gt;}

&lt;arithmetic operator&gt; ::=
	+ | - | * | / | <emphasis role="bold">div</emphasis> | <emphasis role="bold">mod</emphasis> | **</programlisting></para> 
					 <para>These operators are system-provided for the system data
						  types where appropriate, but may be overloaded for other types by using the
						  operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><phrase
													 role="code">+</phrase></entry> 
												<entry><phrase role="code"><ulink
														  url="O-System.iAddition.html" type="olinka">iAddition</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">-</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iSubtraction.html"
														  type="olinka">iSubtraction</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">*</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iMultiplication.html"
														  type="olinka">iMultiplication</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">/</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iDivision.html" type="olinka">iDivision</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">div</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iDiv.html" type="olinka">iDiv</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">mod</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iMod.html" type="olinka">iMod</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">**</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iPower.html" type="olinka">iPower</ulink></phrase></entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-UnaryExpression"> 
					 <title><indexterm><primary>Unary
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Unary
									 Expression</secondary></indexterm>Unary Expression</title> 
					 <para>Unary expressions in D4 have the following syntax: 
						  <programlisting>&lt;unary expression&gt; ::=
	{&lt;unary operator&gt;} &lt;qualified factor&gt;
	
&lt;unary operator&gt; ::=
	+ | - | ~ | <emphasis role="bold">not</emphasis> | <emphasis role="bold">exists</emphasis></programlisting></para> 
					 <para>These operators (except for unary plus (<phrase
						  role="code">+</phrase>) which is eliminated by the parser) are system-provided
						  for the system data types where appropriate, but may be overloaded for other
						  types by using the operator name given by the following table: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Symbol</entry><entry>Operator
													 Name</entry> 
										  </row></thead><tbody> 
										  <row><entry><phrase
													 role="code">-</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iNegate.html" type="olinka">iNegate</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">~</phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iBitwiseNot.html"
														  type="olinka">iBitwiseNot</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">not</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iNot.html" type="olinka">iNot</ulink></phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><emphasis
														  role="bold">exists</emphasis></phrase></entry><entry><phrase role="code"><ulink
														  url="O-System.iExists.html" type="olinka">iExists</ulink></phrase></entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-QualifierExpression"> 
					 <title><indexterm><primary>Qualified
									 Factor</primary></indexterm><indexterm><primary>Qualifier
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Qualifier
									 Expression</secondary></indexterm><indexterm><primary>Namespace
									 Qualifier</primary></indexterm><indexterm><primary>Dot
									 Invocation</primary></indexterm><indexterm><primary>Property
									 Accessor</primary></indexterm><indexterm><primary>Column
									 Extractor</primary></indexterm><indexterm><primary>Method-Style
									 Invocation</primary><secondary>Syntax</secondary></indexterm><indexterm><primary><phrase
									 role="code">.</phrase> -
									 Qualifier</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
									 role="code">.</phrase> -
									 Qualifier</secondary></indexterm><indexterm><primary>Extractor
									 Operators</primary><secondary><phrase role="code">.</phrase> - Column
									 Extractor</secondary></indexterm>Qualifier Expression</title> 
					 <para>Qualifier expressions in D4 have the following syntax: 
						  <programlisting>&lt;qualified factor&gt; ::=
	&lt;factor&gt;{(.&lt;qualifier expression&gt;) | &lt;indexer expression&gt;}

&lt;qualifier expression&gt; ::=
	&lt;identifier&gt;["("&lt;actual parameter commalist&gt;")"][.&lt;qualifier expression&gt;]
</programlisting></para> 
					 <para>The qualifier operator in D4 is a system-provided
						  operator and cannot be overloaded. It serves the following functions: 
						  <itemizedlist> 
								<listitem> 
									 <para>Namespace qualifier</para> 
								</listitem> 
								<listitem> 
									 <para>Property accessor</para> 
								</listitem> 
								<listitem> 
									 <para>Operator invocation</para> 
								</listitem> 
								<listitem> 
									 <para>Column Extractor</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>For a description of how the qualifier behaves for the
						  purposes of namespace resolution, refer to 
						  <ulink url="D4LGLexicalElements-Identifiers.html"
							type="xref">Identifiers</ulink>.</para> 
					 <para>If the target of the qualifier is a scalar-valued
						  expression, the qualifier can be used to access the properties of any logical
						  representation of that type. This type of property access can be an expression
						  or an assignment target, depending on which side of an assignment statement it
						  appears. For a complete description of logical representations and property
						  accessors, refer to 
						  <ulink url="D4LGCatalogElements-ScalarTypes.html"
							type="xref">Scalar Types</ulink>.</para> 
					 <sect3> 
						  <title>Dot Invocation</title> 
						  <para>If the qualifier is an unresolved operator
								invocation, the compiler will attempt to resolve the invocation again, passing
								the qualifier target as the first argument of the invocation. If this
								resolution fails, the compiler will attempt to resolve the invocation with the
								qualifier target as a 
								<phrase role="code"><emphasis
									 role="bold">var</emphasis></phrase> argument. In this way, the qualifier
								enables object-oriented style "method" invocation.</para> 
						  <example> 
								<title>Using Dot Invocation</title> 
								<programlisting>// Standard invocation
Length(LString);
Length(ServerSettings[].Name);
Length("Alphora");
Length(ToString(DateTime()));

// Dot invocation
LString.Length();
ServerSettings[].Name.Length();
"Alphora".Length();
DateTime().ToString().Length();</programlisting> 
						  </example> 
					 </sect3> 
					 <sect3> 
						  <title>Column Extractor</title> 
						  <para>If the target of the qualifier is a row-valued
								expression, the qualifier can be used to access the values of any column of the
								row.</para> 
						  <example> 
								<title>Using the Column Extractor</title> 
								<programlisting><emphasis role="bold">select</emphasis> <emphasis role="bold">row</emphasis> { "Alphora" Company, "Dataphor" Product }.Company;

<emphasis role="bold">create table</emphasis> Contact
{
 Name : String,
 Phone : String,
 <emphasis role="bold">key</emphasis> { Name }
};

<emphasis role="bold">begin</emphasis>
 <emphasis role="bold">var</emphasis> LRow := <emphasis role="bold">row</emphasis> { "Bob" Name, "555-2222" Phone };
 Contact := <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { LRow.Name Name, "123-" + LRow.Phone Phone } };
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">select</emphasis> Contact;

<emphasis role="bold">drop table</emphasis> Contact;</programlisting> 
								<programlisting>Alphora

Name Phone
---- ------------
Bob  123-555-2222</programlisting> 
						  </example> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-IndexerExpression"> 
					 <title><indexterm><primary>Indexer
									 Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Indexer
									 Expression</secondary></indexterm><indexterm><primary>Table-Indexer</primary></indexterm><indexterm><primary>Row
									 Extractor</primary></indexterm><indexterm><primary>Table
									 Operators</primary><secondary><phrase role="code">[]</phrase>
									 (Table-Indexer)</secondary></indexterm><indexterm><primary><phrase
									 role="code">[]</phrase> (Indexer)
									 (Syntax)</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
									 role="code">[]</phrase> (Indexer)
									 (Syntax)</secondary></indexterm><indexterm><primary>Extractor
									 Operators</primary><secondary><phrase role="code">[]</phrase> (Indexer)
									 (Syntax)</secondary></indexterm>Indexer Expression</title> 
					 <para>Indexer expressions in D4 have the following syntax: 
						  <programlisting>&lt;indexer expression&gt; ::=
	"["&lt;expression term commalist&gt; [by "{"&lt;column name commalist&gt;"}"]"]"

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>Indexer expressions provide a mechanism for array-style
						  access. The 
						  <ulink url="O-System.iIndexer.html"
							type="olinka"><symbol>System.iIndexer</symbol></ulink> operator is overloaded
						  for tables, lists, and strings, but may be overloaded for other types using the
						  operator name 
						  <phrase role="code">iIndexer</phrase>.</para> 
					 <para>For table-valued expressions, this operator is known as a
						  <emphasis>table-indexer</emphasis>, and is the only context in which the
						  optional by clause is valid. A table-indexer provides the ability to extract a
						  specified row from a table-valued expression, based on the given index terms.
						  If the by clause is not specified, the index terms will be used to resolve a
						  key based on the number and type of the index terms. The compiler uses the same
						  process as operator overload resolution to resolve the key. In other words, the
						  compiler will attempt to resolve to the key that can be reached with the least
						  narrowing, shortest conversion path from the index terms.</para> 
					 <para>Note that the compiler will try all permutations of the
						  given index terms when attempting to resolve a key in a table-indexer. This
						  process removes any dependence on the order of terms in the table-indexer, but
						  is potentially expensive for large numbers of terms. For this reason, the
						  compiler requires a by clause for table-indexers with more than 5 terms.</para>
					 
					 <para>When a by clause is specified, the index terms will be
						  matched to the columns in the by clause in the order they appear in the
						  table-indexer.</para> 
					 <para>If the by clause is specified, but the columns do not
						  form a superset of some key of the source expression, the compiler will issue a
						  warning stating that the expression may return multiple rows at run-time. Note
						  that the empty table-indexer (<phrase role="code">[]</phrase>) is valid, and
						  results in a "pure" row extractor.</para> 
					 <para>The source expression for a table-indexer is required to
						  have at most one row. If the expression evaluates to a table with more than one
						  row, an error will be thrown at run-time. If the compiler detects that the
						  expression could return more than one row, a warning will be issued. If the
						  source expression does not return any rows, the result of the table-indexer
						  will be 
						  <phrase role="code"><emphasis
								role="bold">nil</emphasis></phrase>. Note that a subsequent column extractor on
						  this result will also evaluate to nil.</para> 
					 <para>The following listing provides several examples of the
						  table-indexer expression: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable : <emphasis role="bold">table</emphasis> { ID : Integer } := <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 1 ID } };
	<emphasis role="bold">var</emphasis> LRow : <emphasis role="bold">row</emphasis> { ID : Integer } := LTable[];
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { 2 ID } } <emphasis role="bold">into</emphasis> LTable;
	// the next statement is an error because the row to be extracted cannot be determined
	LRow := LTable[]; 
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The following example returns the 
						  <phrase role="code">HostName</phrase> for the current
						  session: 
						  <programlisting><emphasis role="bold">select</emphasis> Sessions[SessionID()].HostName;</programlisting></para> 
					 <para>The same expression using the optional by clause: 
						  <programlisting><emphasis role="bold">select</emphasis> Sessions[SessionID() <emphasis role="bold">by</emphasis> { ID }].HostName;</programlisting></para> 
					 <para>See 
						  <ulink url="O-System.iIndexer.html"
							type="olinka"><symbol>System.iIndexer</symbol></ulink> for information and
						  examples of the use of an indexer with strings and lists.</para> 
				</sect2> 
				<sect2 id="D4LGLanguageElements-Expressions-Factor"> 
					 <title><indexterm><primary>Factor</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Factor</secondary></indexterm>Factor</title>
					 
					 <para>Factors in D4 have the following syntax: 
						  <programlisting>&lt;factor&gt; ::=
	("("&lt;expression&gt;")") |
	&lt;parser literal&gt; |
	&lt;identifier&gt; |
	&lt;operator invocation&gt; |
	&lt;selector&gt; |
	(<emphasis role="bold">parent</emphasis> &lt;qualified identifier&gt;) |
	&lt;conditional expression&gt;</programlisting></para> 
					 <sect3 id="D4LGOperatorInvocation"> 
						  <title><indexterm><primary>Operator Invocation
										  (Syntax)</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Operator
										  Invocation</secondary></indexterm><indexterm><primary><phrase
										  role="code">()</phrase> - Operator
										  Invocation</primary></indexterm><indexterm><primary>Operator
										  Signature</primary></indexterm><indexterm><primary>Aggregate Column
										  Specifier</primary></indexterm><indexterm><primary><phrase
										  role="code"><emphasis
												role="bold">from</emphasis></phrase></primary><secondary>Scalar Aggregate
										  Operator Invocation</secondary></indexterm>Operator Invocation</title> 
						  <para>Operator invocation in D4 uses parentheses to delimit
								the argument list, and commas to separate arguments within the list. The
								arguments in a given call expression must appear in the order they are defined
								in the operator definition for the operator being invoked. The operator name,
								together with the names of the types for the arguments in the order they are
								defined, is known as the <emphasis>operator signature</emphasis> and is used by
								the compiler to perform operator resolution. The operator most closely matching
								the call signature is used.</para> 
						  <para>Each 
								<ulink url="D4LGCatalogElements-Operators.html"
								 type="link">operand</ulink> in the signature of an operator has an associated
								modifier. If this modifier is 
								<phrase role="code"><emphasis
									 role="bold">var</emphasis></phrase>, the call must use the 
								<phrase role="code"><emphasis
									 role="bold">var</emphasis></phrase> keyword to pass the argument in the
								invocation. This helps to ensure that operator invocations which can have side
								effects are clearly marked in the invocation.</para> 
						  <para>For stand alone aggregate operator invocations, the 
								<phrase
								 role="code">&lt;aggregate&nbsp;actual&nbsp;parameter&gt;</phrase> is used to
								specify the target column, or columns, of the invocation. In addition, the
								syntax provides for the possibility of order-dependent aggregate operator
								invocations. For a complete description of aggregate operators, refer to the 
								<ulink
								 url="D4LGCatalogElements-Operators-AggregateOperators.html"
								 type="xref">Aggregate Operators</ulink> discussion in this guide.</para> 
						  <para>Operator invocations in D4 have the following syntax:
								
								<programlisting>&lt;operator invocation&gt; ::=
	&lt;identifier&gt;"("&lt;actual parameter commalist&gt;")"

&lt;actual parameter&gt; ::=
	&lt;modified actual parameter&gt; | &lt;aggregate actual parameter&gt;

&lt;modified actual parameter&gt; ::=
	[<emphasis role="bold">var</emphasis>] &lt;expression&gt;

&lt;aggregate actual parameter&gt; ::=
	(&lt;column name&gt; | ("{"&lt;column name commalist&gt;"}")) 
		<emphasis role="bold">from</emphasis>
		&lt;expression&gt;
		[<emphasis role="bold">order by</emphasis> "{"&lt;order column definition commalist&gt;"}"]</programlisting></para> 
					 </sect3> 
					 <sect3 id="D4LGConditionalExpression"> 
						  <title><indexterm><primary>Conditional
										  Expression</primary></indexterm><indexterm><primary>Expressions</primary><secondary>Conditional
										  Expression</secondary></indexterm><indexterm><primary>If
										  Expression</primary></indexterm><indexterm><primary>Case
										  Expression</primary></indexterm>Conditional Expression</title> 
						  <para>Conditional expressions are a kind of inline function
								in that they are equivalent to writing an operator that uses branching.</para> 
						  <para>There are two types of conditional expressions in D4,
								the <emphasis><ulink url="D4LGIfStatement.html" type="link">if</ulink>
								expression</emphasis> and the <emphasis><ulink url="D4LGCaseStatement.html"
								type="link">case</ulink> expression</emphasis>.</para> 
						  <para>These operators are system-provided and cannot be
								overloaded.</para> 
						  <para>Conditional expressions in D4 have the following
								syntax: 
								<programlisting>&lt;conditional expression&gt; ::=
	&lt;if expression&gt; |
	&lt;case expression&gt;

&lt;if expression&gt; ::=
	<emphasis role="bold">if</emphasis> &lt;expression term&gt; <emphasis role="bold">then</emphasis> &lt;expression term&gt; <emphasis role="bold">else</emphasis> &lt;expression term&gt;

&lt;case expression&gt; ::=
	<emphasis role="bold">case</emphasis> [&lt;expression&gt;]
		&lt;ne case expression item list&gt;
		<emphasis role="bold">else</emphasis> &lt;expression&gt;
	<emphasis role="bold">end</emphasis>
    
&lt;case expression item&gt; ::=
	<emphasis role="bold">when</emphasis> &lt;expression&gt; <emphasis role="bold">then</emphasis> &lt;expression&gt;</programlisting></para> 
						  <para>If the condition evaluates to true, the result of the
								if expression is the result of evaluating the first expression. If the
								condition evaluates to false or nil, the result of the if expression is the
								result of evaluating the second expression. Note that both expressions are
								required to return values of compatible types.</para> 
						  <para>Case expressions are shorthand for iterated if
								expressions. There are two flavors of the case expression, one in which a
								single expression is used as the comparison target for each case item, and one
								in which no comparison target is given, rather each case item condition is a
								boolean comparison in itself. In both versions of the expression, the final
								unsatisfied condition is given by the else expression, and the results of all
								case items and the else expression must return values of compatible
								types.</para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink url="D4LGCaseStatement.html" type="xref">case
									 statement</ulink> | 
								<ulink url="D4LGIfStatement.html" type="xref">if
									 statement</ulink> | 
								<ulink
								 url="D4LGLanguageElements-Expressions.html">Expressions</ulink></para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGCatalogElements"> 
		  <title><indexterm><primary>Catalog</primary></indexterm><indexterm><primary>Data
						  Dictionary</primary></indexterm>Catalog Elements</title> 
		  <para>The Catalog is the repository of globally scoped objects within
				the Dataphor Server. It contains the tables, views, business rules (<ulink
				url="D4LGCatalogElements-Constraints.html" type="link">constraints</ulink>) and
				other items that constitute the database schema. The Catalog is also called the
				the Data Dictionary. The Dataphor Server uses the Catalog to describe the
				application schema which represents the core of the database
				application.</para> 
		  <para>Catalog objects are partitioned into logical groups called
				<emphasis><ulink url="D4LGCatalogElements-Libraries.html"
				type="link">Libraries</ulink></emphasis>. These libraries function as a
				deployment and dependency tracking unit for Dataphor applications. All objects
				in the catalog belong to a library. For a complete disucssion of libraries,
				refer to the 
				<ulink url="DDGWorkingWithLibraries.html"
				 type="olinka"><citetitle>Working With Libraries</citetitle></ulink> chapter in
				the Logical Application Design part of this guide.</para> 
		  <para><indexterm><primary>Session-Specific
						  Objects</primary></indexterm><indexterm><primary>Objects</primary><secondary>Session-Specific</secondary></indexterm>The
				D4 language also supports the declaration of session-specific objects. These
				objects are visible only within the session in which they are created, and are
				implicitly dropped when the session is disconnected. A session-specific object
				with the same name as a catalog object will effectively hide the catalog object
				within that session. Session-specific objects are allowed to reference objects
				in the global catalog, but objects in the global catalog cannot reference
				session-specific objects. Operators, tables, views, references, and constraints
				can all be session-specific. Refer to the section for each of these types of
				objects for information on how to create and manage session-specific
				objects.</para> 
		  <para>Each type of catalog object has associated declarative syntax for
				creating, altering, or dropping objects in the catalog. Data definition
				language statements in D4 have the following syntax: 
				<programlisting>&lt;ddl statement&gt; ::=
	&lt;create statement&gt; |
	&lt;alter statement&gt; |
	&lt;drop statement&gt; |
	&lt;attach statement&gt; |
	&lt;invoke statement&gt; |
	&lt;detach statement&gt; |
 &lt;grant statement&gt; |
 &lt;revoke statement&gt; |
	&lt;revert statement&gt;

&lt;create statement&gt; ::=
	&lt;create table statement&gt; |
	&lt;create view statement&gt; |
	&lt;create constraint statement&gt; |
	&lt;create reference statement&gt; |
	&lt;create scalar type statement&gt; |
	&lt;create operator statement&gt; |
	&lt;create aggregate operator statement&gt; |
	&lt;create device statement&gt; |
	&lt;create sort statement&gt; |
	&lt;create conversion statement&gt; |
	&lt;create role statement&gt; |
	&lt;create right statement&gt;

&lt;alter statement&gt; ::=
	&lt;alter table statement&gt; |
	&lt;alter view statement&gt; |
	&lt;alter constraint statement&gt; |
	&lt;alter reference statement&gt; |
	&lt;alter scalar type statement&gt; |
	&lt;alter operator statement&gt; |
	&lt;alter aggregate operator statement&gt; |
	&lt;alter device statement&gt; |
	&lt;alter sort statement&gt; |
	&lt;alter role statement&gt;

&lt;drop statement&gt; ::=
	&lt;drop table statement&gt; |
	&lt;drop view statement&gt; |
	&lt;drop constraint statement&gt; |
	&lt;drop reference statement&gt; |
	&lt;drop scalar type statement&gt; |
	&lt;drop operator statement&gt; |
	&lt;drop aggregate operator statement&gt; |
	&lt;drop device statement&gt; |
	&lt;drop sort statement&gt; |
	&lt;drop conversion statement&gt; |
	&lt;drop role statement&gt; |
	&lt;drop right statement&gt;</programlisting></para> 
		  <para>See the topics for each type of catalog object for a complete
				description of the syntax for each DDL statement.</para> 
		  <para>For a complete description of the attach, invoke, and detach
				statements, see 
				<ulink url="D4LGCatalogElements-EventHandlers.html"
				 type="xref">Event Handlers</ulink>.</para> 
		  <para>For a complete description of the grant, revoke, and revert
				statements, see 
				<ulink url="D4LGCatalogElements-Security.html"
				 type="xref">Security</ulink>.</para> 
		  <sect1 id="D4LGCatalogElements-Objects"> 
				<title><indexterm><primary>Objects</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Objects</secondary></indexterm>Objects</title> 
				<para>All catalog objects have certain properties in common. The
					 following list summarizes these common properties: 
					 <itemizedlist> 
						  <listitem> 
								<para>ID</para> 
								<para>Each object has an associated ID of type 
									 <phrase role="code">System.Integer</phrase>. This
									 is a unique identifier assigned by the Dataphor Server which serves to identify
									 the object.</para> 
						  </listitem> 
						  <listitem> 
								<para>Name</para> 
								<para>Each object has an associated Name which serves
									 as the user visible name of the object.</para> 
						  </listitem> 
						  <listitem> 
								<para>Dependencies</para> 
								<para>The dependencies and dependents of each object
									 are stored in the catalog, and used to ensure the validity of DDL
									 statements.</para> 
						  </listitem> 
						  <listitem> 
								<para>Security</para> 
								<para>Each object is owned by some user, and has an
									 associated set of rights.</para> 
						  </listitem> 
						  <listitem> 
								<para>Metadata</para> 
								<para>Each object has associated metadata which is used
									 to store extra information about the object that does not pertain to the
									 logical model, but to some other application such as a frontend client.</para> 
						  </listitem> 
						  <listitem> 
								<para>Characteristics</para> 
								<para>Each object has associated characteristics such
									 as whether or not the object is a system object, and so on. These
									 characteristics are set by the system and cannot be changed.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<sect2 id="D4LGCatalogElements-Objects-Dependencies"> 
					 <title><indexterm><primary>Dependencies</primary></indexterm><indexterm><primary>Objects</primary><secondary>Dependencies</secondary></indexterm>Dependencies</title>
					 
					 <para>The catalog tracks not only the objects, but the
						  dependencies between the objects. For example, the 
						  <phrase role="code">ID</phrase> column in the 
						  <phrase role="code">Employee</phrase> table is defined in
						  terms of the 
						  <phrase role="code">EmployeeID</phrase> type, so the type
						  is a <emphasis>dependency</emphasis>, or requirement, of the table. Conversely,
						  the table is a <emphasis>dependent</emphasis> of the type. Dependency tracking
						  is used to ensure the consistency of the catalog. If a given object has
						  dependents, it cannot be dropped without first dropping the dependents.
						  Additionally, objects within libraries are only allowed to reference objects
						  within the same library, or a required library.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-Objects-Security"> 
					 <title><indexterm><primary>Security</primary> 
								<secondary>Catalog
									 Objects</secondary></indexterm><indexterm><primary>Objects</primary><secondary>Security</secondary></indexterm>Security</title>
					 
					 <para>Whenever a catalog object is created, the rights
						  necessary to protect operations on that object are also created. For example,
						  creating a table creates 
						  <phrase role="code">Select</phrase>, 
						  <phrase role="code">Insert</phrase>, 
						  <phrase role="code">Update</phrase>, and 
						  <phrase role="code">Delete</phrase> rights for the table,
						  as well as 
						  <phrase role="code">Alter</phrase> and 
						  <phrase role="code">Drop</phrase> rights. The following
						  table lists the rights created for each type of catalog object: 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Catalog Object</entry><entry>Rights
													 Created</entry> 
										  </row></thead><tbody> 
										  <row><entry><phrase role="code">Scalar
														  Type</phrase></entry> 
												<entry><phrase role="code">Alter,
														  Drop</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">Operator</phrase></entry><entry><phrase role="code">Alter, Drop,
														  Execute</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code">Table</phrase>
													 or 
													 <phrase
													  role="code">View</phrase></entry><entry><phrase role="code">Alter, Drop,
														  Select, Insert, Update, Delete</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">Device</phrase></entry><entry><phrase role="code">Alter, Drop,
														  Read, Write, CreateStore, AlterStore, DropStore, Reconcile,
														  MaintainUsers</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">Constraint</phrase></entry><entry><phrase role="code">Alter,
														  Drop</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">Reference</phrase></entry><entry><phrase role="code">Alter,
														  Drop</phrase></entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The created right is named by concatenating the name of
						  the object with the name of the right. For example, a table name 
						  <phrase role="code">Employee</phrase> will have a right
						  named 
						  <phrase role="code">EmployeeSelect</phrase>.</para> 
					 <indexterm><primary>Owner</primary></indexterm> 
					 <para>Each catalog object also has an
						  <emphasis>owner</emphasis>, or the user that is responsible for the object.
						  Initially, the owner is the user that created the object, but ownership can be
						  changed with the 
						  <phrase role="code"><ulink
								url="O-System.SetObjectOwner.html"
								type="olinka">SetObjectOwner</ulink></phrase> operator. All rights for the
						  object are implicitly granted to the owner of the object. For more information
						  on catalog objects and security, see 
						  <ulink url="DUGP3Security.html"
							type="olinkb">Security</ulink>.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-Objects-Metadata"> 
					 <title><indexterm><primary>Metadata
									 (Syntax)</primary></indexterm><indexterm><primary>Tags
									 (Metadata)</primary></indexterm><indexterm><primary>Objects</primary><secondary>Metadata</secondary></indexterm><indexterm><primary>Alter
									 Metadata (Syntax)</primary></indexterm>Metadata</title> 
					 <para>Each of the objects in the catalog may have metadata
						  associated with it. This metadata is application specific information that is
						  irrelevant to the logical model, expressed as a set of named string
						  values.</para> 
					 <para>There are several kinds of metadata in D4, such
						  as:</para> 
					 <para> 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para> <emphasis role="strong"><ulink
										  url="FTRTagsDescriptions.html" type="olinka">Tags</ulink></emphasis> </para> 
									 <para> Tags are general purpose strings that are
										  identified by a name.</para> 
								</listitem> 
								<listitem> 
									 <para> <emphasis role="strong"><ulink
										  url="D4LGOrders.html" type="link">Orders</ulink></emphasis> </para> 
									 <para> Order information on a table variable (Table
										  or View) is considered metadata because it is ignored within the logical
										  model.</para> 
								</listitem> 
								<listitem> 
									 <para> <emphasis role="strong"><ulink
										  url="D4LGCatalogElements-Objects-ClassDefinitions.html" type="link">Class
												Definitions</ulink></emphasis> </para> 
									 <para> Certain structures within the catalog
										  reference host language (.NET Framework) implemented code. Again, the meaning
										  of these references has no meaning within the logical model.</para> 
								</listitem> 
						  </itemizedlist> </para> 
					 <para>Metadata in D4 has the following syntax: 
						  <programlisting>&lt;metadata&gt; ::=
	[&lt;tags&gt;]
	
&lt;tags&gt; ::=
	[<emphasis role="bold">static</emphasis>] <emphasis role="bold">tags</emphasis> "{"&lt;ne tag definition commalist&gt;"}"
	
&lt;tag definition&gt; ::=
	[<emphasis role="bold">static</emphasis> | <emphasis role="bold">dynamic</emphasis>] &lt;tag name&gt; = &lt;string&gt;
	
&lt;tag name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>Alter metadata in D4 has the following syntax: 
						  <programlisting>&lt;alter metadata&gt; ::=
	[<emphasis role="bold">alter tags</emphasis> "{"&lt;alter tag definition commalist&gt;"}"]
	
&lt;alter tag definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;tag definition&gt;) | (<emphasis role="bold">alter</emphasis> &lt;tag definition&gt;) | (<emphasis role="bold">drop</emphasis> &lt;tag name&gt;)</programlisting></para> 
					 <para>Metadata tags can be specified in most DDL statements. In
						  addition, some operators such as 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Adorn.html"
								type="link">adorn</ulink></emphasis></phrase> allow metadata to be added
						  directly in an expression.</para> 
					 <para>Each metadata tag may be either
						  <emphasis>static</emphasis> or <emphasis>dynamic</emphasis>. Static metadata is
						  associated only with the object on which it is defined. It is not inferred
						  through expressions or inherited by other objects. Dynamic metadata tags are
						  inferred through expressions and passed on to other objects when appropriate.
						  For example, a static tag on a scalar type will not be inherited by a table
						  variable column defined on that type. For a complete description of the
						  metadata tags utilized by the different components of the Dataphor Server,
						  refer to 
						  <ulink url="DRTags.html">Tags</ulink>.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-Objects-ClassDefinitions"> 
					 <title><indexterm><primary>Class
									 Definitions</primary></indexterm><indexterm><primary>Objects</primary><secondary>Class
									 Definitions</secondary></indexterm><indexterm><primary>Attributes</primary></indexterm><indexterm><primary>Alter
									 Class Definition (Syntax)</primary></indexterm>Class Definitions</title> 
					 <para>Class definitions are a specific type of metadata used
						  within the catalog to describe structures in the host implementation.</para> 
					 <para>Class definitions in D4 have the following syntax: 
						  <programlisting>&lt;class definition&gt; ::=
	<emphasis role="bold">class</emphasis> &lt;class name&gt; [&lt;attributes&gt;]

&lt;class name&gt; ::=
	&lt;string&gt;

&lt;attributes&gt; ::=
	<emphasis role="bold">attributes</emphasis> "{"&lt;ne attribute definition commalist&gt;"}"
	
&lt;attribute definition&gt; ::=
	&lt;attribute name&gt; = &lt;attribute value&gt;

&lt;attribute name&gt; ::=
	&lt;string&gt;

&lt;attribute value&gt; ::=
	&lt;string&gt;</programlisting></para> 
					 <para>The 
						  <phrase role="code">&lt;class&nbsp;name&gt;</phrase> is the
						  name of a registered class registered with a library. Each 
						  <phrase role="code">&lt;attribute&nbsp;name&gt;</phrase>
						  corresponds to a property of that class, and the value of the property on the
						  instance of the class constructed will be set to 
						  <phrase
							role="code">&lt;attribute&nbsp;value&gt;</phrase>.</para> 
					 <para>Alter class definitions in D4 have the following syntax: 
						  <programlisting>&lt;alter class definition&gt; ::=
	<emphasis role="bold">alter class</emphasis> [&lt;class name&gt;] ["{"&lt;alter attribute definition commalist&gt;"}"]
	
&lt;alter attribute definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;attribute definition&gt;) | 
	(<emphasis role="bold">alter</emphasis> &lt;attribute definition&gt;) | 
	(<emphasis role="bold">drop</emphasis> &lt;attribute name&gt;)</programlisting></para> 
					 <para>Although altering host-implementation structures is
						  allowed, whether or not the alteration is effective once the internal
						  host-implementation structure has been constructed is determined by the
						  host-implementation structure itself.</para> 
					 <para>These definitions are used throughout DDL statements to
						  specify host implementation structures.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Security"> 
				<title><indexterm><primary>Security</primary><secondary>Catalog
								Elements</secondary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Security</secondary></indexterm><indexterm><primary>Grant
								Statement</primary></indexterm><indexterm><primary>Revoke
								Statement</primary></indexterm><indexterm><primary>Revert
								Statement</primary></indexterm>Security</title> 
				<para>Management of the security model in the Dataphor Server is
					 accomplished using operators in the system library. These operators provide a
					 complete API for creating 
					 <ulink url="DUGP3SecurityPrimitives-Users.html"
					  type="olinka">users</ulink>, managing 
					 <ulink url="DUGP3SecurityPrimitives-Roles.html"
					  type="olinka">roles</ulink>, and granting and revoking 
					 <ulink url="DUGP3SecurityPrimitives-Rights.html"
					  type="olinka">rights</ulink>. As a shorthand, the D4 language includes several
					 statements that provide a shorthand for the rights management portions of this
					 API.</para> 
				<para>The syntax of these statements is as follows: 
					 <programlisting>&lt;grant statement&gt; ::=
	<emphasis role="bold">grant</emphasis> &lt;right specifier&gt;
	[<emphasis role="bold">on</emphasis> &lt;catalog object specifier&gt;]
 <emphasis role="bold">to</emphasis> &lt;security specifier&gt;

&lt;revoke statement&gt; ::=
	<emphasis role="bold">revoke</emphasis> &lt;right specifier&gt; 
	[<emphasis role="bold">on</emphasis> &lt;catalog object specifier&gt;] 
	<emphasis role="bold">from</emphasis> &lt;security specifier&gt;

&lt;revert statement&gt; ::=
	<emphasis role="bold">revert</emphasis> &lt;right specifier&gt; 
	[<emphasis role="bold">on</emphasis> &lt;catalog object specifier&gt;] 
	<emphasis role="bold">for</emphasis> &lt;security specifier&gt;

&lt;right specifier&gt; ::=
	<emphasis role="bold">all</emphasis> | <emphasis role="bold">usage</emphasis> | "{"&lt;right name commalist&gt;"}"

&lt;right name&gt; ::=
	&lt;qualified identifier&gt;

&lt;catalog object specifier&gt; ::=
	&lt;qualified identifier&gt; | &lt;operator specifier&gt;

&lt;operator specifier&gt; ::=
	&lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"

&lt;security specifier&gt; ::=
	(<emphasis role="bold">user</emphasis> &lt;user id&gt;) |
	(<emphasis role="bold">role</emphasis> &lt;role name&gt;)

&lt;user id&gt; ::=
	&lt;string&gt;

&lt;role name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<indexterm><primary>Right Assignments</primary></indexterm> 
				<para>Rights management in the catalog is represented by
					 <emphasis>right assignments</emphasis>. The grant and revoke statements create
					 right assignments, either granted or revoked, respectively, while the revert
					 statement deletes right assignments. Note that reverting a right does not
					 necessarily revoke that right, it simply removes the right assignment so that
					 the right is granted or revoked based on the other determining factors in the
					 security model: object ownership and role membership.</para> 
				<para>All three statements operate on a set of rights given by 
					 <phrase role="code">&lt;right&nbsp;specifier&gt;</phrase> to a
					 security context given by 
					 <phrase role="code">&lt;security&nbsp;specifier&gt;</phrase>.
					 The statements include an optional 
					 <phrase
					  role="code">&lt;catalog&nbsp;object&nbsp;specifier&gt;</phrase> that determines
					 which catalog object the rights are associated with.</para> 
				<para>The 
					 <phrase role="code">&lt;right&nbsp;specifier&gt;</phrase> is a
					 comma-separated list of right names. Note that because rights are catalog
					 objects, their identifiers are case-sensitive. If the security statement
					 includes a 
					 <phrase
					  role="code">&lt;catalog&nbsp;object&nbsp;specifier&gt;</phrase>, each right
					 name in the 
					 <phrase role="code">&lt;right&nbsp;specifier&gt;</phrase> is
					 prepended with the name of the catalog object.</para> 
				<indexterm><primary>Security</primary><secondary><phrase
						  role="code"><emphasis role="bold">all</emphasis></phrase>
						  Specifier</secondary></indexterm><indexterm><primary>Security</primary><secondary><phrase
						  role="code"><emphasis role="bold">usage</emphasis></phrase>
						  Specifier</secondary></indexterm> 
				<para>The special purpose right specifiers 
					 <phrase role="code"><emphasis
						  role="bold">all</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">usage</emphasis></phrase> allow groups of object rights to be
					 specified. These specifiers are only valid when a catalog object specifier is
					 used in the security statement.</para> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">all</emphasis></phrase> specifier indicates that all the rights
					 associated with the given object are included in the security statement, while
					 the 
					 <phrase role="code"><emphasis
						  role="bold">usage</emphasis></phrase> specifier indicates that only the rights
					 necessary to use the object, not to administer it be included. Usage rights
					 will vary based on the type of object as follows: 
					 <indexterm><primary>Catalog Objects</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Usage
								Rights</primary></indexterm><indexterm><primary>Scalar
								Types</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Operators</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Tables</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Views</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Devices</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>Constraints</primary><secondary>Usage
								Rights</secondary></indexterm><indexterm><primary>References</primary><secondary>Usage
								Rights</secondary></indexterm> 
					 <informaltable> 
						  <tgroup cols="2"><thead> 
									 <row><entry>Catalog Object</entry><entry>Rights
												Included</entry> 
									 </row></thead><tbody> 
									 <row><entry><phrase role="code">Scalar
													 Type</phrase></entry> 
										  <entry><phrase role="code">Execute</phrase>
												rights for all compiler-generated operators for the type, including selectors,
												accessors, special selectors and comparers, and comparison operators.</entry> 
									 </row> 
									 <row><entry><phrase
												role="code">Operator</phrase></entry><entry><phrase
												role="code">Execute</phrase></entry> 
									 </row> 
									 <row><entry><phrase role="code">Table</phrase> or 
												<phrase
												 role="code">View</phrase></entry><entry><phrase role="code">Select, Insert,
													 Update, Delete</phrase></entry> 
									 </row> 
									 <row><entry><phrase
												role="code">Device</phrase></entry><entry><phrase role="code">Read,
													 Write</phrase></entry> 
									 </row> 
									 <row><entry><phrase
												role="code">Constraint</phrase></entry><entry>None</entry> 
									 </row> 
									 <row><entry><phrase
												role="code">Reference</phrase></entry><entry>None</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>The 
					 <phrase
					  role="code">&lt;catalog&nbsp;object&nbsp;specifier&gt;</phrase> is either the
					 name of a catalog object, or an 
					 <phrase role="code">&lt;operator&nbsp;specifier&gt;</phrase>,
					 denoting a particular operator.</para> 
				<para>The 
					 <phrase role="code">&lt;security&nbsp;specifier&gt;</phrase>
					 indicates that the right statement affects a user or role. Note that user
					 identifiers are case-insensitive and specified as strings, while roles, because
					 they are catalog objects, are named and specified by a case-sensitive 
					 <phrase
					  role="code">&lt;qualified&nbsp;identifier&gt;</phrase>.</para> 
				<para>For a complete discussion of the security model in the
					 Dataphor Server, refer to the 
					 <ulink url="DUGP3Security.html"
					  type="olinka"><citetitle>Security</citetitle></ulink> chapter in the Dataphor
					 User's Guide.</para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-ScalarTypes"> 
				<title><indexterm><primary>Scalar Types</primary><secondary>As
								Catalog Elements</secondary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Scalar
								Types</secondary></indexterm><indexterm><primary>Create Type
								Statement</primary></indexterm><indexterm><primary>Create Type
								Statement</primary></indexterm><indexterm><primary>Alter Type
								Statement</primary></indexterm><indexterm><primary>Drop Type
								Statement</primary></indexterm>Scalar Types</title> 
				<para>A scalar type is a named set of values. Scalar types have no
					 user-visible structure (also called <emphasis>atomic</emphasis>). They are the
					 fundamental units of data description in the D4 language. Types provide the
					 building blocks out of which all other data in the database is built. In
					 addition to providing a complete set of system data types, D4 allows for the
					 creation of user-defined types of arbitrary complexity.</para> 
				<para>Internally, each scalar type has a <emphasis>physical
					 representation</emphasis>, and a <emphasis>native representation</emphasis>.
					 Externally, each scalar type exposes <emphasis>logical
					 representations</emphasis> that allow the value to be manipulated in the
					 logical model. Note that because the physical representation is internal to the
					 query processor, it must be host-implemented. For most types, the compiler can
					 provide a host-implementation for the physical representation.</para> 
				<para>Translation between the physical representation and the
					 native representation is accomplished through a host-implementation structure
					 called a <emphasis>conveyor</emphasis>. This conveyor can be specified as part
					 of the type definition, or system-provided.</para> 
				<para>Each logical representation in the logical model may be
					 singled out as a <emphasis>native accessor</emphasis>. A native accessor is a
					 representation that can be used by the data acess layer to translate the value
					 to and from a given native representation. By default, the Dataphor Server will
					 attempt to select an appropriate logical representation for use as a native
					 accessor when necessary. However, native accessors can also be specified as
					 part of the type definition.</para> 
				<para>For a complete discussion of system-provided representations,
					 refer to the section on representations below.</para> 
				<para>The create scalar type statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;create scalar type statement&gt; ::=
	<emphasis role="bold">create type</emphasis> &lt;scalar type name&gt;
		[&lt;like clause&gt;]
		["{"&lt;scalar type definition item commalist&gt;"}"]
		[&lt;conveyor definition&gt;]
		&lt;metadata&gt;

&lt;scalar type name&gt; ::=
	&lt;qualified identifier&gt;

&lt;like clause&gt; ::=
	<emphasis role="bold">like</emphasis> &lt;scalar type name&gt;
	
&lt;scalar type definition item&gt; ::=
	&lt;representation definition&gt; |
	&lt;constraint definition&gt; |
	&lt;default definition&gt; |
	&lt;special definition&gt;

&lt;conveyor definition&gt; ::=
	&lt;class definition&gt;</programlisting></para> 
				<para>The alter scalar type statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;alter scalar type statement&gt; ::=
	<emphasis role="bold">alter type</emphasis> &lt;scalar type name&gt; 
		["{"&lt;alter scalar type definition item commalist&gt;"}"]
		&lt;alter class definition&gt;
		&lt;alter metadata&gt;

&lt;alter scalar type definition item&gt; ::=
	&lt;alter representation definition&gt; |
	&lt;alter constraint definition&gt; |
	&lt;alter default definition&gt; |
	&lt;alter special definition&gt;</programlisting></para> 
				<para>The drop scalar type statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;drop scalar type statement&gt; ::=
	<emphasis role="bold">drop type</emphasis> &lt;scalar type name&gt;</programlisting></para> 
				<para>These statements create, alter or drop a type named 
					 <phrase role="code">&lt;scalar&nbsp;type&nbsp;name&gt;</phrase>
					 with the characteristics given by the rest of the statements. Explanations for
					 each of the specific portions of the statements follow.</para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para> 
					 <ulink url="D4LGLanguageElements-Types.html" type="link">
						  Language Elements, Types</ulink> | 
					 <ulink url="D4LGLanguageElements-Types-ScalarTypes.html"
					 type="olinkb">Scalar Types</ulink></para> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-Conveyors"> 
					 <title><indexterm><primary>Conveyors</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Conveyors</secondary></indexterm>Conveyors</title> 
					 <para>The 
						  <phrase role="code">&lt;class&nbsp;definition&gt;</phrase>
						  given at the end of the 
						  <phrase
						  role="code">&lt;create&nbsp;scalar&nbsp;type&nbsp;statement&gt;</phrase>
						  describes the host implementation class that will provide the physical
						  representation for this type. This class is known as the
						  <emphasis>conveyor</emphasis> for the type. If no conveyor is specified, the
						  system will provide a default conveyor based on the first representation
						  encountered in the type definition that does not include implementations for
						  the selector and accessors. This representation is said to be the
						  <emphasis>system-provided</emphasis> representation for the type. The physical
						  representation of the scalar type is also said to be
						  <emphasis>system-provided</emphasis>. A given scalar type may have only one
						  system-provided representation. For more information on system-provided
						  representations, refer to the representations discussion in the next
						  section.</para> 
					 <para>The following table lists the conveyors for the system
						  data types. 
						  <informaltable> 
								<tgroup cols="2"><thead> 
										  <row><entry>Scalar Type</entry><entry>Conveyor
													 Class</entry> 
										  </row></thead><tbody> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Boolean.html"
														  type="olinkb">System.Boolean</ulink></phrase></entry><entry><phrase
													 role="code">System.BooleanConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Decimal.html"
														  type="olinkb">System.Decimal</ulink></phrase></entry><entry><phrase
													 role="code">System.DecimalConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Long.html"
														  type="olinkb">System.Long</ulink></phrase></entry><entry><phrase
													 role="code">System.Int64Conveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Integer.html"
														  type="olinkb">System.Integer</ulink></phrase></entry><entry><phrase
													 role="code">System.Int32Conveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Short.html"
														  type="olinkb">System.Short</ulink></phrase></entry><entry><phrase
													 role="code">System.Int16Conveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Byte.html"
														  type="olinkb">System.Byte</ulink></phrase></entry><entry><phrase
													 role="code">System.ByteConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.String.html"
														  type="olinkb">System.String</ulink></phrase></entry><entry><phrase
													 role="code">System.StringConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.TimeSpan.html"
														  type="olinkb">System.TimeSpan</ulink></phrase></entry><entry><phrase
													 role="code">System.TimeSpanConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.DateTime.html"
														  type="olinkb">System.DateTime</ulink></phrase></entry><entry><phrase
													 role="code">System.DateTimeConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Date.html"
														  type="olinkb">System.Date</ulink></phrase></entry><entry><phrase
													 role="code">System.DateTimeConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Time.html"
														  type="olinkb">System.Time</ulink></phrase></entry><entry><phrase
													 role="code">System.DateTimeConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Money.html"
														  type="olinkb">System.Money</ulink></phrase></entry><entry><phrase
													 role="code">System.DecimalConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Guid.html"
														  type="olinkb">System.Guid</ulink></phrase></entry><entry><phrase
													 role="code">System.GuidConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Binary.html"
														  type="olinkb">System.Binary</ulink></phrase></entry><entry><phrase
													 role="code">System.ObjectConveyor</phrase></entry> 
										  </row> 
										  <row><entry><phrase role="code"><ulink
														  url="T-System.Error.html"
														  type="olinkb">System.Error</ulink></phrase></entry><entry><phrase
													 role="code">System.ObjectConveyor</phrase></entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>These conveyors are all registered in the 
						  <phrase role="code">System</phrase> library.</para> 
				</sect2> 
				<sect2
				id="D4LGCatalogElements-ScalarTypes-PossibleRepresentations"> 
					 <title><indexterm><primary>Logical
									 Representations</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Logical
									 Representations</secondary></indexterm>Logical Representations</title> 
					 <para><indexterm><primary>Selectors</primary></indexterm><indexterm><primary>Accessors</primary></indexterm><indexterm><primary>Read
									 Accessors</primary></indexterm><indexterm><primary>Write
									 Accessors</primary></indexterm>Each scalar type has a set of <emphasis>logical
						  representations</emphasis>. Each logical representation is a set of &lt;name,
						  data type&gt; pairs called <emphasis>properties</emphasis>. For each
						  representation, a <emphasis>selector</emphasis> is provided which takes as
						  arguments all the properties of the representation. For each property, a read
						  and write <emphasis>accessor</emphasis> is provided which allows for retrieval
						  and manipulation of the individual components of the representation. It is
						  important to note that the write accessor is only shorthand for the equivalent
						  selector invocation. Values, by definition, are immutable.</para> 
					 <para><indexterm><primary>System-Provided
									 Representation</primary></indexterm>Given any type definition, the compiler
						  must be able to determine the physical representation. Although this
						  information can be specified explicitly, the compiler is capable of providing
						  the implementation based on a logical representation. The compiler will select
						  the first representation encountered in the type definition that does not
						  include implementations for the selector and accessors. This representation is
						  then referred to as a <emphasis>system-provided representation</emphasis>,
						  meaning that not only does it determine the physical representation of the
						  type, but the implementations for the selector and accessors for the
						  representation will be system-provided.</para> 
					 <para>Regardless of whether a given type has a system-provided
						  representation, at least one representation must be host-implemented in order
						  to access the physical representation of the value. A host-implemented
						  representation is one for which the selector and accessors are
						  host-implemented. Each of the other representations may be host- or
						  D4-implemented, but the compiler will only provide default implementations for
						  the system-provided representation.</para> 
					 <para>Note that a logical representation must be capable of
						  representing all the values of a given scalar type. Indeed, if it were not, it
						  would not be a logical representation for the scalar type.</para> 
					 <para>The definition of a scalar type may omit the definition
						  of a representation if that scalar type is defined to be <emphasis><ulink
						  url="D4LGCatalogElements-Conversions-LikeTypes.html"
						  type="link">like</ulink></emphasis> some other scalar type. The 
						  <phrase role="code"><ulink
								url="D4LGCatalogElements-ScalarTypes.html"
								type="link">&lt;like&nbsp;clause&gt;</ulink></phrase> is shorthand for a 
						  <phrase
						  role="code">&lt;representation&nbsp;definition&gt;</phrase> in terms of the
						  like type, and the definition of implicit conversions to and from the like
						  type. 
						  <phrase role="code">Like</phrase> type definitions will be
						  discussed with 
						  <ulink url="D4LGCatalogElements-Conversions.html"
						  type="link">implicit conversions</ulink> later in this guide.</para> 
					 <para>A logical representation definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;representation definition&gt; ::=
	<emphasis role="bold">representation</emphasis> &lt;representation name&gt;
		"{"&lt;ne property definition commalist&gt;"}"
		[&lt;selector definition&gt;]
		&lt;metadata&gt;

&lt;representation name&gt; ::=
	&lt;qualified identifier&gt;

&lt;selector definition&gt; ::=
	&lt;class definition&gt; | (selector &lt;accessor block&gt;)

&lt;accessor block&gt; ::=
	&lt;class definition&gt; | &lt;expression&gt; | &lt;block&gt;</programlisting></para> 
					 <para>An alter logical representation definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter representation definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;representation definition&gt;) |
	(
		<emphasis role="bold">alter representation</emphasis> 
			&lt;representation name&gt; 
			["{"&lt;ne alter property definition commalist&gt;"}"] 
			[&lt;alter selector &lt;alter acessor block&gt;]
			&lt;alter metadata&gt; 
	) |
	(<emphasis role="bold">drop representation</emphasis> &lt;representation name&gt;)

&lt;alter accessor block&gt; ::=
	&lt;alter class definition&gt; | &lt;expression&gt; | &lt;block&gt;</programlisting></para> 
					 <sect3 id="D4LGSelector"> 
						  <title><indexterm><primary>Selector</primary></indexterm><indexterm><primary>Logical
										  Representations</primary><secondary>Selector</secondary></indexterm>Selector</title>
						  
						  <para>A <emphasis>selector</emphasis> is a D4 operator that
								allows the values of a type to be selected based on values for the properties
								of that representation.</para> 
						  <para>The 
								<phrase role="code"><ulink
									 url="D4LGCatalogElements-ScalarTypes-PossibleRepresentations.html"
									 type="link">&lt;selector&nbsp;definition&gt;</ulink></phrase> for the
								representation defines the implementation of the selector operator. There are
								three possibilities. First, the 
								<phrase
								role="code">&lt;selector&nbsp;definition&gt;</phrase> may be omitted if this is
								the system-provided representation for the type. Second, the selector may be
								specified in terms of a 
								<phrase role="code"><ulink
									 url="D4LGCatalogElements-Objects-ClassDefinitions.html"
									 type="link">&lt;class&nbsp;definition&gt;</ulink></phrase> which designates a
								host implementation. Third, the selector may be written in D4 as either a
								simple 
								<phrase role="code"><ulink
									 url="D4LGLanguageElements-Expressions.html"
									 type="link">&lt;expression&gt;</ulink></phrase>, or a 
								<phrase role="code"><ulink
									 url="D4LGImperativeStatements-BlocksandScoping.html"
									 type="link">&lt;block&gt;</ulink></phrase>.</para> 
						  <para>If the 
								<phrase
								role="code">&lt;selector&nbsp;definition&gt;</phrase> is omitted, the
								representation must be the system-provided representation for the type, meaning
								that this representation was used by the compiler to determine a
								system-provided conveyor, or physical representation for the type. If the
								representation has only one property and that property is of some simple scalar
								type, the system will use the class 
								<phrase role="code">System.ScalarSelectorNode</phrase>
								registered in the 
								<phrase role="code">System</phrase> library to provide
								the selector implementation. In this case, the type is said to be a
								<emphasis>simple</emphasis> scalar type. </para> 
						  <para>If the representation has multiple properties, or the
								type of the single property is not a simple scalar type, the compiler will
								provide a compound selector using the class 
								<phrase
								role="code">System.CompoundScalarSelectorNode</phrase>. In this case, the type
								is said to be a <emphasis>compound</emphasis> scalar type. Note that the
								distinction between simple and compound scalar types is only introduced to
								allow the compiler to provide default physical representations for scalar
								types. There is no logical difference between a simple and a compound scalar
								type, they behave the same in every respect in the logical model.</para> 
						  <para>If the 
								<phrase role="code"><ulink
									 url="D4LGCatalogElements-ScalarTypes-PossibleRepresentations.html"
									 type="link">&lt;accessor&nbsp;block&gt;</ulink></phrase> is a D4 expression or
								block, then the type must have at least one host-implemented representation.
								The selector and accessors for the host-implemented representation will be
								available within the D4 code implementing the selector. Note that the
								host-implemented representation may or may not be system-provided.</para> 
						  <para>The selector operator is built based on the accessor
								block determined above with the following header: 
								<programlisting><emphasis role="bold">operator</emphasis> &lt;type name&gt;[.&lt;representation name&gt;]
	(
		<emphasis role="bold">const</emphasis> A&lt;property name&gt; : &lt;property type&gt;[, ...]
	) : &lt;type&gt;</programlisting></para> 
						  <para>The following example illustrates the use of the
								selector for the 
								<phrase role="code">Seconds</phrase> representation of
								the 
								<phrase role="code">System.TimeSpan</phrase> data type:
								
								<programlisting>Seconds(100); // returns a TimeSpan value						</programlisting> </para> 
					 </sect3> 
					 <sect3 id="D4LGProperties"> 
						  <title><indexterm><primary>Properties</primary></indexterm><indexterm><primary>Scalar
										  Types</primary><secondary>Properties</secondary></indexterm>Properties</title> 
						  <para>Properties are the individual components of a logical
								representation. Each property is a &lt;name, data type&gt; pair that defines
								the component of the representation. Each property requires two special-purpose
								operators called accessors, one to read the value for the property, and one to
								write it.</para> 
						  <para>The 
								<phrase
								role="code">&lt;accessor&nbsp;block&gt;</phrase> for the read and write
								accessors define the implementation of these operators. As with selectors,
								there are three possibilities: system-provided, host-implemented, and
								D4-implemented. If the property is a component of the system-provided
								representation, the accessor blocks for the read and write accessors may be
								omitted, and the compiler will provide default implementations. If the accessor
								blocks are D4-implemented, there must be at least one host-implemented
								representation available, and the selector and accessors for that
								representation will be available.</para> 
						  <para>A property definition in D4 has the following syntax:
								
								<programlisting>&lt;property definition&gt; ::=
	&lt;property name&gt; : &lt;type specifier&gt; 
		[<emphasis role="bold">read</emphasis> &lt;accessor block&gt;] 
		[<emphasis role="bold">write</emphasis> &lt;accessor block&gt;] 
		&lt;metadata&gt;
		
&lt;property name&gt; ::=
	&lt;qualified identifier&gt;

&lt;accessor block&gt; ::=
	&lt;class definition&gt; | &lt;expression&gt; | &lt;block&gt;</programlisting></para> 
						  <para>An alter property definition in D4 has the following
								syntax: 
								<programlisting>&lt;alter property definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;property definition&gt;) |
	(
		<emphasis role="bold">alter</emphasis> &lt;property name&gt;
			[: &lt;type specifier&gt;]
			[<emphasis role="bold">alter read</emphasis> &lt;alter accessor block&gt;]
			[<emphasis role="bold">alter write</emphasis> &lt;alter accessor block&gt;]
			&lt;alter metadata&gt; 
	) |
	(<emphasis role="bold">drop</emphasis> &lt;property name&gt;)

&lt;alter accessor block&gt; ::=
	&lt;alter class definition&gt; | &lt;expression&gt; | &lt;block&gt;</programlisting></para> 
						  <sect4 id="D4LGReadAccessor"> 
								<title><indexterm><primary>Read
												Accessor</primary></indexterm><indexterm><primary>Scalar
												Types</primary><secondary>Read Accessor</secondary></indexterm>Read
									 Accessor</title> 
								<para>The read accessor is a special-purpose operator
									 built by the compiler to allow read access to the given property.</para> 
								<para>The 
									 <phrase role="code"><ulink
										  url="D4LGProperties.html" type="link">read
												&lt;accessor&nbsp;block&gt;</ulink></phrase> for the property defines the
									 implementation of the read accessor. If no read accessor definition is
									 provided, the representation must be the system-provided representation for the
									 type, and the compiler will provide a default implementation. If the type is a
									 simple scalar type, the system will use the class 
									 <phrase
									 role="code">System.ScalarReadAccessorNode</phrase> registered in the 
									 <phrase role="code">System</phrase> library to
									 provide the read accessor implementation. If the type is a compound scalar
									 type, the system will use the class 
									 <phrase
									 role="code">System.CompoundScalarReadAccessorNode</phrase>.</para> 
								<para>The read accessor is built based on the class
									 definition determined above with the following header: 
									 <programlisting><emphasis role="bold">operator</emphasis> &lt;type name&gt;.Read&lt;property name&gt;
	(
		<emphasis role="bold">const</emphasis> value : &lt;type&gt;
	) : &lt;property type&gt;</programlisting></para> 
								<para>The following example illustrates the use of a
									 read accessor: 
									 <programlisting>// sets LInteger to the value of the DaysPart property of a TimeSpan
LInteger = LTimeSpan.DaysPart; </programlisting></para> 
						  </sect4> 
						  <sect4 id="D4LGWriteAccessor"> 
								<title><indexterm><primary>Write
												Accessor</primary></indexterm><indexterm><primary>Properties</primary><secondary>Write
												Accessor</secondary></indexterm>Write Accessor</title> 
								<para>The write accessor is a special-purpose operator
									 built by the compiler to allow write access to the given property.</para> 
								<para>The 
									 <phrase role="code"><ulink
										  url="D4LGProperties.html" type="link">write
												&lt;accessor&nbsp;block&gt;</ulink></phrase> for the property defines the
									 implementation of the write accessor. If no write accessor definition is
									 provided, the representation must be the system-provided representation for the
									 type, and the compiler will provide a default implementation. If the type is a
									 simple scalar type, the system will use the class 
									 <phrase
									 role="code">System.ScalarWriteAccessorNode</phrase> registered in the 
									 <phrase role="code">System</phrase> library to
									 provide the write accessor implementation. If the type is a compound scalar
									 type, the system will use the class 
									 <phrase
									 role="code">System.CompoundScalarWriteAccessorNode</phrase>.</para> 
								<para>The write accessor is built based on the class
									 definition determined above with the following header: 
									 <programlisting><emphasis role="bold">operator</emphasis> &lt;type name&gt;.Write&lt;property name&gt;
	(
		<emphasis role="bold">const</emphasis> Avalue : &lt;type&gt;, 
		<emphasis role="bold">const</emphasis> A&lt;property name&gt; : &lt;property type&gt;
	) : &lt;type&gt;</programlisting></para> 
								<para>The following example illustrates the use of a
									 write accessor: 
									 <programlisting>// sets the value of the DaysPart property of the LTimeSpan variable
LTimeSpan.DaysPart := 100;</programlisting></para> 
						  </sect4> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-NativeAccessors"> 
					 <title><indexterm><primary>Native
									 Accessors</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Native Accessors</secondary></indexterm>Native
						  Accessors</title> 
					 <para>Native accessors provide a mechanism for translating to
						  and from various native representations of the type. This mechanism is used by
						  the data access layer to facilitate data entry and display in the presentation
						  layer.</para> 
					 <para>A given logical representation can be explicitly
						  specified as a native accessor using the metadata tag 
						  <phrase
						  role="code">DAE.&lt;native&nbsp;accessor&nbsp;name&gt;</phrase> on the
						  representation. The value of this tag is the name of the logical representation
						  that will serve as the given native accessor. The table below gives the names
						  of the available native accessors, and their associated tag names.</para> 
					 <para>When the data access layer requests a value in terms of
						  some native representation, the logical representations of the scalar type are
						  searched for an appropriate representation to be used to perform the
						  translation. The following sequence of steps is taken when performing this
						  search: 
						  <itemizedlist> 
								<listitem> 
									 <para>If the required native representation is the
										  same as the native representation of the type, that representation is
										  used.</para> 
								</listitem> 
								<listitem> 
									 <para>If a logical representation of the type is
										  explicitly specified as the requested native representation, that
										  representation is used.</para> 
								</listitem> 
								<listitem> 
									 <para>If a logical representation matches the
										  requested native representation, that representation is used.</para> 
								</listitem> 
								<listitem> 
									 <para>If no logical representation can be found,
										  the data access layer reports an error.</para> 
								</listitem> 
						  </itemizedlist> </para> 
					 <para>The Dataphor Server defines the following native
						  representations: 
						  <informaltable> 
								<tgroup cols="3"><tbody> 
										  <row><entry><ulink
													 url="Alphora.Dataphor.DAE.Client.DataFieldProperties.html" type="olinka">Native
														  Accessor</ulink></entry><entry>Native (.NET Framework)Type</entry><entry><ulink
													 url="D4LGCatalogElements-Objects-Metadata.html" type="link">Metadata Tag
														  Name</ulink></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsBoolean</phrase></entry><entry><phrase
													 role="code">System.Boolean</phrase></entry><entry><phrase
													 role="code">DAE.AsBoolean</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsByte</phrase></entry><entry><phrase
													 role="code">System.Byte</phrase></entry><entry><phrase
													 role="code">DAE.AsByte</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsInt16</phrase></entry><entry><phrase
													 role="code">System.Int16</phrase></entry><entry><phrase
													 role="code">DAE.AsInt16</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsInt32</phrase></entry><entry><phrase
													 role="code">System.Int32</phrase></entry><entry><phrase
													 role="code">DAE.AsInt32</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsInt64</phrase></entry><entry><phrase
													 role="code">System.Int64</phrase></entry><entry><phrase
													 role="code">DAE.AsInt64</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsDecimal</phrase></entry><entry><phrase
													 role="code">System.Decimal</phrase></entry><entry><phrase
													 role="code">DAE.AsDecimal</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsString</phrase></entry><entry><phrase
													 role="code">System.String</phrase></entry><entry><phrase
													 role="code">DAE.AsString</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsDisplayString</phrase></entry><entry><phrase
													 role="code">System.String</phrase></entry><entry><phrase
													 role="code">DAE.AsDisplayString</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsDateTime</phrase></entry><entry><phrase
													 role="code">System.DateTime</phrase></entry><entry><phrase
													 role="code">DAE.AsDateTime</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsTimeSpan</phrase></entry><entry><phrase
													 role="code">System.TimeSpan</phrase></entry><entry><phrase
													 role="code">DAE.AsTimeSpan</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsGuid</phrase></entry><entry><phrase
													 role="code">System.Guid</phrase></entry><entry><phrase
													 role="code">DAE.AsGuid</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsException</phrase></entry><entry><phrase
													 role="code">System.Exception</phrase></entry><entry><phrase
													 role="code">DAE.AsException</phrase></entry> 
										  </row> 
										  <row><entry><phrase
													 role="code">AsByteArray</phrase></entry><entry><phrase
													 role="code">byte[]</phrase></entry><entry><phrase
													 role="code">DAE.AsByteArray</phrase></entry> 
										  </row></tbody> 
								</tgroup> 
						  </informaltable></para> 
					 <para>The 
						  <phrase role="code">AsString</phrase> and 
						  <phrase role="code">AsDisplayString</phrase> native
						  accessors both translate to and from string values. However, the 
						  <phrase role="code">AsDisplayString</phrase> native
						  accessor is intended to provide a more cosmetic representation, while the 
						  <phrase role="code">AsString</phrase> accessor provides a
						  user-editable format for the value. For example, the 
						  <phrase role="code">AsString</phrase> accessor for the 
						  <phrase role="code">System.Money</phrase> type is simply
						  the decimal value as a string, while the 
						  <phrase role="code">AsDisplayString</phrase> accessor
						  includes currency formatting.</para> 
					 <para>The following example illustrates the use of the native
						  accessor metadata tags: 
						  <programlisting><emphasis role="bold">create type</emphasis> Money
{
	<emphasis role="bold">representation</emphasis> Money
	{
		Value : Decimal
			<emphasis role="bold">read class</emphasis> "System.ScalarReadAccessorNode"
			<emphasis role="bold">write class</emphasis> "System.ScalarWriteAccessorNode"
	} <emphasis role="bold">class</emphasis> "System.ScalarSelectorNode",
	<emphasis role="bold">representation</emphasis> AsString
	{
		AsString : String
			<emphasis role="bold">read class</emphasis> "System.MoneyAsStringReadAccessorNode"
			<emphasis role="bold">write class</emphasis> "System.MoneyAsStringWriteAccessorNode"
	} <emphasis role="bold">class</emphasis> "System.MoneyAsStringSelectorNode",
	<emphasis role="bold">representation</emphasis> AsDisplayString
	{
		AsDisplayString : String
			<emphasis role="bold">read class</emphasis> "System.MoneyAsDisplayStringReadAccessorNode"
			<emphasis role="bold">write class</emphasis> "System.MoneyAsStringWriteAccessorNode"
	} <emphasis role="bold">class</emphasis> "System.MoneyAsStringSelectorNode"
} 
	<emphasis role="bold">class</emphasis> "System.DecimalConveyor"
	<emphasis role="bold">static tags</emphasis> 
	{ 
		Catalog.Comment = "System Money", 
		DAE.AsString = "AsString",
		DAE.AsDisplayString = "AsDisplayString"
	};</programlisting></para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-Defaults"> 
					 <title><indexterm><primary>Defaults
									 (Syntax)</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Defaults</secondary></indexterm>Defaults</title> 
					 <para>A scalar type may have a <emphasis>default</emphasis>
						  associated with it, which indicates what the default value for any variable of
						  this type should be. This applies not only to columns in a table, but also to
						  local variables declared through a variable declaration statement. The default
						  must be a value of the type.</para> 
					 <para>A scalar type default definition in D4 has the following
						  syntax: 
						  <programlisting>&lt;default definition&gt; ::=
	<emphasis role="bold">default</emphasis> &lt;expression&gt; &lt;metadata&gt;</programlisting></para> 
					 <para>An alter scalar type default definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter default definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;default definition&gt;) |
	(<emphasis role="bold">alter default</emphasis> [&lt;expression&gt;] &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop</emphasis> default)</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;expression&gt;</phrase> production
						  rule see 
						  <ulink url="D4LGLanguageElements-Expressions.html"
						  type="xref">Expressions</ulink>.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-TypeConstraints"> 
					 <title><indexterm><primary>Type Constraints
									 (Syntax)</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Type Constraints</secondary></indexterm>Type
						  Constraints</title> 
					 <para>Scalar types in D4 are defined using constraints. A type
						  constraint describes the set of legal values for the type. Constraints are
						  enforced whenever a variable assignment is made, including local variables and
						  column assignments. A given type may have any number of constraints associated
						  with it. The Dataphor Server will verify that any value of the given type
						  satisfies all the type constraints defined. </para> 
					 <para>If a constraint is violated (if the expression evaluates
						  to false for some value), an error will be raised. Note that if the constraint
						  expression evaluates to nil, the constraint is considered satisfied. The text
						  of the error message can be specified using metadata on the constraint. If the
						  tag 
						  <phrase role="code"><ulink
								url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
								type="olinka">DAE.SimpleMessage</ulink></phrase> appears on the constraint, the
						  value of the tag will be used as the message of the error. If the tag 
						  <phrase role="code"><ulink
								url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
								type="olinka">DAE.Message</ulink></phrase> appears on the constraint, the value
						  of the tag is a D4 expression that is evaluated in the same context as the
						  validation (i.e. the expression will have access to the implicit 
						  <phrase role="code"><emphasis
								role="bold">value</emphasis></phrase> variable, which contains the value being
						  validated). The expression is expected to return a value of type string that
						  will be the text of the error. If no custom message is provided, a generic
						  error will be given stating that the constraint has been violated. In either
						  case, the 
						  <ulink url="DUGP1ErrorsandWarnings.html"
						  type="olinka">severity</ulink> of the error given will be
						  <emphasis>User</emphasis>.</para> 
					 <para>A type constraint definition in D4 has the following
						  syntax: 
						  <programlisting>&lt;constraint definition&gt; ::=
	<emphasis role="bold">constraint</emphasis> &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>An alter type constraint definition in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter constraint definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;constraint definition&gt;) |
	(<emphasis role="bold">alter constraint</emphasis> &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop constraint</emphasis> &lt;constraint name&gt;)</programlisting></para> 
					 <para>For a detailed description of the 
						  <phrase role="code">&lt;expression&gt;</phrase> production
						  rule see 
						  <ulink url="D4LGLanguageElements-Expressions.html"
						  type="olinkb">Expressions</ulink>.</para> 
					 <para>The expression specified must be boolean-valued, 
						  <ulink url="D4LGLanguageElements-Expressions.html"
						  type="link">functional</ulink>, and 
						  <ulink url="D4LGLanguageElements-Expressions.html"
						  type="link">deterministic</ulink>. In addition, the constraint expression is
						  not allowed to reference global database state. The compiler enforces these
						  requirements. Within the expression, the implicit variable 
						  <phrase role="code"><emphasis
								role="bold">value</emphasis></phrase> is available, which is the value being
						  validated.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-SpecialValues"> 
					 <title><indexterm><primary>Specials
									 (Syntax)</primary></indexterm><indexterm><primary>Scalar
									 Types</primary><secondary>Specials</secondary></indexterm>Specials</title> 
					 <para>A <emphasis>special</emphasis> is a named value of the
						  scalar type. Special values provide a mechanism for the application to
						  designate a given value as significant in some way.</para> 
					 <para>Special definitions in D4 have the following syntax: 
						  <programlisting>&lt;special definition&gt; ::=
	<emphasis role="bold">special</emphasis> &lt;special name&gt; &lt;expression&gt; &lt;metadata&gt;

&lt;special name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>Alter special definitions in D4 have the following
						  syntax: 
						  <programlisting>&lt;alter special definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;special definition&gt;) |
	(<emphasis role="bold">alter special</emphasis> &lt;special name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop special</emphasis> &lt;special name&gt;)</programlisting></para> 
					 <para><indexterm><primary>Special
									 Selector</primary></indexterm><indexterm><primary>Special
									 Comparer</primary></indexterm>For each special the compiler builds two
						  special-purpose operators called the <emphasis>special selector</emphasis> and
						  the <emphasis>special comparer</emphasis>. The special selector has the
						  heading: 
						  <programlisting><emphasis role="bold">operator</emphasis> &lt;type name&gt;&lt;special name&gt;() : &lt;type&gt;</programlisting>and returns the value of the special. The special comparer has
						  the heading: 
						  <programlisting><emphasis role="bold">operator</emphasis> Is&lt;special name&gt;(<emphasis role="bold">const</emphasis> AValue : &lt;type&gt;) : Boolean</programlisting>and returns true if the given value is equal to the value of
						  the special, and false otherwise.</para> 
					 <para>In addition to the operators created for each special,
						  each scalar type has an associated special comparer which is created even if
						  there are no specials defined for the type. The scalar type special comparer
						  has the heading: 
						  <programlisting><emphasis role="bold">operator</emphasis> IsSpecial(<emphasis role="bold">const</emphasis> AValue : &lt;type&gt;) : Boolean</programlisting>and returns true if the given value is equal to the value of
						  any special defined on the type, and false otherwise.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-Metadata"> 
					 <title><indexterm><primary>Scalar
									 Types</primary><secondary>Metadata</secondary></indexterm>Metadata</title> 
					 <para>The 
						  <phrase role="code">&lt;metadata&gt;</phrase> describes
						  additional information that should be associated with this type. For more
						  information on the tags available for use with scalar types, refer to 
						  <ulink url="DRTags.html" type="olinkb">Tags</ulink>.</para>
					 
				</sect2> 
				<sect2 id="D4LGCatalogElements-ScalarTypes-Examples"> 
					 <title>Examples</title> 
					 <para>The following examples illustrate the use of the create
						  type statement: 
						  <programlisting><emphasis role="bold">create type</emphasis> ID <emphasis role="bold">like</emphasis> Integer;

<emphasis role="bold">create type</emphasis> ShortID
{
	<emphasis role="bold">representation</emphasis> ShortID { ShortID : String },
	<emphasis role="bold">constraint</emphasis> LengthValid 
		Length(value) &lt;= 3 
		<emphasis role="bold">tags</emphasis> { DAE.SimpleMessage = "Short ID must be 3 characters or less" }
};

<emphasis role="bold">create operator</emphasis> InchesToString(<emphasis role="bold">const</emphasis> AInches : Decimal) : String
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := AInches.ToString() + '"';
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">create operator</emphasis> StringToInches(<emphasis role="bold">const</emphasis> AString : String) : Decimal
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := AString.SubString(0, AString.IndexOf('"')).ToDecimal();
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">create type</emphasis> Length
{
	// The compiler will use this representation to construct the physical representation
	<emphasis role="bold">representation</emphasis> Inches { Inches : Decimal }, 

	<emphasis role="bold">representation</emphasis> Feet 
	{ 
		Feet : Decimal 
			<emphasis role="bold">read</emphasis> <emphasis role="bold">value</emphasis>.Inches / 12
			<emphasis role="bold">write</emphasis> Inches(Feet * 12) 
	} <emphasis role="bold">selector</emphasis> Inches(Feet * 12),

	<emphasis role="bold">representation</emphasis> Centimeters 
	{ 
		Centimeters : Decimal 
			<emphasis role="bold">read</emphasis> <emphasis role="bold">value</emphasis>.Inches * 2.54 
			<emphasis role="bold">write</emphasis> Inches(Centimeters / 2.54) 
	} <emphasis role="bold">selector</emphasis> Inches(Centimeters / 2.54),
	
	// The AsString representation will be used by the 
	// Frontend to display Length values and to 
	// allow the user to enter length values
	<emphasis role="bold">representation</emphasis> AsString 
	{ 
		AsString : String 
			<emphasis role="bold">read</emphasis> InchesToString(value.Inches) 
			<emphasis role="bold">write</emphasis> Inches(StringToInches(AsString)) 
	} <emphasis role="bold">selector</emphasis> Inches(StringToInches(AsString))
};</programlisting> </para> 
					 <para>The following example illustrates the use of the alter
						  type statement: 
						  <programlisting><emphasis role="bold">alter type</emphasis> ID <emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Frontend.Width = "10" };

<emphasis role="bold">alter type</emphasis> ShortID
{
	<emphasis role="bold">create default</emphasis> "",
	<emphasis role="bold">create special</emphasis> Unknown ""
};</programlisting> </para> 
					 <para>The following example illustrates the use of the drop
						  type statement: 
						  <programlisting><emphasis role="bold">drop type</emphasis> ID;</programlisting> </para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-TableVariables"> 
				<title><indexterm><primary>Table
								Variables</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Table Variables</secondary></indexterm>Table
					 Variables</title> 
				<para>Table variables are the only global variables in the catalog.
					 They represent the complete state of the database at any given point. There are
					 two types of table variables, base and derived. Base table variables in D4 are
					 called Tables, while derived table variables are called Views. Note that for
					 convenience, the unqualified term table is often used to denote both base and
					 derived table variables, especially when discussing properties that are common
					 to both objects.</para> 
				<sect2
				id="D4LGCatalogElements-TableVariables-CommonCharacteristics"> 
					 <title><indexterm><primary>Table
									 Variables</primary><secondary>Common
									 Characteristics</secondary></indexterm>Common Characteristics</title> 
					 <para>Table variables have several characteristics in common,
						  including keys, orders, constraints, and references. These characteristics
						  share common production rules in the grammar and so are discussed first.</para>
					 
					 <sect3 id="D4LGKeys"> 
						  <title><indexterm><primary>Keys
										  (Syntax)</primary></indexterm><indexterm><primary>Table
										  Variables</primary><secondary>Keys</secondary></indexterm>Keys</title> 
						  <para>All table variables may have any number of associated
								keys. A <emphasis>key</emphasis> is a subset of the columns of a table variable
								that constitutes a unique identifier for any row in the table. In other words,
								no two rows in the table have the same values for all the columns of any key of
								the table. When a table variable is declared, the keys of the table variable
								may also be declared. For derived table variables, the keys specified are in
								addition to those already inferred by the compiler.</para> 
						  <para>Note that keys do not imply any ordering or indexing,
								they only declare a unique constraint for the table variable. This uniqueness
								provides the logical addressing mechanism for all tables.</para> 
						  <para>All tables must have at least one key. If no keys are
								specified in the table declaration, all columns will be used as a key. Note
								that a key is not required to have any columns. A key with no columns
								effectively means the table may only contain one row.</para> 
						  <para>Key definitions in D4 have the following syntax: 
								<programlisting>&lt;key definition&gt; ::=
	<emphasis role="bold">key</emphasis> "{"&lt;column name commalist&gt;"}" &lt;metadata&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter key definitions in D4 have the following
								syntax: 
								<programlisting>&lt;alter key definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;key definition&gt;) |
	(<emphasis role="bold">alter key</emphasis> "{"&lt;column name commalist&gt;"}" &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop key</emphasis> "{"&lt;column name commalist&gt;"}")</programlisting></para> 
						  <para>Note that, as the alter syntax indicates, the columns
								in a key cannot be changed. The key must be dropped and re-created to effect a
								change of this type.</para> 
						  <indexterm><primary>Sparse
									 Keys</primary></indexterm><indexterm><primary>Keys</primary><secondary>Sparse
									 Keys</secondary></indexterm> 
						  <para>In the presence of nilable columns, a key may be
								defined as either <emphasis>sparse</emphasis>, or <emphasis>dense</emphasis>.
								As discussed in the section on 
								<ulink url="D4LGNilSemantics.html" type="xref">Nil
									 Semantics</ulink>, for dense keys, the definition of row-equality is used to
								enforce key constraints. This means that for a single-column key, a nil in the
								key column may only appear in one row of the table. Sparse keys, by contrast
								enforce uniqueness only among the rows that have values specified for the
								columns of the key. Because a sparse key cannot be used as a logical addressing
								mechanism, there are restrictions on the usage of sparse keys in the query
								processor. In particular, sparse keys will not be used to ensure uniqueness for
								a 
								<phrase role="code"><emphasis
									 role="bold">browse</emphasis></phrase> operator, and may not be used to define
								clustered indexes in the storage layer. To specify that a given key is sparse,
								use the 
								<phrase role="code">Storage.IsSparse</phrase> tag on
								the key definition.</para> 
					 </sect3> 
					 <sect3 id="D4LGOrders"> 
						  <title><indexterm><primary>Orders
										  (Syntax)</primary></indexterm><indexterm><primary>Table
										  Variables</primary><secondary>Orders</secondary></indexterm>Orders</title> 
						  <para>All table variables may have any number of associated
								orders. An <emphasis>order</emphasis> is a possible ordering of the columns of
								a table. It is a kind of metadata that is used by consumers of data in the
								Dataphor Server and has no effect on the logical model. When a table variable
								is declared, the orders of the table variable may also be declared. For derived
								table variables, the orders specified are in addition to those already inferred
								by the compiler.</para> 
						  <para>Order definitions in D4 have the following syntax: 
								<programlisting>&lt;order definition&gt; ::=
	<emphasis role="bold">order</emphasis> "{"&lt;order column definition commalist&gt;"}" &lt;metadata&gt;
    
&lt;order column definition&gt; ::=
	&lt;column name&gt; [<emphasis role="bold">sort</emphasis> &lt;expression&gt;] [<emphasis role="bold">asc</emphasis> | <emphasis role="bold">desc</emphasis>] [(<emphasis role="bold">include</emphasis> | <emphasis role="bold">exclude</emphasis>) <emphasis role="bold">nil</emphasis>]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter order definitions in D4 have the following
								syntax: 
								<programlisting>&lt;alter order definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;order definition&gt;) |
	(<emphasis role="bold">alter order</emphasis> "{"&lt;order column definition commalist&gt;"}" &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop order</emphasis> "{"&lt;order column definition commalist&gt;"}")</programlisting></para> 
						  <para>Note that, as the alter syntax indicates, the columns
								of an order cannot be changed. The order must be dropped and re-created to
								effect a change of this type.</para> 
						  <para>An order can consist of any subset of the columns of
								a table variable in any order. Each column can include an optional sort
								expression, and an optional ascending indicator. In addition, the column can
								specify whether or not to include rows with a 
								<phrase role="code"><emphasis role="bold"><ulink
									 url="D4LGNilSemantics.html" type="link">nil</ulink></emphasis></phrase> for the
								column in the result.</para> 
						  <para>The sort expression allows the order to use an
								arbitrary condition for sorting. The sort expression must be integer-valued, 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">functional</ulink> and 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">deterministic</ulink>.
								The expression has access to the implicit variables 
								<phrase role="code"><emphasis
									 role="bold">left.value</emphasis></phrase> and 
								<phrase role="code"><emphasis
									 role="bold">right.value</emphasis></phrase>, which are the values to be
								compared. The expression must return -1 if 
								<phrase role="code"><emphasis
									 role="bold">left.value</emphasis></phrase> is less than 
								<phrase role="code"><emphasis
									 role="bold">right.value</emphasis></phrase>, 0 if the two values are equal, and
								1 if 
								<phrase role="code"><emphasis
									 role="bold">left.value</emphasis></phrase> is greater than 
								<phrase role="code"><emphasis
									 role="bold">right.value</emphasis></phrase>.</para> 
						  <para>The optional ascending indicator specifies whether
								this column should be sorted ascending or descending. If no ascending indicator
								is specified, ascending is assumed.</para> 
					 </sect3> 
					 <sect3 id="D4LGRowConstraints"> 
						  <title><indexterm><primary>Constraints</primary><secondary>Row
										  Constraints (Syntax)</secondary></indexterm><indexterm><primary>Row Constraints
										  (Syntax)</primary></indexterm><indexterm><primary>Table
										  Variables</primary><secondary>Row Constraints
										  (Syntax)</secondary></indexterm>Row Constraints</title> 
						  <para>All table variables may have any number of row
								constraints associated with them. Each row constraint is validated whenever any
								insert or update is made against the table variable. If a constraint is
								violated, i.e. if the expression evaluates to false for any row, the name of
								the constraint is used to construct an error message. If present on the
								constraint, the metadata tag 
								<phrase role="code"><ulink
									 url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
									 type="olinka">DAE.Message</ulink></phrase> is also used to construct the error
								message.</para> 
						  <para>Row constraint definitions in D4 have the following
								syntax: 
								<programlisting>&lt;row constraint definition&gt; ::=
	&lt;constraint definition&gt; |
	&lt;transition constraint definition&gt;

&lt;constraint definition&gt; ::=
	constraint &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;

&lt;transition constraint definition&gt; ::=
	transition constraint &lt;constraint name&gt;
		[<emphasis role="bold">on insert</emphasis> &lt;expression&gt;]
		[<emphasis role="bold">on update</emphasis> &lt;expression&gt;]
		[<emphasis role="bold">on delete</emphasis> &lt;expression&gt;]
		&lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
						  <para>Alter row constraint definitions in D4 have the
								following syntax: 
								<programlisting>&lt;alter row constraint definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;row constraint definition&gt;) |
	(<emphasis role="bold">alter constraint</emphasis> &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;) |
	&lt;alter transition constraint definition&gt; |
	(<emphasis role="bold">drop</emphasis> [<emphasis role="bold">transition</emphasis>] <emphasis role="bold">constraint</emphasis> &lt;constraint name&gt;)

&lt;alter transition constraint definition&gt; ::=
	<emphasis role="bold">alter transition constraint</emphasis> &lt;constraint name&gt;
		[&lt;alter transition constraint definition item&gt;]
		[&lt;alter transition constraint definition item&gt;]
		[&lt;alter transition constraint definition item&gt;]
		&lt;alter metadata&gt;

&lt;alter transition constraint definition item&gt; ::=
	(<emphasis role="bold">create on</emphasis> &lt;transition&gt; &lt;expression&gt;) |
	(<emphasis role="bold">alter on</emphasis> &lt;transition&gt; &lt;expression&gt;) |
	(<emphasis role="bold">drop on</emphasis> &lt;transition&gt;)

&lt;transition&gt; ::=
	<emphasis role="bold">insert</emphasis> | <emphasis role="bold">update</emphasis> | <emphasis role="bold">delete</emphasis></programlisting></para> 
						  <para>As the syntax indicates, there are two types of row
								constraints: <emphasis>simple</emphasis> constraints and
								<emphasis>transition</emphasis> constraints.</para> 
						  <para>Simple constraints specify a condition that must hold
								for every row in the table. The constraint expression is required to be
								boolean-valued, 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">functional</ulink> and 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">deterministic</ulink>.
								The compiler enforces these requirements. Within the constraint expression,
								access to the columns of the row being validated is available by directly
								referencing the column names.</para> 
						  <para>Transition constraints specify a condition that must
								hold for some transition of a row within the table. The transition constraint
								may specify a condition that must hold for the <emphasis>insert</emphasis>,
								<emphasis>update</emphasis>, and <emphasis>delete</emphasis> transition. The
								constraint expression in every case is required to be boolean-valued, 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">functional</ulink> and 
								<ulink
								url="D4LGLanguageElements-Expressions.html" type="link">deterministic</ulink>.
								The compiler enforces these requirements. Within an insert expression, access
								to the columns of the row being inserted is avilable by referencing the column
								names, prefixed with the 
								<phrase role="code">new</phrase> keyword. Within an
								update expression, access to the old values of the row being updated is
								available by referencing the column name, prefixed with the 
								<phrase role="code">old</phrase> keyword, and access to
								the new values of the row being updated is available by referencing the column
								name, prefixed with the 
								<phrase role="code">new</phrase> keyword. Within a
								delete expression, access to the values of the row being deleted is available
								by referencing the column name, prefixed with the 
								<phrase role="code">old</phrase> keyword.</para> 
						  <para>Both types of constraints are allowed to reference
								global catalog objects. In so doing, the constraint becomes a
								<emphasis>deferred</emphasis> constraint check, meaning that it will not be
								checked until transaction commit. This behavior can be controlled using the 
								<phrase role="code"><ulink
									 url="FTRTagsDescriptions-DAETags-IsDeferred.html"
									 type="olinka">DAE.IsDeferred</ulink></phrase> tag in the constraint
								definition.</para> 
						  <para>For both row and transition constraints, if the
								constraint expression evaluates to nil, the constraint is considered
								satisfied.</para> 
						  <para>As with all constraints, the text of the error
								message can be specified using metadata on the constraint. If the tag 
								<phrase role="code"><ulink
									 url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
									 type="olinka">DAE.SimpleMessage</ulink></phrase> appears on the constraint, the
								value of the tag will be used as the message of the error. If the tag 
								<phrase role="code"><ulink
									 url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
									 type="olinka">DAE.Message</ulink></phrase> appears on the constraint, the value
								of the tag is a D4 expression that is evaluated in the same context as the
								validation. The expression is expected to return a value of type string that
								will be the text of the error. For transition constraints, the transition can
								be included in the tag name, indicating which transition violation the message
								is to be used with. For example, the tag 
								<phrase role="code">DAE.Insert.SimpleMessage</phrase>
								specifies the text of the message to be used if the insert transition of the
								constraint is violated. If no custom message is provided, a generic error will
								be given stating that the constraint has been violated. In either case, the 
								<ulink url="DUGP1ErrorsandWarnings.html"
								type="olinka">severity</ulink> of the error given will be
								<emphasis>User</emphasis>.</para> 
					 </sect3> 
					 <sect3 id="D4LGReferences"> 
						  <title><indexterm><primary>References</primary><secondary>Table
										  Variables And</secondary></indexterm><indexterm><primary>Table
										  Variables</primary><secondary>References</secondary></indexterm>References</title>
						  
						  <para>All table variables can participate in any number of
								reference constraints. These references are allowed to be declared within a
								table variable declaration for convenience. This mechanism is only shorthand
								for the equivalent reference constraint definition. For a complete description
								of references, refer to 
								<ulink url="D4LGCatalogElements-References.html"
								type="xref">References</ulink>.</para> 
						  <para>Reference definitions within table variable
								declarations in D4 have the following syntax: 
								<programlisting>&lt;reference definition&gt; ::=
	<emphasis role="bold">reference</emphasis> &lt;reference name&gt; 
	"{"&lt;column name commalist&gt;"}" 
	&lt;references definition&gt;
	&lt;metadata&gt;
	
&lt;reference name&gt; ::=
	&lt;qualified identifier&gt;</programlisting>Alter reference definitions within table variable declarations
								in D4 have the following syntax: 
								<programlisting>&lt;alter reference definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;reference definition&gt;) |
	(<emphasis role="bold">alter reference</emphasis> &lt;reference name&gt; &lt;alter metadata&gt;)
	(<emphasis role="bold">drop</emphasis> &lt;reference name&gt;)</programlisting></para> 
						  <para>For a complete description of the 
								<phrase
								role="code">&lt;references&nbsp;definition&gt;</phrase> production rule, refer
								to 
								<ulink url="D4LGCatalogElements-References.html"
								type="xref">References</ulink>.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-TableVariables-Tables"> 
					 <title><indexterm><primary>Tables</primary></indexterm><indexterm><primary>Table
									 Variables</primary><secondary>Tables</secondary></indexterm><indexterm><primary>Create
									 Table Statement</primary></indexterm><indexterm><primary>Alter Table
									 Statement</primary></indexterm><indexterm><primary>Drop Table
									 Statement</primary></indexterm><indexterm><primary><phrase
									 role="code"><emphasis
										  role="bold">from</emphasis></phrase></primary><secondary>Create Table
									 Statement</secondary></indexterm>Tables</title> 
					 <para>Tables are base relation variables, that is, they
						  represent sets of unordered rows, where each row contains a value for each of
						  the columns defined by the table header. A table (variable) is the fundamental
						  unit of data persistence in the catalog. Tables, combined with views, provide
						  the mechanism for describing the data that is available in the application
						  schema. Tables are defined in terms of the columns they contain.</para> 
					 <para>The create table statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;create table statement&gt; ::=
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">table</emphasis> &lt;table name&gt;
	[&lt;device clause&gt;]
	(
		(<emphasis role="bold">from</emphasis> &lt;expression&gt;) |
		("{"&lt;table definition item commalist&gt;"}")
	)
	&lt;metadata&gt;
    
&lt;table name&gt; ::=
	&lt;qualified identifier&gt;

&lt;device clause&gt; ::=
	<emphasis role="bold">in</emphasis> &lt;device name&gt;	

&lt;device name&gt; ::=
	&lt;qualified identifier&gt;

&lt;table definition item&gt; ::=
	&lt;column definition&gt; |
 &lt;row constraint definition&gt; |
	&lt;key definition&gt; |
 &lt;reference definition&gt; |
	&lt;order definition&gt;</programlisting></para> 
					 <para>The alter table statement in D4 has the following syntax:
						  
						  <programlisting>&lt;alter table statement&gt; ::=
	<emphasis role="bold">alter table</emphasis> &lt;table name&gt; 
		["{"&lt;alter table definition item commalist&gt;"}"]
		&lt;alter metadata&gt;

&lt;alter table definition item&gt; ::=
	&lt;alter column definition&gt; |
	&lt;alter row constraint definition&gt; |
	&lt;alter key definition&gt; |
	&lt;alter reference definition&gt; |
	&lt;alter order definition&gt;</programlisting></para> 
					 <para>The drop table statement in D4 has the following syntax: 
						  <programlisting>&lt;drop table statement&gt; ::=
	<emphasis role="bold">drop table</emphasis> &lt;table name&gt;</programlisting></para> 
					 <para>These statements create, alter, or drop a base table
						  variable named 
						  <phrase role="code">&lt;table&nbsp;name&gt;</phrase> in the
						  catalog. The optional 
						  <phrase role="code"><emphasis
								role="bold">session</emphasis></phrase> keyword indicates the table is visible
						  only within the current session. A session-specific table will hide a global
						  table with the same name.</para> 
					 <para>The 
						  <phrase
						  role="code">&lt;create&nbsp;table&nbsp;statement&gt;</phrase> includes an
						  optional 
						  <phrase role="code">&lt;device&nbsp;clause&gt;</phrase>
						  which indicates that the table is persisted in the specified device. If no
						  device is specified, the compiler will use the default device for the table
						  variable. The default device is determined as described in 
						  <ulink
						  url="D4LGCatalogElements-Libraries-DefaultDeviceResolution.html"
						  type="xref">Default Device Resolution</ulink>. For more information on how the
						  Dataphor Server maps table variables and operators into devices, see 
						  <ulink url="DDGPhysicalRealization.html"
						  type="olinka">Physical Realization</ulink>.</para> 
					 <para>For a description of the 
						  <phrase role="code">&lt;key&nbsp;definition&gt;</phrase>, 
						  <phrase role="code">&lt;order&nbsp;definition&gt;</phrase>,
						  
						  <phrase
						  role="code">&lt;row&nbsp;constraint&nbsp;definition&gt;</phrase>, and 
						  <phrase
						  role="code">&lt;reference&nbsp;definition&gt;</phrase> production rules, see 
						  <ulink
						  url="D4LGCatalogElements-TableVariables-CommonCharacteristics.html"
						  type="xref">Common Characteristics</ulink>.</para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGTableExpressions.html" type="xref">Table
								Operators</ulink></para> 
					 <sect3 id="D4LGColumns"> 
						  <title><indexterm><primary>Columns</primary></indexterm><indexterm><primary>Tables</primary><secondary>Columns</secondary></indexterm>Columns</title>
						  
						  <para>Base table variables are defined in terms of the
								columns, or attributes, that make up the table structure. Each column has a
								name that is unique within the table variable, a data type which describes the
								legal values for this column, and possibly a default and column constraints.
								Each column also includes a 
								<phrase
								role="code">&lt;nilable&nbsp;definition&gt;</phrase>, which indicates whether
								or not the column is allowed to be 
								<ulink url="D4LGNilSemantics.html"
								type="link">nil</ulink>, or have no value.</para> 
						  <indexterm><primary>TableDee</primary></indexterm><indexterm><primary>TableDum</primary></indexterm>
						  
						  <para>Note that a table variable need not have any columns
								at all. There are exactly two table values with no columns: 
								<itemizedlist> 
									 <listitem> 
										  <para><phrase role="code"><emphasis
													 role="bold">table</emphasis> { }</phrase></para> 
										  <para>The table value with no columns and no
												rows. The system table 
												<phrase
												role="code">System.TableDum</phrase> is a shorthand for this table
												selector.</para> 
									 </listitem> 
									 <listitem> 
										  <para><phrase role="code"><emphasis
													 role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { }
													 }</phrase></para> 
										  <para>The table value with no columns and one
												row. The system table 
												<phrase
												role="code">System.TableDee</phrase> is a shorthand for this table
												selector.</para> 
									 </listitem> 
								</itemizedlist></para> 
						  <para>Column definitions within base table variable
								declarations in D4 have the following syntax: 
								<programlisting>&lt;column definition&gt; ::=
	&lt;column name&gt; : &lt;type specifier&gt;
		&lt;nilable definition&gt;
		["{"&lt;ne column definition item commalist&gt;"}"
		&lt;metadata&gt;
		
&lt;column definition item&gt; ::=
	&lt;default definition&gt; |
	&lt;constraint definition&gt; |
	&lt;nilable definition&gt;
    
&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;nilable definition&gt; ::=
	[[<emphasis role="bold">not</emphasis>] <emphasis role="bold">nil</emphasis>]</programlisting></para> 
						  <sect4 id="D4LGColumnDefault"> 
								<title><indexterm><primary>Column
												Defaults</primary></indexterm><indexterm><primary>Tables</primary><secondary>Column
												Default</secondary></indexterm>Column Default</title> 
								<para>Each column in a table variable may have an
									 associated default which is used to provide a value for the column if no value
									 is specified through a given modification statement. A column level default
									 will effectively override a scalar type level default.</para> 
								<para>Column default definitions in D4 have the
									 following syntax: 
									 <programlisting>&lt;default definition&gt; ::=
	<emphasis role="bold">default</emphasis> &lt;expression&gt; &lt;metadata&gt;

&lt;alter default definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;default definition&gt;) |
	(<emphasis role="bold">alter default</emphasis> [&lt;expression&gt;] &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop default</emphasis>)</programlisting></para> 
						  </sect4> 
						  <sect4 id="D4LGColumnConstraints"> 
								<title><indexterm><primary>Column
												Constraints</primary></indexterm><indexterm><primary>Tables</primary><secondary>Column
												Constraints</secondary></indexterm>Column Constraints</title> 
								<para>Each column in a table variable may have any
									 number of associated column constraints which are used to validate the data in
									 any given data modification statement. Note that a column constraint is merely
									 a special case of a row constraint, which is in turn a special case of a
									 database-wide integrity constraint.</para> 
								<para>If the constraint expression evaluates to nil,
									 the constraint is considered satisfied.</para> 
								<para>As with all constraints, the text of the error
									 message can be specified using metadata on the constraint. If the tag 
									 <phrase role="code"><ulink
										  url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
										  type="olinka">DAE.SimpleMessage</ulink></phrase> appears on the constraint, the
									 value of the tag will be used as the message of the error. If the tag 
									 <phrase role="code"><ulink
										  url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
										  type="olinka">DAE.Message</ulink></phrase> appears on the constraint, the value
									 of the tag is a D4 expression that is evaluated in the same context as the
									 validation. The expression is expected to return a value of type string that
									 will be the text of the error. If no custom message is provided, a generic
									 error will be given stating that the constraint has been violated. In either
									 case, the 
									 <ulink url="DUGP1ErrorsandWarnings.html"
									 type="olinka">severity</ulink> of the error given will be
									 <emphasis>User</emphasis>.</para> 
								<para>Column constraints are validated in addition to
									 scalar type level constraints.</para> 
								<para>Column constraint definitions in D4 have the
									 following syntax: 
									 <programlisting>&lt;constraint definition&gt; ::=
	<emphasis role="bold">constraint</emphasis> &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
								<para>Alter column constraint definitions in D4 have
									 the following syntax: 
									 <programlisting>&lt;alter constraint definition&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;constraint definition&gt;) |
	(<emphasis role="bold">alter constraint</emphasis> &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop constraint</emphasis> &lt;constraint name&gt;)</programlisting></para> 
								<para>The constraint expression must be boolean-valued,
									 
									 <ulink url="D4LGLanguageElements-Expressions.html"
									 type="link">functional</ulink> and 
									 <ulink url="D4LGLanguageElements-Expressions.html"
									 type="link">deterministic</ulink>. In addition, the constraint expression is
									 not allowed to reference global database state. The compiler enforces these
									 requirements. Within the constraint expression, the implicit variable 
									 <phrase role="code"><emphasis
										  role="bold">value</emphasis></phrase> is available which represents the value
									 being validated.</para> 
						  </sect4> 
					 </sect3> 
					 <sect3 id="D4LGExamples"> 
						  <title>Examples</title> 
						  <para>The following examples illustrate the use of the
								create table statement: 
								<programlisting><emphasis role="bold">create table</emphasis> Customer
{
	ID : Integer,
	Name : String,
	IsHappy : Boolean,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">create table</emphasis> CustomerPhone
{
	Customer_ID : Integer,
	PhoneType_ID : Integer { default 1 },
	PhoneNumber : String
	{	
		<emphasis role="bold">constraint</emphasis> PhoneLength Length(value) &gt;= 7
			<emphasis role="bold">tags</emphasis> { DAE.SimpleMessage = "Phone Number must be	at least 7 characters" }
	} <emphasis role="bold">tags</emphasis> { Frontend.Title = "Phone Number" },
	ke<emphasis role="bold"/>y  { Customer_ID, PhoneType_ID },
	<emphasis role="bold">reference</emphasis> PhoneCustomer { Customer_ID } <emphasis role="bold">references</emphasis> Customer { ID }
} <emphasis role="bold">tags</emphasis> { Frontend.Title = "Customer Phone" };</programlisting> </para> 
						  <para>The following example illustrates the use of the
								alter table statement: 
								<programlisting><emphasis role="bold">alter table</emphasis> CustomerPhone
{
	<emphasis role="bold">create column</emphasis> IsInternational : Boolean { default false },
	<emphasis role="bold">create order</emphasis> { PhoneNumber, PhoneType_ID }
} <emphasis role="bold">alter tags</emphasis> { alter Frontend.Title = "Customer Phone #" };</programlisting> </para> 
						  <para>The following example illustrates the use of the drop
								table statement: 
								<programlisting><emphasis role="bold">drop table</emphasis> CustomerPhone;</programlisting> </para> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-TableVariables-Views"> 
					 <title><indexterm><primary>Views</primary></indexterm><indexterm><primary>Table
									 Variables</primary><secondary>Views</secondary></indexterm><indexterm><primary>Create
									 View Statement</primary></indexterm><indexterm><primary>Alter View
									 Statement</primary></indexterm><indexterm><primary>Drop View
									 Statement</primary></indexterm>Views</title> 
					 <para>Views are derived relation variables, that is, they are
						  tables in the catalog that are defined in terms of an expression against other
						  tables or views.</para> 
					 <para>Views can be modified with DML statements so long as the
						  post-modification data satisfies the predicate of the view. The predicate of
						  the view is, loosely speaking, the meaning of the result and is inferred from
						  the defining expression of the view. For a discussion of updatability semantics
						  for each operator, see 
						  <ulink url="D4LGTableExpressions.html" type="xref">Table
								Operators</ulink>.</para> 
					 <para>The create view statement in D4 has the following syntax:
						  
						  <programlisting>&lt;create view statement&gt; ::= 
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">view</emphasis> &lt;view name&gt; 
		&lt;expression&gt; 
		["{"&lt;ne view definition item commalist&gt;"}"] 
		&lt;metadata&gt;
    
&lt;view name&gt; ::=
	&lt;qualified identifier&gt;

&lt;view definition item&gt; ::=
	&lt;row constraint definition&gt; |
	&lt;key definition&gt; |
	&lt;reference definition&gt; |
	&lt;order definition&gt;</programlisting></para> 
					 <para>The alter view statement in D4 has the following syntax: 
						  <programlisting>&lt;alter view statement&gt; ::=
	<emphasis role="bold">alter view</emphasis> &lt;view name&gt; 
		["{"&lt;alter view definition item commalist&gt;"}"
		&lt;alter metadata&gt;

&lt;alter view definition item&gt; ::=
	&lt;alter row constraint definition&gt; |
	&lt;alter key definition&gt; |
	&lt;alter reference definition&gt; |
	&lt;alter order definition&gt;</programlisting></para> 
					 <para>The drop view statement in D4 has the following syntax: 
						  <programlisting>&lt;drop view statement&gt; ::=
	<emphasis role="bold">drop view</emphasis> &lt;view name&gt;</programlisting></para> 
					 <para>These statements create, alter, and drop a view named 
						  <phrase role="code">&lt;view&nbsp;name&gt;</phrase> in the
						  catalog. The optional 
						  <phrase role="code"><emphasis
								role="bold">session</emphasis></phrase> keyword indicates that this view is
						  visible only within the session in which it was created. A session-specific
						  table will hide a global table with the same name.</para> 
					 <para>For a description of the 
						  <phrase role="code">&lt;key&nbsp;definition&gt;</phrase>, 
						  <phrase role="code">&lt;order&nbsp;definition&gt;</phrase>,
						  
						  <phrase
						  role="code">&lt;row&nbsp;constraint&nbsp;definition&gt;</phrase>, and 
						  <phrase
						  role="code">&lt;reference&nbsp;definition&gt;</phrase> production rules, see 
						  <ulink
						  url="D4LGCatalogElements-TableVariables-CommonCharacteristics.html"
						  type="xref">Common Characteristics</ulink>.</para> 
					 <para>Constraints and keys included in the definition of a view
						  become part of the definition of the view. For example, if a constraint is
						  included in the view declaration, it becomes a restriction in the view
						  definition. Note that the base table remains unaffected by this constraint, the
						  view simply excludes rows that violate the constraint, and a row that violates
						  the constraint cannot be inserted into the view, but can be inserted into the
						  base table.</para> 
					 <para>The following examples illustrate the use of the create
						  view statement: 
						  <programlisting><emphasis role="bold">create view</emphasis> HappyDog 
	Dog <emphasis role="bold">where</emphasis> Bones &gt; 15;

<emphasis role="bold">create view</emphasis> Labrador
	Dog 
	{ 
		<emphasis role="bold">constraint</emphasis> OnlyLabs	Species = "Lab"
	} <emphasis role="bold">tags</emphasis> { Frontend.Title = "Labs" };</programlisting> </para> 
					 <para>The following example illustrates the use of the alter
						  view statement to add a reference from a view: 
						  <programlisting><emphasis role="bold">alter view</emphasis> HappyDog { <emphasis role="bold">create reference</emphasis> HappyDog_Rainbow { Color } 
		<emphasis role="bold">references</emphasis> Rainbow { Color } };</programlisting> </para> 
					 <para>The following example illustrates the use of the drop
						  view statement: 
						  <programlisting><emphasis role="bold">drop view</emphasis> HappyDog;</programlisting> </para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Constraints"> 
				<title><indexterm><primary>Constraints</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Constraints</secondary></indexterm><indexterm><primary>Create
								Constraint Statement</primary></indexterm><indexterm><primary>Alter Constraint
								Statement</primary></indexterm><indexterm><primary>Drop Constraint
								Statement</primary></indexterm>Constraints</title> 
				<para>A <emphasis>constraint</emphasis> is a named boolean-valued
					 expression that must evaluate to true. If a data manipulation is attempted
					 which would violate the constraint, the modification is rejected. If the
					 constraint expression evaluates to nil, the constraint is considered
					 satisfied.</para> 
				<para>As with all constraints, the text of the error message can be
					 specified using metadata on the constraint. If the tag 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
						  type="olinka">DAE.SimpleMessage</ulink></phrase> appears on the constraint, the
					 value of the tag will be used as the message of the error. If the tag 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-MessageorSimpleMessage.html"
						  type="olinka">DAE.Message</ulink></phrase> appears on the constraint, the value
					 of the tag is a D4 expression that is evaluated in the same context as the
					 validation. The expression is expected to return a value of type string that
					 will be the text of the error. If no custom message is provided, a generic
					 error will be given stating that the constraint has been violated. In either
					 case, the 
					 <ulink url="DUGP1ErrorsandWarnings.html"
					 type="olinka">severity</ulink> of the error given will be
					 <emphasis>User</emphasis>.</para> 
				<para>The create constraint statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;create constraint statement&gt; ::=
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">constraint</emphasis> &lt;constraint name&gt; &lt;expression&gt; &lt;metadata&gt;
	
&lt;constraint name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The alter constraint statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;alter constraint statement&gt; ::=
	<emphasis role="bold">alter constraint</emphasis> &lt;constraint name&gt; [&lt;expression&gt;] &lt;alter metadata&gt;</programlisting></para> 
				<para>The drop constraint statement in D4 has the following syntax:
					 
					 <programlisting>&lt;drop constraint statement&gt; ::=
	<emphasis role="bold">drop constraint</emphasis> &lt;constraint name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a constraint named 
					 <phrase role="code">&lt;constraint&nbsp;name&gt;</phrase> in
					 the catalog. The optional 
					 <phrase role="code"><emphasis
						  role="bold">session</emphasis></phrase> keyword indicates that this constraint
					 is visible only within the session in which it was created. A session-specific
					 constraint will hide a global constraint with the same name.</para> 
				<para>The constraint expression is required to be boolean-valued, 
					 <ulink url="D4LGLanguageElements-Expressions.html"
					 type="link">functional</ulink>, and 
					 <ulink url="D4LGLanguageElements-Expressions.html"
					 type="link">deterministic</ulink>. The compiler enforces these
					 requirements.</para> 
				<para>The following example illustrates the use of the create
					 constraint statement. The given constraint enforces that all cats have at least
					 one life: 
					 <programlisting><emphasis role="bold">create constraint</emphasis> LivingCats
	<emphasis role="bold">not exists</emphasis> 
	( 
		(Cat <emphasis role="bold">where</emphasis> IsAlive) <emphasis role="bold">join</emphasis> 
		((Life <emphasis role="bold">group by</emphasis> { Cat_ID, ID } <emphasis role="bold">add</emphasis> { Count() Lives }) <emphasis role="bold">where</emphasis> Lives = 0) 
	);</programlisting> </para> 
				<para>The following example illustrates the use of the alter
					 constraint statement. The new constraint enforces that all cats have at most
					 nine lives: 
					 <programlisting><emphasis role="bold">alter constraint</emphasis> LivingCats
	<emphasis role="bold">not exists</emphasis> ((Life <emphasis role="bold">group by</emphasis> { Cat_ID } <emphasis role="bold">add</emphasis> { Count() Lives }) <emphasis role="bold">where</emphasis> Lives &gt; 9);</programlisting> </para> 
				<para>The following example illustrates the use of the drop
					 constraint statement: 
					 <programlisting><emphasis role="bold">drop constraint</emphasis> LivingCats;</programlisting> </para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-References"> 
				<title><indexterm><primary>References</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>References</secondary></indexterm><indexterm><primary>Create
								Reference Statement</primary></indexterm><indexterm><primary>Alter Reference
								Statement</primary></indexterm><indexterm><primary>Drop Reference
								Statement</primary></indexterm>References</title> 
				<para>A <emphasis>reference</emphasis> is a special case of a
					 database-wide integrity constraint. A reference constraint enforces
					 <emphasis>referential integrity</emphasis>. In other words, if a reference
					 constraint is defined from a table variable 
					 <phrase role="code">Source</phrase> to a table variable 
					 <phrase role="code">Target</phrase>, then if a row appears in 
					 <phrase role="code">Source</phrase>, it must have a matching
					 row in 
					 <phrase role="code">Target</phrase>. A reference constraint is
					 considered satisfied if all the values of the reference columns of the row in 
					 <phrase role="code">Source</phrase> are specials, or do not
					 have a value (are nil). The equivalent database-wide integrity constraint for a
					 given reference constraint is then: 
					 <programlisting>// Reference constraint from Source(SourceColumn) to Target(TargetColumn)
<emphasis role="bold">create constraint</emphasis> C 
	<emphasis role="bold">not exists</emphasis> 
	(
		(Source <emphasis role="bold">where not</emphasis>(IsSpecial(SourceColumn)) <emphasis role="bold">over</emphasis> { SourceColumn }) <emphasis role="bold">minus</emphasis> 
		(Target <emphasis role="bold">over</emphasis> { TargetColumn } <emphasis role="bold">rename</emphasis> { TargetColumn SourceColumn })
	);</programlisting></para> 
				<indexterm><primary>Require - Referential
						  Action</primary></indexterm><indexterm><primary>Cascade - Referential
						  Action</primary></indexterm><indexterm><primary>Clear - Referential
						  Action</primary></indexterm><indexterm><primary>Set - Referential
						  Action</primary></indexterm> 
				<indexterm><primary>Referential Actions</primary></indexterm> 
				<para>References may also include specifications for actions to be
					 taken when updates or deletes are made to the target table of the reference.
					 The following list summarizes these actions: 
					 <itemizedlist> 
						  <listitem> 
								<para>Require</para> 
								<para>The require action indicates that the update or
									 delete should be rejected if there are rows in the source table which reference
									 the rows being modified. If no action is specified, this is the default.</para>
								
						  </listitem> 
						  <listitem> 
								<para>Cascade</para> 
								<para>The cascade action indicates that the update or
									 delete should be cascaded to the rows of the source table which reference the
									 rows being modified. If the modification is an update, all rows referencing the
									 old value are updated to reference the new value. If the modification is a
									 delete, all rows referencing the deleted value are deleted.</para> 
						  </listitem> 
						  <listitem> 
								<para>Clear</para> 
								<para>The clear action indicates that rows in the
									 source table which reference the rows being modified should be set to the
									 special value for the scalar type of the column. The types for each column must
									 have one and only one special defined in order to use this update
									 action.</para> 
						  </listitem> 
						  <listitem> 
								<para>Set</para> 
								<para>The set action indicates that rows in the source
									 table which reference the rows being modified should be set to the given
									 expressions. Note that the values specified for these expressions must also
									 satisfy the reference constraint.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The create reference statement in D4 has the following
					 syntax: 
					 <programlisting>&lt;create reference statement&gt; ::=
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">reference</emphasis> &lt;reference name&gt;
		&lt;tablevar name&gt; "{"&lt;column name commalist&gt;"}" 
		&lt;references definition&gt;
		&lt;metadata&gt;

&lt;reference name&gt; ::=
	&lt;qualified identifier&gt;

&lt;tablevar name&gt; ::=
	&lt;qualified identifier&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;references definition&gt; ::=
	<emphasis role="bold">references</emphasis> &lt;tablevar name&gt; "{"&lt;column name commalist&gt;"}" 
	[<emphasis role="bold">update</emphasis> (<emphasis role="bold">require</emphasis> | <emphasis role="bold">cascade</emphasis> | <emphasis role="bold">clear</emphasis> | <emphasis role="bold">set</emphasis> "{"&lt;expression commalist&gt;"}")] 
	[<emphasis role="bold">delete</emphasis> (<emphasis role="bold">require</emphasis> | <emphasis role="bold">cascade</emphasis> | <emphasis role="bold">clear</emphasis> | <emphasis role="bold">set</emphasis> "{"&lt;expression commalist&gt;"}")]</programlisting></para> 
				<para>The alter reference statement in D4 has the following syntax:
					 
					 <programlisting>&lt;alter reference statement&gt; ::=
	<emphasis role="bold">alter reference</emphasis> &lt;reference name&gt; &lt;alter metadata&gt;</programlisting></para> 
				<para>The drop reference statement in D4 has the following syntax: 
					 <programlisting>&lt;drop reference statement&gt; ::=
	<emphasis role="bold">drop reference</emphasis> &lt;reference name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a reference named 
					 <phrase role="code">&lt;reference&nbsp;name&gt;</phrase> in the
					 catalog. The optional 
					 <phrase role="code"><emphasis
						  role="bold">session</emphasis></phrase> keyword indicates that this reference
					 is visible only within the session in which it was created. A session-specific
					 reference will hide a global reference with the same name.</para> 
				<para>The target column names of a reference must form a key in the
					 target table variable. The source column names of a reference may or may not
					 form a key in the source table variable. This means there are two combinations
					 for references, key-to-key references, and key-to-non-key references. Depending
					 on whether a reference is viewed from the source or target table variable, this
					 gives rise to four distinct types of references: 
					 <indexterm><primary>Reference Types</primary></indexterm> 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Extension
										  References</primary></indexterm> 
								<para>Extension</para> 
								<para>An extension reference is one for which the
									 columns of the reference form a key in both the source and target tables, and
									 the reference is viewed from the target table. This is a one-to-zero-or-one
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Parent
										  References</primary></indexterm> 
								<para>Parent</para> 
								<para>A parent reference is one for which the columns
									 of the reference form a key in both the source and target tables, and the
									 reference is viewed from the source table. This is a one-to-one
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Detail
										  References</primary></indexterm> 
								<para>Detail</para> 
								<para>A detail reference is one for which the columns
									 of the reference form a key in the target table, but not the source table, and
									 the reference is viewed from the target table. This is a one-to-many
									 relationship.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Lookup
										  References</primary></indexterm> 
								<para>Lookup</para> 
								<para>A lookup reference is one for which the columns
									 of the reference form a key in the target table, but not the source table, and
									 the reference is viewed from the source table. This is a one-to-one
									 relationship.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>This and other information is used by the Dataphor Frontend
					 to determine how best to present and manipulate the data model. The Frontend
					 dynamically derives the appropriate interface based on the relationships
					 described by references.</para> 
				<para>Note that references are allowed to target any number of
					 columns in the target table variable, as long as the set of target columns
					 completely includes at least one key of the target table variable.</para> 
				<para>Reference definitions are allowed to reference derived table
					 variables, not just base table variables. Note however that if the reference
					 originates in or targets a derived table variable, the reference will be
					 enforced with a database-wide constraint rather than a transition constraint
					 defined in terms of a single row. This means that any operation that affects
					 any table variable involved in the constraint (including table variables
					 referenced by the derived table variable definitions, recursively) will cause
					 the entire constraint to be checked. If the cardinality of either table
					 variable is expected to be large, consider rewriting the reference constraint
					 as a set of transition constraints on the table variables involved. The
					 reference constraint can still be defined using the 
					 <phrase role="code">Storage.Enforced</phrase> tag to prevent
					 validation in order to allow the Frontend to take advantage of the
					 information.</para> 
				<indexterm><primary>Reference Inference</primary></indexterm> 
				<para>References are also derived for table expressions through a
					 process called <emphasis>reference inference</emphasis>. This process is part
					 of <emphasis>type inference</emphasis> and means that not only are references
					 known for the table variables on which they are declared, but expressions that
					 reference those table variables as well. This process becomes exteremely
					 important when a general solution to the problem of user-interface derivation
					 is approached. The solution provided by the Dataphor Server through reference
					 inference is one of the main reasons for the advanced user-interface derivation
					 capabilities of the Frontend.</para> 
				<para>The following example creates a referential integrity
					 constraint between the 
					 <phrase role="code">Dog</phrase> and 
					 <phrase role="code">Owner</phrase> tables. This constraint
					 ensures that there can be no row in the 
					 <phrase role="code">Dog</phrase> table for which the value in
					 the 
					 <phrase role="code">Owner_ID</phrase> column does not appear in
					 the 
					 <phrase role="code">ID</phrase> column of the 
					 <phrase role="code">Owner</phrase> table. 
					 <programlisting><emphasis role="bold">create reference</emphasis> Dog_Owner Dog { Owner_ID } <emphasis role="bold">references</emphasis>	Owner { ID };</programlisting> </para> 
				<para>The following example alters the metadata of the 
					 <phrase role="code">Dog_Owner</phrase> reference. Only the
					 metadata of a reference may be altered. In order to change another aspect of
					 the reference constraint, it must be dropped and re-created. 
					 <programlisting><emphasis role="bold">alter reference</emphasis> Dog_Owner
	<emphasis role="bold">alter tags</emphasis> { <emphasis role="bold">create</emphasis> Catalog.Comment = "Dog - Dog Owners", <emphasis role="bold">create</emphasis> Frontend.Exposed = "true" };</programlisting> </para> 
				<para>The following examples drop the 
					 <phrase role="code">Dog_Owner</phrase> reference: 
					 <programlisting>// drop the constraint using the drop reference syntax
<emphasis role="bold">drop reference</emphasis> Dog_Owner; 

// drop the constraint by altering the source table variable
<emphasis role="bold">alter table</emphasis> Dog { <emphasis role="bold">drop reference</emphasis> Dog_Owner }; </programlisting> </para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Operators"> 
				<title><indexterm><primary>Operators</primary><secondary>As Catalog
								Elements</secondary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Operators</secondary></indexterm><indexterm><primary>Operand</primary></indexterm>Operators</title>
				
				<para>An <emphasis>operator</emphasis> is a pre-compiled piece of
					 D4 code which optionally takes as operands a list of values, also called
					 <emphasis>inputs</emphasis>, or <emphasis>parameters</emphasis>, and optionally
					 returns a value of some type, also called <emphasis>output</emphasis>. For a
					 description of operators as a language element in D4, refer to the Operators
					 section of the Language Elements section of this guide.</para> 
				<para>Each operator is allowed to take any number of
					 <emphasis>operands</emphasis>. Each operand must have a unique name, and a data
					 type. Each operand is available within the block of the operator as a variable
					 with the same name and data type of the operand. Additionally, each operand
					 includes a <emphasis>modifier</emphasis> which tells the compiler how to handle
					 values passed as the argument for this operand. The following table lists the
					 available modifiers: 
					 <itemizedlist> 
						  <indexterm><primary>Parameter
									 Modifiers</primary></indexterm><indexterm><primary>Modifiers</primary><secondary>Parameter</secondary><see>Parameter
									 Modifiers</see></indexterm> 
						  <listitem> 
								<indexterm><primary>In Parameter
										  Modifier</primary></indexterm><indexterm><primary>Pass-By-Value</primary></indexterm>
								
								<para>in</para> 
								<para>Indicates that the value passed as an argument to
									 this operand is copied into the variable representing this operand within the
									 operator. This is known as <emphasis>pass-by-value</emphasis>. If no modifier
									 is specified for the operand, the operand is initially marked 
									 <phrase role="code">in</phrase> as a default. This
									 may change, as described in the next modifier.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary><phrase role="code"><emphasis
												role="bold">const</emphasis></phrase> Parameter
										  Modifier</primary></indexterm><indexterm><primary>Pass-By-Reference</primary></indexterm>
								
								<para><phrase role="code"><emphasis
										  role="bold">const</emphasis></phrase></para> 
								<para>Indicates that the variable representing this
									 operand may not be assigned to within the operator block. This is known as
									 <emphasis>pass-by-reference</emphasis> with the added restriction that the
									 variable is read only within the operator. If the compiler detects that the
									 variable for a given operand is unaffected within the operator block, it will
									 automatically mark the operand 
									 <phrase role="code">const</phrase> as an
									 optimization.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary><phrase role="code"><emphasis
												role="bold">var</emphasis></phrase> Parameter Modifier</primary></indexterm> 
								<para><phrase role="code"><emphasis
										  role="bold">var</emphasis></phrase></para> 
								<para>Indicates that only variables may be passed as
									 arguments to this operand, and that the affects of assignment to the variable
									 representing this operand within the operator block will affect the variable
									 passed as the argument. This is known as
									 <emphasis>pass-by-reference</emphasis>. If an operand is marked 
									 <phrase role="code"><emphasis
										  role="bold">var</emphasis></phrase>, the argument in a call must also be marked
									 
									 <phrase role="code"><emphasis
										  role="bold">var</emphasis></phrase> in order to be passed to the operand. In
									 other words, the modifier is part of the signature of the operator and affects
									 the operator resolution process.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<indexterm><primary>Signature</primary></indexterm> 
				<para>The types of the operands to the operator, together with the
					 modifiers, if any, are called the <emphasis>signature</emphasis> of the
					 operator. The signature is used to resolve which operator has been called in a
					 given invocation. This process is called operator resolution.</para> 
				<para>There are two types of operators in D4, 
					 <ulink url="D4LGCatalogElements-Operators-Operators.html"
					 type="link">standard operators</ulink>, and 
					 <ulink
					 url="D4LGCatalogElements-Operators-AggregateOperators.html"
					 type="link">aggregate operators</ulink>. Aggregate operators are
					 special-purpose operators which have certain restrictions on the operands and
					 return values allowed in the signature, and a specialized calling convention
					 which allows them to be used efficiently within aggregate operations in
					 D4.</para> 
				<para>When invoked within an application transaction, operators may
					 be translated into the application transaction. By default, operators are
					 translated into an application transaction if they are not host-implemented,
					 access global state, and are not functional. To change the default behavior,
					 use the 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-ShouldTranslate.html"
						  type="olinka">DAE.ShouldTranslate</ulink></phrase> tag on the create operator
					 statement. Note also that if the operator is being invoked as an event handler,
					 the attach statement may also specify a translation behavior using the 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-ShouldTranslate.html"
						  type="olinka">DAE.ShouldTranslate</ulink></phrase> tag.</para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="D4LGLanguageElements-Operators.html"
					 type="link">Language Elements, Operators</ulink></para> 
				<sect2 id="D4LGCatalogElements-Operators-OperatorResolution"> 
					 <title><indexterm><primary>Operator
									 Resolution</primary></indexterm><indexterm><primary>Operators</primary><secondary>Operator
									 Resolution</secondary></indexterm>Operator Resolution</title> 
					 <para>Operator resolution in D4 is the process of resolving a
						  given operator invocation to the implementation of an actual operator in the
						  catalog. Each operator name in D4 is allowed to have any number of signatures
						  specified. Each of these is called an <emphasis>overload</emphasis>, and allows
						  the same operator name to be invoked with different numbers and types of
						  arguments. This allows for more flexible operator definition within the
						  language.</para> 
					 <para>The inputs to the operator resolution process are the
						  name of the operator as specified in the invocation, and the
						  <emphasis>invocation signature</emphasis>, or the number and types of each
						  argument, together with any modifiers specified in the invocation. Note that
						  the operator name in the invocation may be the unqualified name.</para> 
					 <para><indexterm><primary>Assignment-Compatibility</primary></indexterm>Operator
						  resolution is based on the notion of
						  <emphasis>assignment-compatiblity</emphasis>. A given type 
						  <phrase role="code">Ts</phrase> is said to be
						  assignment-compatible with type 
						  <phrase role="code">Tt</phrase> if and only if any of the
						  following conditions are true: 
						  <itemizedlist> 
								<listitem> 
									 <para><phrase role="code">Ts</phrase> and 
										  <phrase role="code">Tt</phrase> are the same
										  type.</para> 
								</listitem> 
								<listitem> 
									 <para><phrase role="code">Tt</phrase> is a generic
										  type matching the type category of 
										  <phrase role="code">Ts</phrase></para> 
								</listitem> 
								<listitem> 
									 <para>An implicit conversion path from 
										  <phrase role="code">Ts</phrase> to 
										  <phrase role="code">Tt</phrase> exists.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Note that if the 
						  <phrase role="code"><emphasis
								role="bold">var</emphasis></phrase> modifier is specified for a given
						  parameter, it must also be specified in the argument, and implicit conversions
						  are not allowed.</para> 
					 <para>The process begins by constructing a name resolution
						  path, and performing a standard name resolution on the operator name. All
						  potential name resolutions are considered, and searched for a compatible
						  signature.</para> 
					 <para>The signature list for each potential name resolution is
						  searched for a compatible signature. Only signatures with the same number of
						  arguments are considered. If the type of each argument in the invocation
						  signature is assignment-compatible with the type of the parameter in order,
						  then the signature is compatible.</para> 
					 <para>The compiler will favor widening conversions when
						  searching for conversion paths from the type of the argument to the type of the
						  parameter. The signature with the least number of conversions required is
						  selected as the best match. If multiple signature conversion paths are found
						  with the same number of conversions required, the least narrowing conversion
						  path is used. If multiple signature conversion paths have the same number of
						  narrowing conversions, the call is considered ambiguous, and an error is
						  returned.</para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-Operators-Operators"> 
					 <title><indexterm><primary>Create Operator
									 Statement</primary></indexterm><indexterm><primary>Alter Operator
									 Statement</primary></indexterm><indexterm><primary>Drop Operator
									 Statement</primary></indexterm>Creating Operators</title> 
					 <para>The create operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;create operator statement&gt; ::=
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">operator</emphasis>
		&lt;operator name&gt;
		"("&lt;formal parameter commalist&gt;")"
		[: &lt;type specifier&gt;]
		(&lt;class definition&gt; | &lt;block&gt;)
		&lt;metadata&gt;
		
&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;

&lt;formal parameter&gt; ::=
	[&lt;modifier&gt;] &lt;named type specifier&gt;

&lt;modifier&gt; ::=
	[<emphasis role="bold">var</emphasis> | <emphasis role="bold">const</emphasis>]

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The alter operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;alter operator statement&gt; ::=
	<emphasis role="bold">alter operator</emphasis> &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"
		[(&lt;alter class definition&gt; | &lt;block&gt;)]
		&lt;alter metadata&gt;

&lt;formal parameter specifier&gt; ::=
	[&lt;modifier&gt;] &lt;type specifier&gt;</programlisting></para> 
					 <para>The drop operator statement in D4 has the following
						  syntax: 
						  <programlisting>&lt;drop operator statement&gt; ::=
	<emphasis role="bold">drop operator</emphasis> &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"</programlisting></para> 
					 <para>These statements create, alter, and drop an operator
						  named 
						  <phrase role="code">&lt;operator&nbsp;name&gt;</phrase>
						  with operands given by 
						  <phrase
						  role="code">&lt;formal&nbsp;parameter&nbsp;specifier&nbsp;commalist&gt;</phrase>
						  in the catalog. The operator optionally returns a value of the type given by 
						  <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>.
						  The implementation of the operator is specified by either the 
						  <phrase role="code">&lt;class&nbsp;definition&gt;</phrase>,
						  in which case the operator is a <emphasis>host-implemented</emphasis> operator,
						  or the 
						  <phrase role="code">&lt;block&gt;</phrase>, in which case
						  the operator is a sequence of compiled D4 statements. The optional 
						  <phrase role="code"><emphasis
								role="bold">session</emphasis></phrase> keyword indicates that this operator is
						  visible only within the session in which it was created. A session-specific
						  operator will hide a global operator with the same name and signature.</para> 
					 <para>For a complete description of the 
						  <phrase role="code">&lt;block&gt;</phrase> production rule,
						  refer to 
						  <ulink url="D4LGImperativeStatements.html"
						  type="xref">Imperative Statements</ulink>.</para> 
					 <para>The following example illustrates the use of the create
						  operator statement: 
						  <programlisting><emphasis role="bold">create operator</emphasis> Add(A : Integer, B : Integer) : Integer
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := A + B;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <para>The following example illustrates the use of the alter
						  operator statement: 
						  <programlisting><emphasis role="bold">alter operator</emphasis> Add(Integer, Integer)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer;
	<emphasis role="bold">result</emphasis> := A;
	<emphasis role="bold">for</emphasis> I := 1 <emphasis role="bold">to</emphasis> B <emphasis role="bold">do</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">result</emphasis> + 1;
	<emphasis role="bold">for</emphasis> I := -1 <emphasis role="bold">downto</emphasis> B <emphasis role="bold">do</emphasis>
		<emphasis role="bold">result</emphasis> := <emphasis role="bold">result</emphasis> - 1;
end;</programlisting></para> 
					 <para>The following example illustrates the use of the drop
						  operator statement: 
						  <programlisting><emphasis role="bold">drop operator</emphasis> Add(Integer, Integer);</programlisting> </para> 
				</sect2> 
				<sect2 id="D4LGCatalogElements-Operators-AggregateOperators"> 
					 <title><indexterm><primary>Aggregate
									 Operators</primary></indexterm><indexterm><primary>Operators</primary><secondary>Aggregate
									 Operators</secondary></indexterm><indexterm><primary>Create Aggregate Operator
									 Statement</primary></indexterm><indexterm><primary>Alter Aggregate Operator
									 Statement</primary></indexterm><indexterm><primary>Drop Aggregate Operator
									 Statement</primary></indexterm>Aggregate Operators</title> 
					 <para>Aggregate operators make use of a specialized calling
						  convention which can be used efficiently to implement aggregation in the
						  Dataphor Server. If operands are defined they must not be marked with a
						  modifier and the data type of the operands must correspond to the types of the
						  values to be aggregated. The operator must return a value of some type, not
						  necessarily the same type as the operands. For example, a 
						  <phrase role="code">Sum</phrase> aggregate operator for
						  integers must have the heading: 
						  <programlisting><emphasis role="bold">aggregate operator</emphasis> Sum(AValue : System.Integer) : System.Integer</programlisting></para> 
					 <para><indexterm><primary><phrase role="code"><emphasis
										  role="bold">initialization</emphasis></phrase>
									 Block</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
										  role="bold">aggregation</emphasis></phrase>
									 Block</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
										  role="bold">finalization</emphasis></phrase>
									 Block</primary></indexterm>Aggregate operators have three blocks,
						  <emphasis>initialization</emphasis>, <emphasis>finalization</emphasis>, and
						  <emphasis>aggregation</emphasis>. Each section is allowed to be a
						  host-implemented operator, or a D4 statement block.</para> 
					 <para>The initialization section is called once before
						  aggregation begins. This allows the operator to set up any local variables that
						  will be used to compute the aggregation.</para> 
					 <para>The aggregation section is called once for each row in
						  the table value being aggregated. The value for the target aggregation column
						  for the row is available in this section as the value of the variable
						  representing the single operand defined for the aggregate operator.</para> 
					 <para>The finalization section is called once after all the
						  rows have been processed by the aggregation section. This allows the operator
						  to perform any final computations required to compute the aggregate.</para> 
					 <para><indexterm><primary>Order-dependent</primary></indexterm><indexterm><primary>Aggregate
									 Operators</primary><secondary>Order-dependent</secondary></indexterm>Because
						  the order of aggregation within an aggregate operator may produce different
						  results, depending on the aggregate operator, the D4 language allows aggregate
						  operators to be marked as <emphasis>order-dependent</emphasis>. This indicates
						  to the compiler that the aggregate operator will in general produce different
						  results for different orderings of the input to the operator. For example, the 
						  <phrase role="code">Concat</phrase> aggregate operator will
						  produce entirely different results, depending on the order in which the rows of
						  the input are processed.</para> 
					 <para>To specify whether or not an aggregate operator is
						  order-dependent, use the 
						  <phrase role="code">DAE.IsOrderDependent</phrase> tag in
						  the metadata for the operator. If an aggregate operator is specified as
						  order-dependent, the compiler will issue a warning if the input to that
						  aggregate operator is not well-ordered (if the order of the rows in the input
						  is not ordered by at least a key).</para> 
					 <para>The create aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;create aggregate operator statement&gt; ::=
	<emphasis role="bold">create</emphasis> [<emphasis role="bold">session</emphasis>] <emphasis role="bold">aggregate</emphasis> <emphasis role="bold">operator</emphasis>
		&lt;operator name&gt;
		"("&lt;formal parameter commalist&gt;")"
		: &lt;type specifier&gt;
		<emphasis role="bold">initialization</emphasis> (&lt;class definition&gt; | &lt;block&gt;)
		<emphasis role="bold">aggregation</emphasis> (&lt;class definition&gt; | &lt;block&gt;)
		<emphasis role="bold">finalization</emphasis> (&lt;class definition&gt; | &lt;block&gt;)
		&lt;metadata&gt;

&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;

&lt;named type specifier&gt; ::=
	&lt;qualified identifier&gt; : &lt;type specifier&gt;</programlisting></para> 
					 <para>The alter aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;alter aggregate operator statement&gt; ::=
	<emphasis role="bold">alter aggregate operator</emphasis> &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"
		[<emphasis role="bold">initialization</emphasis> (&lt;alter class definition&gt; | &lt;block&gt;)]
		[<emphasis role="bold">aggregation</emphasis> (&lt;alter class definition&gt; | &lt;block&gt;)]
		[<emphasis role="bold">finalization</emphasis> (&lt;alter class definition&gt; | &lt;block&gt;)]
		&lt;alter metadata&gt;

&lt;formal parameter specifier&gt; ::=
	[&lt;modifier&gt;] &lt;type specifier&gt;</programlisting></para> 
					 <para>The drop aggregate operator statement in D4 has the
						  following syntax: 
						  <programlisting>&lt;drop aggregate operator statement&gt; ::=
	<emphasis role="bold">drop aggregate operator</emphasis> &lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"</programlisting></para> 
					 <para>These statements create, alter, and drop an aggregate
						  operator named 
						  <phrase role="code">&lt;operator&nbsp;name&gt;</phrase>
						  with operands given by 
						  <phrase
						  role="code">&lt;formal&nbsp;parameter&nbsp;specifier&nbsp;commalist&gt;</phrase>
						  in the catalog. The aggregate operator must return a value of the type given by
						  
						  <phrase role="code">&lt;type&nbsp;specifier&gt;</phrase>.
						  The implementation of each section is specified by either the 
						  <phrase role="code">&lt;class&nbsp;definition&gt;</phrase>
						  in which case the section is <emphasis>host-implemented</emphasis>, or the 
						  <phrase role="code">&lt;block&gt;</phrase>, in which case
						  the section is a sequence of compiled D4 statements. The optional 
						  <phrase role="code"><emphasis
								role="bold">session</emphasis></phrase> keyword indicates that this aggregate
						  operator is visible only within the session in which it was created. A
						  session-specific aggregate operator will hide a global aggregate operator with
						  the same name and signature.</para> 
					 <para>For a complete description of the 
						  <phrase role="code">&lt;block&gt;</phrase> production rule,
						  refer to 
						  <ulink url="D4LGImperativeStatements.html"
						  type="xref">Imperative Statements</ulink>.</para> 
					 <para>Aggregate operators can be invoked in one of two ways.
						  First, they can be invoked as part of the 
						  <phrase role="code"><emphasis
								role="bold">add</emphasis></phrase> clause of an 
						  <phrase role="code"><emphasis
								role="bold">group</emphasis></phrase> table operator. Second, they invoked
						  stand-alone a scalar aggregate operator invocation. For a complete description
						  of the 
						  <phrase role="code"><emphasis
								role="bold">group</emphasis></phrase> table operator, refer to the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Aggregate.html"
								type="link">group</ulink></emphasis></phrase> discussion in this guide.</para> 
					 <para>Outside the context of a 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Aggregate.html"
								type="link">group</ulink></emphasis></phrase> operator, aggregate operators
						  must be called using an scalar aggregate operator invocation. For example, to
						  compute the sum of the values for a column 
						  <phrase role="code">Data</phrase> of some table 
						  <phrase role="code">Integers</phrase>, the following
						  expression would be used: 
						  <programlisting>Sum(Data <emphasis role="bold">from</emphasis> Integers)</programlisting></para> 
					 <para>Note that multiple columns may be specified by enclosing
						  the column list in braces (<phrase role="code">{ }</phrase>). The aggregate
						  operator is resolved based on the type of the column, or columns, being
						  aggregated. If the operator resolved is not an aggregate operator, the compiler
						  will raise an error.</para> 
					 <para>For a complete description of aggregate operator
						  invocation syntax, refer to the 
						  <ulink url="D4LGOperatorInvocation.html"
						  type="link">operator invocations</ulink> discussion in this guide.</para> 
					 <para>The following example creats an aggregate operator, and
						  uses it in some simple aggregate expressions: 
						  <programlisting>// aggregate operators
<emphasis role="bold">create aggregate operator</emphasis> StdDev(AValue : Decimal) : Decimal
	<emphasis role="bold">initialization</emphasis>
		<emphasis role="bold">begin</emphasis>
			<emphasis role="bold">var</emphasis> LSum : Decimal := 0d;
			<emphasis role="bold">var</emphasis> LSumOfSquares : Decimal := 0d;
			<emphasis role="bold">var</emphasis> LCount : Integer := 0;
			<emphasis role="bold">result</emphasis> := 0d;
		<emphasis role="bold">end</emphasis>
	<emphasis role="bold">aggregation</emphasis>
		<emphasis role="bold">begin</emphasis>
			LSum := LSum + AValue;
			LSumOfSquares := LSumOfSquares + (AValue ** 2d);
			LCount := LCount + 1;
		<emphasis role="bold">end</emphasis>
	<emphasis role="bold">finalization</emphasis>
		<emphasis role="bold">begin</emphasis>
			<emphasis role="bold">result</emphasis> := 
				(
					(
						(LSumOfSquares - ((LSum ** 2d) / ToDecimal(LCount))) / 
						ToDecimal(LCount - 1)
					) ** 
					0.5d
				);
		<emphasis role="bold">end</emphasis>;
		
// Invocation through the table aggregate operator
<emphasis role="bold">select</emphasis>
	<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 0.1d DecimalValue }, 
		<emphasis role="bold">row</emphasis> { 0.2d }, <emphasis role="bold">row</emphasis> { 0.3d }, 
		<emphasis role="bold">row</emphasis> { 0.4d }, <emphasis role="bold">row</emphasis> { 0.5d } }
		<emphasis role="bold">group</emphasis> <emphasis role="bold">add</emphasis> { StdDev(DecimalValue) Value_StdDev };

// Stand-alone invocation
<emphasis role="bold">select</emphasis> 
	StdDev
	(
		DecimalValue <emphasis role="bold">from</emphasis> 
		<emphasis role="bold">table</emphasis> 
		{ 
			<emphasis role="bold">row</emphasis> { 0.1d DecimalValue }, 
			<emphasis role="bold">row</emphasis> { 0.2d } 
		}
	);</programlisting></para> 
					 <bridgehead renderas="sect3">See Also</bridgehead> 
					 <para> 
						  <ulink url="D4LGTableExpressions-Aggregate.html"
						  type="link">Aggregate</ulink></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Devices"> 
				<title><indexterm><primary>Devices</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Devices</secondary></indexterm><indexterm><primary>Create
								Device Statement</primary></indexterm><indexterm><primary>Alter Device
								Statement</primary></indexterm><indexterm><primary>Drop Device
								Statement</primary></indexterm>Devices</title> 
				<para>All data storage in the Dataphor Server is abstracted through
					 the concept of a Device. The Dataphor Server not only uses devices to store
					 data, it also offloads any query processing that is supported by the device.
					 Because each data source is capable of different types of data manipulation,
					 the internal device interface provides a mechanism for dynamically determining
					 these capabilities for any given expression. The Dataphor Server then uses this
					 information to distribute query processing among the different devices involved
					 in the request. When the device on which the data resides cannot perform a
					 particular operation, the query processor takes over and performs the query
					 processing internally. The result is seamless access to disparate data
					 sources.</para> 
				<para>The storage systems represented by each device have their own
					 internal catalog, which must be synchronized with the Dataphor Server in order
					 to be utilized within D4. This process is known as <emphasis>schema
					 reconciliation</emphasis>. Settings on each device control how this process
					 occurs.</para> 
				<para>Each device may have any number of associated type and
					 operator mappings which control how catalog objects in the Dataphor Server map
					 into the device.</para> 
				<para>Each device may also have a mapping for each user in the
					 Dataphor Server called a <emphasis>device user</emphasis>. This mapping
					 contains the credentials to be used when communicating with the storage system
					 represented by the device, as well as any user-specific settings for the
					 device. These mappings are created through the use of system library
					 operators.</para> 
				<para>For a complete discussion of all these topics, refer to the 
					 <ulink url="DDGStorageIntegrationArchitecture.html"
					 type="olinka"><citetitle>Storage Integration Architecture</citetitle></ulink>
					 chapter in the Physical Realization part of this guide.</para> 
				<para>The create device statement in D4 has the following syntax: 
					 <programlisting>&lt;create device statement&gt; ::=
	<emphasis role="bold">create device</emphasis> &lt;device name&gt;
		["{"&lt;device map item commalist&gt;"}"]
		&lt;reconciliation settings&gt;
		&lt;class definition&gt;
		&lt;metadata&gt;

&lt;device name&gt; ::=
	&lt;qualified identifier&gt;
		
&lt;device map item&gt; ::=
	&lt;device scalar type map&gt; |
	&lt;device operator map&gt;

&lt;device scalar type map&gt; ::=
	<emphasis role="bold">type</emphasis> &lt;scalar type name&gt; &lt;class definition&gt;

&lt;scalar type name&gt; ::=
	&lt;qualified identifier&gt;

&lt;device operator map&gt; ::=
	<emphasis role="bold">operator</emphasis> &lt;operator specifier&gt; &lt;class definition&gt;

&lt;operator specifier&gt; ::=
	&lt;operator name&gt;"("&lt;formal parameter specifier commalist&gt;")"

&lt;reconciliation settings&gt; ::=
	[<emphasis role="bold">reconciliation</emphasis> "{"&lt;reconciliation settings item commalist&gt;"}"]
	
&lt;reconciliation settings item&gt; ::=
	&lt;reconciliation mode definition&gt; |
	&lt;reconciliation master&gt;
	
&lt;reconciliation mode definition&gt; ::=
	<emphasis role="bold">mode</emphasis> = "{"&lt;reconciliation mode commalist&gt;"}"
	
&lt;reconciliation mode&gt; ::=
	none |
	startup |
	command |
	automatic
	
&lt;reconciliation master&gt; ::=
	<emphasis role="bold">master</emphasis> = (server | device | both)</programlisting></para> 
				<para>The alter device statement in D4 has the following syntax: 
					 <programlisting>&lt;alter device statement&gt; ::=
	<emphasis role="bold">alter device</emphasis> &lt;device name&gt; 
		["{"&lt;alter device map item commalist&gt;"}"]
		&lt;alter reconciliation settings&gt;
		&lt;alter class definition&gt; 
		&lt;alter metadata&gt;

&lt;alter reconciliation settings&gt; ::=
	[<emphasis role="bold">alter reconciliation</emphasis> "{"&lt;reconciliation settings item commalist&gt;"}"]

&lt;alter device map item&gt; ::=
	&lt;alter device scalar type map&gt; |
	&lt;alter device operator map&gt;
	
&lt;alter device scalar type map&gt; ::=
	(<emphasis role="bold">create</emphasis> &lt;device scalar type map&gt;) | 
	(<emphasis role="bold">alter type</emphasis> &lt;scalar type name&gt; &lt;alter class definition&gt;) | 
	(<emphasis role="bold">drop type</emphasis> &lt;scalar type name&gt;)
	
&lt;alter device operator map&gt; ::=
	<emphasis role="bold">create</emphasis> &lt;device operator map&gt; |
	<emphasis role="bold">alter operator</emphasis> &lt;operator specifier&gt; &lt;alter class definition&gt; |
	<emphasis role="bold">drop operator</emphasis> &lt;operator specifier&gt;</programlisting></para> 
				<para>The drop device statement in D4 has the following syntax: 
					 <programlisting>&lt;drop device statement&gt; ::=
	<emphasis role="bold">drop device</emphasis> &lt;device name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop a device named 
					 <phrase role="code">&lt;device&nbsp;name&gt;</phrase> in the
					 catalog.</para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-EventHandlers"> 
				<title><indexterm><primary>Event
								Handlers</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Event
								Handlers</secondary></indexterm><indexterm><primary>Attach
								Statement</primary></indexterm><indexterm><primary>Detach
								Statement</primary></indexterm>Event Handlers</title> 
				<para>Event handlers are operators that have been attached to
					 specific events in the system such as data modification, or proposable
					 interface calls. Event handlers can be attached to events triggered at the
					 scalar type level, the column level, or the table variable level. Each event
					 has an associated signature which is used to invoke the attached operator. The
					 signature of a handler must match the signature of the event to which it is
					 attached. </para> 
				<para>The following lists detail the available events for different
					 types of catalog objects:<indexterm><primary>Event
								Handlers</primary><secondary>Signatures</secondary></indexterm></para> 
				<para>Table Variable Level Events: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Before Insert
										  Event</primary></indexterm> 
								<para>Before Insert</para> 
								<para>Occurs before the insert of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">var row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var</emphasis> Boolean)</programlisting>The first parameter is set to the row value that is about to
									 be inserted. Changes made to the value of this parameter within the body of the
									 handler will affect the actual row being inserted. The second parameter
									 indicates whether or not to perform the insert. By default, the value of this
									 parameter is true, setting it to false within the body of the handler will stop
									 propagation of the insert.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>After Insert
										  Event</primary></indexterm> 
								<para>After Insert</para> 
								<para>Occurs after the insert of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; })</programlisting>The first parameter is set to the row value that was inserted.
									 Note that if the handler is deferred, it will be invoked at transaction commit
									 time, rather than immediately after the insert occurs.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Before Update
										  Event</primary></indexterm> 
								<para>Before Update</para> 
								<para>Occurs before the update of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var</emphasis> Boolean)</programlisting>The first parameter is set to the old row value being updated.
									 The second parameter is set to the new row value being updated. Changes made to
									 the value of the new parameter within the body of the handler will affect the
									 actual row being updated. The third parameter indicates whether or not to
									 perform the update. By default, the value of this parameter is true, setting it
									 to false within the body of the handler will stop propagation of the
									 update.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>After Update
										  Event</primary></indexterm> 
								<para>After Update</para> 
								<para>Occurs after the update of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">const row</emphasis> { &lt;heading&gt; })</programlisting>The first parameter is set to the old row value that was
									 updated. The second parameter is set to the new row value that was updated.
									 Note that if the handler is deferred, it will be invoked at transaction commit
									 time, rather than immediately after the update occurs.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Before Delete
										  Event</primary></indexterm> 
								<para>Before Delete</para> 
								<para>Occurs before the delete of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var</emphasis> Boolean)</programlisting>The first parameter is set to the row value that is being
									 deleted. The second parameter indicates whether or not to perform the delete.
									 By default, the value of this parameter is true, setting it to false within the
									 body of the handler will stop propagation of the delete.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>After Delete
										  Event</primary></indexterm> 
								<para>After Delete</para> 
								<para>Occurs after the delete of a row in a table
									 variable. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; })</programlisting>The first parameter is set to the row value that was deleted.
									 Note that if the hander is deferred, it will be invoked at transaction commit
									 time, rather than immediately after the delete occurs.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Default
										  Event</primary><secondary>Table-Level</secondary></indexterm> 
								<para>Default</para> 
								<para>Occurs during a <emphasis>default</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">var row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">const</emphasis> String)</programlisting>The first parameter is set to the row value being defaulted.
									 Changes made to the value of this parameter within the body of the handler will
									 affect the resulting default row. The second parameter is set to the name of
									 the column being defaulted, if any, and the empty string (<phrase
									 role="code">""</phrase>) otherwise. Note that the handler should return true if
									 any change was made to the value of the first parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Change
										  Event</primary><secondary>Table-Level</secondary></indexterm> 
								<para>Change</para> 
								<para>Occurs during a <emphasis>change</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">const</emphasis> String)</programlisting>The first parameter is set to the old row value as it was
									 prior to the change that caused the proposable call. The second parameter is
									 set to the new row value. Changes made to the value of the new parameter within
									 the body of the handler will affect the resulting changed row. The third
									 parameter is set to the name of the column that was changed, if a single change
									 caused the call, and the empty string (<phrase role="code">""</phrase>)
									 otherwise. Note that the handler should return true if any change was made to
									 the value of the second parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Validate
										  Event</primary><secondary>Table-Level</secondary></indexterm> 
								<para>Validate</para> 
								<para>Occurs during a validate proposable call. The
									 signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">const</emphasis> String)</programlisting>The first parameter is set to the old row value as it was
									 prior to the change that caused the proposable call. The second parameter is
									 set to the new row value. Changes made to the value of the new parameter within
									 the body of the handler will affect the resulting validated row. The third
									 parameter is set to the name of the column that was changed, if a single change
									 caused the call, and the empty string (<phrase role="code">""</phrase>)
									 otherwise. Note that the handler should return true if any change was made to
									 the value of the second parameter.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Column Level Events: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Default
										  Event</primary><secondary>Column-Level</secondary></indexterm> 
								<para>Default</para> 
								<para>Occurs during a <emphasis>default</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">var</emphasis> &lt;column data type&gt;)</programlisting>The first parameter should be set to the desired default value
									 within the body of the handler. The handler should return true if any change
									 was made to the value of the first parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Change
										  Event</primary><secondary>Column-Level</secondary></indexterm> 
								<para>Change</para> 
								<para>Occurs during a <emphasis>change</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var row</emphasis> { &lt;heading&gt; })</programlisting>The first parameter is set to the old row value as it was
									 prior to the change that caused the proposable call. The second parameter is
									 set to the new row value. Changes made to the value of the new parameter within
									 the body of the handler will affect the resulting changed row. The handler
									 should return true if any change was made to the value of the second
									 parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Validate
										  Event</primary><secondary>Column-Level</secondary></indexterm> 
								<para>Validate</para> 
								<para>Occurs during a <emphasis>validate</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const row</emphasis> { &lt;heading&gt; }, <emphasis role="bold">var row</emphasis> { &lt;heading&gt; })</programlisting>The first parameter is set to the old row value as it was
									 prior to the change that caused the proposable call. The second parameter is
									 set to the new row value. Changes made to the value of the new parameter within
									 the body of the handler will affect the resulting validated row. The handler
									 should return true if any change was made to the value of the second
									 parameter.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Scalar Type Level Events: 
					 <itemizedlist> 
						  <listitem> 
								<indexterm><primary>Default
										  Event</primary><secondary>Scalar Type-Level</secondary></indexterm> 
								<para>Default</para> 
								<para>Occurs during a <emphasis>default</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">var</emphasis> &lt;scalartype&gt;)</programlisting>The first parameter should be set to the desired default value
									 within the body of the handler. The handler should return true if any change
									 was made to the value of the first parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Change
										  Event</primary><secondary>Scalar Type-Level</secondary></indexterm> 
								<para>Change</para> 
								<para>Occurs during a <emphasis>change</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const</emphasis> &lt;scalartype&gt;, <emphasis role="bold">var</emphasis> &lt;scalartype&gt;)</programlisting>The first parameter is set to the old value before the change
									 that caused the proposable call. The second parameter is set to the new value.
									 Changes made to the value of the new parameter within the body of the handler
									 will affect the resulting changed value. The handler should return true if any
									 change was made to the value of the second parameter.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Validate
										  Event</primary><secondary>Scalar Type-Level</secondary></indexterm> 
								<para>Validate</para> 
								<para>Occurs during a <emphasis>validate</emphasis>
									 proposable call. The signature for this event handler is: 
									 <programlisting>(<emphasis role="bold">const</emphasis> &lt;scalartype&gt;, <emphasis role="bold">var</emphasis> &lt;scalartype&gt;)</programlisting>The first parameter is set to the old value before the change
									 that caused the proposable call. The second parameter is set to the new value.
									 Changes made to the value of the new parameter within the body of the handler
									 will affect the resulting validated value. The handler should return true if
									 any change was made to the value of the second parameter.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>If multiple operators are attached to the same event, the
					 order in which the operators are invoked can be controlled by specifying that a
					 given operator should be invoked before a given set of operators. This is
					 accomplished with the optional <emphasis>before</emphasis> clause of the attach
					 statement, or with the invoke statement.</para> 
				<para>D4 allows for the <emphasis>after</emphasis> table-level
					 event handlers to be deferred until transaction commit time. This allows the
					 event handlers to be invoked only when all the effects of the transaction are
					 known, thus simplifying the implementation of many types of business
					 rules.</para> 
				<para>By default, any after table-level event handler is deferred
					 if the operator being invoked accesses global state. To change this behavior,
					 the 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-IsDeferred.html"
						  type="olinka">DAE.IsDeferred</ulink></phrase> tag can be specified with the
					 attach statement.</para> 
				<para>In addition, event handlers can be translated into an
					 application transaction. By default, all event handlers except after
					 table-level event handlers are translated into the application transaction. If
					 a given event handler is invoked within an application transaction, it will not
					 be invoked when the application transaction is committed. To disable
					 application transaction translation of an event handler, use the 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-ShouldTranslate.html"
						  type="olinka">DAE.ShouldTranslate</ulink></phrase> tag on the attach statement.
					 Note also that the operator being invoked may have a 
					 <phrase role="code"><ulink
						  url="FTRTagsDescriptions-DAETags-ShouldTranslate.html"
						  type="olinka">DAE.ShouldTranslate</ulink></phrase> tag indicating whether the
					 operator body should be translated into the application transaction.</para> 
				<para>Event handlers are attached and detached using the DDL
					 statements 
					 <phrase role="code"><emphasis
						  role="bold">attach</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">detach</emphasis></phrase>.</para> 
				<para>The attach statement in D4 has the following syntax: 
					 <programlisting>&lt;attach statement&gt; ::=
	<emphasis role="bold">attach</emphasis> [<emphasis role="bold">operator</emphasis>] &lt;operator name&gt;
		<emphasis role="bold">to</emphasis> &lt;event source specifier&gt; 
		&lt;event specifier clause&gt;
		[<emphasis role="bold">before</emphasis> "{"&lt;ne operator name commalist&gt;"}"]
		&lt;metadata&gt;

&lt;event source specifier&gt; ::=
	&lt;tablevar name&gt; |
	(&lt;column name&gt; <emphasis role="bold">in</emphasis> &lt;tablevar name&gt;) |
	&lt;scalar type name&gt;

&lt;event specifier clause&gt; ::=
	<emphasis role="bold">on</emphasis> (&lt;event specifier&gt; | ("{"&lt;ne event specifier commalist&gt;"}"))
	
&lt;event specifier&gt; ::=
	((<emphasis role="bold">before</emphasis> | <emphasis role="bold">after</emphasis>) (<emphasis role="bold">insert</emphasis> | <emphasis role="bold">update</emphasis> | <emphasis role="bold">delete</emphasis>)) | 
	(<emphasis role="bold">default</emphasis> | <emphasis role="bold">validate</emphasis> | <emphasis role="bold">change</emphasis>)</programlisting></para> 
				<para>This statement attaches the operator specified by 
					 <phrase role="code">&lt;operator&nbsp;name&gt;</phrase> to the
					 event source specified by 
					 <phrase
					 role="code">&lt;event&nbsp;source&nbsp;specifier&gt;</phrase> and the event
					 specified by 
					 <phrase
					 role="code">&lt;event&nbsp;specifier&nbsp;clause&gt;</phrase>. The 
					 <phrase
					 role="code">&lt;event&nbsp;source&nbsp;specifier&gt;</phrase> and 
					 <phrase
					 role="code">&lt;event&nbsp;specifier&nbsp;clause&gt;</phrase> are used to
					 determine the signature for the operator to be invoked.</para> 
				<para>The detach statement in D4 has the following syntax: 
					 <programlisting>&lt;detach statement&gt; ::=
	<emphasis role="bold">detach</emphasis> [<emphasis role="bold">operator</emphasis>] &lt;operator name&gt;
		<emphasis role="bold">from</emphasis> &lt;event source specifier&gt;
		&lt;event specifier clause&gt;</programlisting></para> 
				<para>This statement detaches the operator specified by 
					 <phrase role="code">&lt;operator&nbsp;name&gt;</phrase> from
					 the event source specified by 
					 <phrase
					 role="code">&lt;event&nbsp;source&nbsp;specifier&gt;</phrase> and the event
					 specified by 
					 <phrase
					 role="code">&lt;event&nbsp;specifier&nbsp;clause&gt;</phrase>.</para> 
				<para>The order of invocation for a given event can be controlled
					 with the invoke statement: 
					 <programlisting>&lt;invoke statement&gt; ::=
	<emphasis role="bold">invoke</emphasis> &lt;operator name&gt;
		<emphasis role="bold">on</emphasis> &lt;event source specifier&gt;
		&lt;event specifier clause&gt;
		<emphasis role="bold">before</emphasis> "{"&lt;ne operator name commalist&gt;"}"</programlisting></para> 
				<para>This statement causes the operator specified by 
					 <phrase role="code">&lt;operator&nbsp;name&gt;</phrase> on the
					 event source specified by 
					 <phrase
					 role="code">&lt;event&nbsp;source&nbsp;specifier&gt;</phrase> and the event
					 specified by 
					 <phrase
					 role="code">&lt;event&nbsp;specifier&nbsp;clause&gt;</phrase> to be invoked
					 before any operator attached to the same event with a name appearing in the 
					 <phrase
					 role="code">&lt;ne&nbsp;operator&nbsp;name&nbsp;commalist&gt;</phrase>.</para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Sorts"> 
				<title><indexterm><primary>Sorts</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Sorts</secondary></indexterm><indexterm><primary>Create
								Sort Statement</primary></indexterm><indexterm><primary>Alter Sort
								Statement</primary></indexterm><indexterm><primary>Drop Sort
								Statement</primary></indexterm>Sorts</title> 
				<para>A <emphasis>sort</emphasis> is associated with a scalar type
					 definition and provides the default sort expression for columns defined on the
					 given scalar type. A given scalar type may only have one sort associated with
					 it. Note that this sort serves only as a default for ordering, and can always
					 be changed for a given result set using the sort clause of the order column
					 definition with an 
					 <phrase role="code"><ulink url="D4LGOrders.html"
						  type="link">&lt;order&nbsp;definition&gt;</ulink></phrase> or 
					 <phrase role="code"><ulink
						  url="D4LGDataManipulation-SelectStatement.html"
						  type="link">&lt;order&nbsp;clause&gt;</ulink></phrase>.</para> 
				<para>The create sort statement in D4 has the following syntax: 
					 <programlisting>&lt;create sort statement&gt; ::=
	<emphasis role="bold">create sort</emphasis> &lt;scalar type name&gt; <emphasis role="bold">using</emphasis> &lt;expression&gt;

&lt;scalar type name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The alter sort statement in D4 has the following syntax: 
					 <programlisting>&lt;alter sort statement&gt; ::=
	<emphasis role="bold">alter sort</emphasis> &lt;scalar type name&gt; <emphasis role="bold">using</emphasis> &lt;expression&gt;</programlisting></para> 
				<para>The drop sort statement in D4 has the following syntax: 
					 <programlisting>&lt;drop sort statement&gt; ::=
	<emphasis role="bold">drop sort</emphasis> &lt;scalar type name&gt;</programlisting></para> 
				<para>These statements create, alter, and drop the sort for the
					 scalar type given by 
					 <phrase role="code">&lt;scalar&nbsp;type&nbsp;name&gt;</phrase>
					 in the catalog.</para> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Conversions"> 
				<title><indexterm><primary>Conversions</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Conversions</secondary></indexterm><indexterm><primary>Implicit
								Conversions</primary><secondary>Definition</secondary></indexterm><indexterm><primary>Types</primary><secondary>Implicit
								Conversions</secondary></indexterm><indexterm><primary>Scalar
								Types</primary><secondary>Implicit
								Conversions</secondary></indexterm><indexterm><primary>Create Conversion
								Statement</primary></indexterm><indexterm><primary>Drop Conversion
								Statement</primary></indexterm><indexterm><primary>Narrowing
								Conversions</primary></indexterm><indexterm><primary>Widening
								Conversions</primary></indexterm>Conversions</title> 
				<para>The D4 language supports the concept of implicit conversions.
					 This allows values of a given type to be implicitly converted by the compiler
					 to values of a target type. Implicit conversions must be explicitly specified
					 by the type designer using the 
					 <phrase
					 role="code">&lt;create&nbsp;conversion&nbsp;statement&gt;</phrase>. Implicit
					 conversions are transitive. For example if type 
					 <phrase role="code">A</phrase> can be implicitly converted to
					 type 
					 <phrase role="code">B</phrase> and type 
					 <phrase role="code">B</phrase> can be implicitly converted to
					 type 
					 <phrase role="code">C</phrase>, a value of type 
					 <phrase role="code">A</phrase> can be used where a value of
					 type 
					 <phrase role="code">C</phrase> is required.</para> 
				<para>Implicit conversions can be narrowing, or widening. A
					 narrowing conversion is one which may produce a run-time error because the
					 value being converted cannot be represented in the target type. For example, an
					 attempt to convert the integer value 
					 <phrase role="code">256</phrase> to a byte value will result in
					 a run-time error. A widening conversion is one which is guaranteed to be safe,
					 i.e. every value of the source type can be represented as a value in the target
					 type. Converting a value of type 
					 <phrase role="code">Byte</phrase> to a value of type 
					 <phrase role="code">Integer</phrase> is a widening conversion.
					 For more information on type conversion, narrowning, widening, and a table of
					 available conversions, refer to 
					 <ulink url="D4LGLanguageElements-Types-TypeConversions.html"
					 type="xref">Type Conversion</ulink>.</para> 
				<para>There are two cases where the compiler will attempt to
					 determine a conversion path: assignment statements, and operator calls.
					 Assignment statements include 
					 <phrase role="code"><emphasis
						  role="bold">insert</emphasis></phrase>, 
					 <phrase role="code"><emphasis
						  role="bold">update</emphasis></phrase>, and 
					 <phrase role="code"><emphasis
						  role="bold">delete</emphasis></phrase>. In each case, the compiler will attempt
					 to resolve the request using the least-narrowing, shortest conversion path from
					 the source type to the target type. Note that a narrowing conversion may result
					 in a run-time error if the value being converted is not a valid value of the
					 target type. The compiler favors widening conversions over path-length when
					 determining a conversion path between two types, and when determining an
					 appropriate operator overload.</para> 
				<para>The create conversion statement has the following syntax: 
					 <programlisting>&lt;create conversion statement&gt; ::=
		<emphasis role="bold">create conversion</emphasis> &lt;source scalar type name&gt; 
			<emphasis role="bold">to</emphasis> &lt;target scalar type name&gt; <emphasis role="bold">using</emphasis> &lt;operator name&gt;
			[<emphasis role="bold">widening</emphasis> | <emphasis role="bold">narrowing</emphasis>] &lt;metadata&gt;

&lt;source scalar type name&gt; ::=
	&lt;qualified identifier&gt;

&lt;target scalar type name&gt; ::=
	&lt;qualified identifier&gt;

&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;</programlisting> </para> 
				<para>This statement creates a conversion from 
					 <phrase
					 role="code">&lt;source&nbsp;scalar&nbsp;type&nbsp;name&gt;</phrase> to 
					 <phrase
					 role="code">&lt;target&nbsp;scalar&nbsp;type&nbsp;name&gt;</phrase> using the
					 operator specified by 
					 <phrase role="code">&lt;operator&nbsp;name&gt;</phrase>.</para>
				
				<para>The drop conversion statement has the following syntax: 
					 <programlisting>&lt;drop conversion statement&gt; ::=
	<emphasis role="bold">drop conversion</emphasis> &lt;source scalar type name&gt; <emphasis role="bold">to</emphasis> &lt;target scalar type name&gt; <emphasis role="bold">using</emphasis> &lt;operator name&gt;</programlisting></para> 
				<para>This statement drops the conversion from 
					 <phrase
					 role="code">&lt;source&nbsp;scalar&nbsp;type&nbsp;name&gt;</phrase> to 
					 <phrase
					 role="code">&lt;target&nbsp;scalar&nbsp;type&nbsp;name&gt;</phrase> using the
					 operator specified by 
					 <phrase role="code">&lt;operator&nbsp;name&gt;</phrase>.</para>
				
				<sect2 id="D4LGCatalogElements-Conversions-LikeTypes"> 
					 <title><indexterm><primary>Like
									 Types</primary></indexterm><indexterm><primary>Conversions</primary><secondary>Like
									 Types</secondary></indexterm>Like Types</title> 
					 <para>The D4 language allows a 
						  <phrase role="code">&lt;like&nbsp;clause&gt;</phrase> in
						  the 
						  <phrase
						  role="code">&lt;create&nbsp;scalar&nbsp;type&nbsp;statement&gt;</phrase>. This
						  clause indicates that the compiler should provide the basic representations of
						  the type based on the like type, and that implicit conversions to and from the
						  like type will be created.</para> 
					 <para>When a type is created <emphasis>like</emphasis> another
						  type, the compiler will perform the following steps: 
						  <orderedlist> 
								<listitem> 
									 <para>The <emphasis>like representation</emphasis>
										  of the like is determined. The like representation for a type is the
										  representation with a single property defined in terms of the like type.
										  Clearly, if a type is not defined to be like another type, then it has no like
										  representation.</para> 
								</listitem> 
								<listitem> 
									 <para>If any logical representation of the like
										  type that is not the like representation for that type has a single property
										  defined in terms of the like type, the definition for that representation is
										  added as the like representation for the new type.</para> 
								</listitem> 
								<listitem> 
									 <para>The definition for each logical
										  representation of the like type that is a native accessor is added to the new
										  type.</para> 
								</listitem> 
								<listitem> 
									 <para>If no like representation definition was
										  added based on a representation of the like type, a new representation
										  definition is added with a single property defined in terms of the like type.
										  This representation will be named the unqualified name of the new type. If the
										  new type definition already has a representation definition with the same name,
										  the representation will be named 
										  <phrase role="code">As</phrase> concatenated
										  with the unqualified name of the like type. If the new type definition already
										  has a representation definition with this name, the compiler will not attempt
										  to construct a like representation for the new type.</para> 
								</listitem> 
								<listitem> 
									 <para>If the like type has a default definition,
										  and the new type definition does not include a default definition, the new type
										  definition will be given the same default definition.</para> 
								</listitem> 
								<listitem> 
									 <para>Each constraint of the like type that does
										  not appear on the new type definition will become a constraint on the new type
										  definition.</para> 
								</listitem> 
								<listitem> 
									 <para>Each special of the like type that does not
										  appear on the new type definition will become a special on the new type
										  definition.</para> 
								</listitem> 
								<listitem> 
									 <para>All metadata tags from the like type will be
										  copied to the new type, with metadata tags on the new type definition
										  overriding metadata tags from the like type.</para> 
								</listitem> 
								<listitem> 
									 <para>Implicit conversions are created to and from
										  the like type using the read accessor and selector of the like representation
										  of the new type, respectively.</para> 
								</listitem> 
						  </orderedlist></para> 
					 <para>The following create type statement: 
						  <programlisting><emphasis role="bold">create type</emphasis> ID <emphasis role="bold">like</emphasis> String;</programlisting>is shorthand for: 
						  <programlisting><emphasis role="bold">create type</emphasis> ID
{
	<emphasis role="bold">representation</emphasis> ID { ID : String }
};

<emphasis role="bold">create conversion</emphasis> String <emphasis role="bold">to</emphasis> ID <emphasis role="bold">using</emphasis> ID <emphasis role="bold">narrowing</emphasis>;
<emphasis role="bold">create conversion</emphasis> ID <emphasis role="bold">to</emphasis> String <emphasis role="bold">using</emphasis> ID.ReadID <emphasis role="bold">widening</emphasis>;</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGCatalogElements-Roles"> 
				<title><indexterm><primary>Roles</primary></indexterm><indexterm><primary>Rights</primary></indexterm><indexterm><primary>Catalog
								Elements</primary><secondary>Roles</secondary></indexterm><indexterm><primary>Create
								Role Statement</primary></indexterm><indexterm><primary>Alter Role
								Statement</primary></indexterm><indexterm><primary>Drop Role
								Statement</primary></indexterm><indexterm><primary>Create Right
								Statement</primary></indexterm><indexterm><primary>Drop Right
								Statement</primary></indexterm>Roles and Rights</title> 
				<para>Roles and Rights are the application-level security
					 primitives available in the Dataphor Server. Rights are the basic unit of
					 permission, while roles are groups of right assignments that can be used to
					 facilitate security administration. Roles are catalog level objects and
					 therefore share the namespace with all other catalog objects. In contrast,
					 Rights have a separate namespace, and are only required to be uniquely named
					 within the set of rights.</para> 
				<para>The security statements in D4 have the following syntax: 
					 <programlisting>&lt;create role statement&gt; ::=
	<emphasis role="bold">create role</emphasis> &lt;role name&gt; &lt;metadata&gt;

&lt;alter role statement&gt; ::=
	<emphasis role="bold">alter role</emphasis> &lt;role name&gt; &lt;alter metadata&gt;

&lt;drop role statement&gt; ::=
	<emphasis role="bold">drop role</emphasis> &lt;role name&gt;

&lt;create right statement&gt; ::=
	<emphasis role="bold">create right</emphasis> &lt;right name&gt;

&lt;drop right statement&gt; ::=
	<emphasis role="bold">drop right</emphasis> &lt;right name&gt;

&lt;role name&gt; ::=
	&lt;qualified identifier&gt;

&lt;right name&gt; ::=
	&lt;qualified identifier&gt;</programlisting> </para> 
				<para>The create role statement creates a role named 
					 <phrase role="code">&lt;role&nbsp;name&gt;</phrase> with the
					 metadata specified by 
					 <phrase role="code">&lt;metadata&gt;</phrase>.</para> 
				<para>The alter role statement alters the metadata for the role
					 specified by 
					 <phrase role="code">&lt;role&nbsp;name&gt;</phrase>.</para> 
				<para>The drop role statement drops the role specified by 
					 <phrase role="code">&lt;role&nbsp;name&gt;</phrase>. Any right
					 assignments and user memberships for the role being dropped are implicitly
					 removed by the drop role statement.</para> 
				<para>The create right statement creates a right named 
					 <phrase role="code">&lt;right&nbsp;name&gt;</phrase>. The right
					 name must be unique among the existing rights in the system. The right created
					 is owned by the user performing the create right statement. The owner of the
					 right is implicitly granted the right, while other users must be explicitly
					 granted the right.</para> 
				<para>The drop right statement drops the right specified by 
					 <phrase role="code">&lt;right&nbsp;name&gt;</phrase>. Rights
					 that are implicitly created by the system to protect access to catalog objects
					 cannot be dropped with a drop right statement. Any right assignments
					 referencing the right being dropped are implicitly removed by the drop right
					 statement.</para> 
				<para>For more information on the security model of the Dataphor
					 Server, refer to the Security discussions in the Dataphor User's Guide and the
					 Dataphor Developer's Guide.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGDataManipulation"> 
		  <title><indexterm><primary>Data Manipulation
						  Language</primary></indexterm>Data Manipulation</title> 
		  <para>This section covers the data manipulation language statements
				available in the D4 language. These statements allow data in the database to be
				retrieved, stored, and changed.</para> 
		  <para>Data manipulation statements in D4 have the following syntax: 
				<programlisting>&lt;dml statement&gt; ::=
	&lt;select statement&gt; |
	&lt;insert statement&gt; |
	&lt;update statement&gt; |
	&lt;delete statement&gt;</programlisting></para> 
		  <para>It is important to note that these statements are set-at-a-time
				operations, meaning that they do not operate at a row level, rather on an
				entire table variable at once. Also note that conceptually each of the
				modification statements, 
				<phrase role="code"><emphasis
					 role="bold">insert</emphasis></phrase>, 
				<phrase role="code"><emphasis
					 role="bold">update</emphasis></phrase>, and 
				<phrase role="code"><emphasis
					 role="bold">delete</emphasis></phrase>, are shorthands for some equivalent
				relational assignment.</para> 
		  <para>The following sections consider each statement in detail.</para> 
		  <sect1 id="D4LGDataManipulation-SelectStatement"> 
				<title><indexterm><primary>Select
								Statement</primary></indexterm><indexterm><primary>Data Manipulation
								Language</primary><secondary>Select
								Statement</secondary></indexterm><indexterm><primary>Cursor
								Definition</primary></indexterm>Select Statement</title> 
				<para>The select statement allows for the retrieval of a specified
					 table expression. The statement allows the result set to be ordered
					 arbitrarily, and allows for the specification of 
					 <ulink url="DDGP1Cursor.html" type="olinka">cursor</ulink>
					 level properties such as isolation level and cursor type. The select statement
					 and the cursor selector both use the same 
					 <phrase role="code">&lt;cursor&nbsp;definition&gt;</phrase>
					 production rule to define their syntax.</para> 
				<para>The purpose of the select statement in the D4 language is to
					 provide a facility for parser-level recognition of statements that should
					 return a result set. This is used by the Call-Level Interface (CLI) to
					 determine whether a given batch should be executed or opened. Thus, a select
					 statement should only be used to retrieve data through the CLI. For example: 
					 <programlisting>Employee;</programlisting> is a valid expression, but no data will be retrieved. On the
					 other hand the results of the following query will be retrieved through the
					 CLI: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee; </programlisting> 
					 <programlisting>ID Name 
-- ---- 
1  Joe 
2  John 
3  Josh 
4  Jeff 
5  Jake 
6  Jeff </programlisting> </para> 
				<para>The select statement in D4 has the following syntax: 
					 <programlisting>&lt;select statement&gt; ::=
	<emphasis role="bold">select</emphasis> &lt;cursor definition&gt;

&lt;cursor definition&gt; ::=
	&lt;expression&gt; 
	[&lt;order clause&gt; | &lt;browse clause&gt;] 
	[&lt;cursor capabilities&gt;] 
	[&lt;cursor isolation&gt;] 
	[&lt;cursor type&gt;]

&lt;order clause&gt; ::=
	<emphasis role="bold">order by</emphasis> 
		"{"&lt;order column definition commalist&gt;"}" 
		[&lt;language modifiers&gt;]

&lt;browse clause&gt; ::=
	<emphasis role="bold">browse by</emphasis> 
		"{"&lt;order column definition commalist&gt;"}" 
		[&lt;language modifiers&gt;]

&lt;order column definition&gt; ::=
	&lt;column name&gt; [<emphasis role="bold">sort</emphasis> &lt;expression&gt;] [<emphasis role="bold">asc</emphasis> | <emphasis role="bold">desc</emphasis>] [(<emphasis role="bold">include</emphasis> | <emphasis role="bold">exclude</emphasis>) <emphasis role="bold">nil</emphasis>]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;cursor capabilities&gt; ::=
	<emphasis role="bold">capabilities</emphasis> "{"&lt;cursor capability commalist&gt;"}"
	
&lt;cursor capability&gt; ::=
	navigable | 
	backwardsnavigable | 	
	bookmarkable | 
	searchable | 
	updateable | 
	truncateable | 
	countable

&lt;cursor isolation&gt; ::=
	<emphasis role="bold">isolation</emphasis> (none | browse | isolated)

&lt;cursor type&gt; ::=
	<emphasis role="bold">type</emphasis> (<emphasis role="bold">static</emphasis> | <emphasis role="bold">dynamic</emphasis>)</programlisting></para> 
				<para>The basis of the cursor definition is a table expression
					 specified by 
					 <phrase role="code">&lt;expression&gt;</phrase>. For a detailed
					 description of the 
					 <phrase role="code">&lt;expression&gt;</phrase> production
					 rule, refer to 
					 <ulink url="D4LGLanguageElements-Expressions.html"
					 type="xref">Expressions</ulink>. For a complete description of the table
					 operators avaialable in D4, refer to 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink>.</para> 
				<sect2
				id="D4LGDataManipulation-SelectStatement-OrderingTheResultSet"> 
					 <title><indexterm><primary><phrase role="code"><emphasis
										  role="bold">order by</emphasis></phrase>
									 Clause</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
										  role="bold">browse by</emphasis></phrase>
									 Clause</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Ordering</secondary></indexterm>Ordering The
						  Result Set</title> 
					 <para>The result set for a 
						  <ulink url="DDGP1Cursor.html" type="olinka">cursor</ulink>
						  is ordered as specified by the 
						  <phrase role="code">&lt;order&nbsp;clause&gt;</phrase> or 
						  <phrase role="code">&lt;browse&nbsp;clause&gt;</phrase>. An
						  <emphasis>order</emphasis> specification simply indicates the requested order
						  for the result set, whereas a <emphasis>browse</emphasis> specification
						  indicates not only the requested order, but that <emphasis>navigational
						  access</emphasis> should be used to retrieve data from the cursor. A cursor
						  using navigational access enables functionality such as searching and backwards
						  scrolling by transparently transforming the expression actually used to
						  retrieve the data. This type of access enables efficient searching and
						  navigation through a cursor without requiring ad-hoc solutions to be developed
						  in client applications.</para> 
					 <para>An order can consist of any subset of the columns of a
						  table variable in any order. Each column can include an optional sort
						  expression, and an optional ascending indicator. In addition, each column can
						  indicate whether or not rows with nil for the column should be included in the
						  result set. By default, rows with nils are excluded.</para> 
					 <para>The sort expression allows the order to use an arbitrary
						  condition for sorting. The sort expression must be integer-valued, functional
						  and deterministic. The expression has access to the implicit variables 
						  <phrase role="code"><emphasis
								role="bold">left.value</emphasis></phrase> and 
						  <phrase role="code"><emphasis
								role="bold">right.value</emphasis></phrase>, which are the values to be
						  compared. The expression must return -1 if 
						  <phrase role="code"><emphasis
								role="bold">left.value</emphasis></phrase> is less than 
						  <phrase role="code"><emphasis
								role="bold">right.value</emphasis></phrase>, 0 if the two values are equal, and
						  1 if 
						  <phrase role="code"><emphasis
								role="bold">left.value</emphasis></phrase> is greater than 
						  <phrase role="code"><emphasis
								role="bold">right.value</emphasis></phrase>.</para> 
					 <para>The optional ascending indicator specifies whether this
						  column should be sorted ascending or descending. If no ascending indicator is
						  specified, ascending is assumed.</para> 
					 <para>The following example illustrates the use of the order
						  clause: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">order by</emphasis> { Name, ID <emphasis role="bold">desc</emphasis> };	 </programlisting> 
						  <programlisting>ID Name
-- ---- 
5  Jake 
6  Jeff 
4  Jeff 
1  Joe 
2  John
3  Josh </programlisting> </para> 
				</sect2> 
				<sect2
				id="D4LGDataManipulation-SelectStatement-CursorCapabilities"> 
					 <title><indexterm><primary>Cursor
									 Capabilities</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Capabilities</secondary></indexterm>Cursor
						  Capabilities</title> 
					 <para><ulink url="DDGP1Cursor.html"
						  type="olinka">Cursor</ulink> capabilities describe the behaviors available for
						  the cursor. These include items such as updatability, backwards navigation,
						  searching, and bookmarking. The D4 language defines the following cursor
						  capabilities: 
						  <itemizedlist> 
								<listitem> 
									 <para>Navigable</para> 
									 <para>Indicates that the cursor is capable of
										  forward navigation through calls like Next and Last. Also indicates that the
										  cursor supports data retrieval through the Select call. All cursors are
										  guaranteed to support this level of functionality.</para> 
								</listitem> 
								<listitem> 
									 <para>Backwards Navigable</para> 
									 <para>Indicates that the cursor is capable of
										  backward navigation through calls like Prior and First.</para> 
								</listitem> 
								<listitem> 
									 <para>Bookmarkable</para> 
									 <para>Indicates that the cursor is capable of
										  bookmarking functionality, or remembering a location in the result set for
										  quick location at a later time.</para> 
								</listitem> 
								<listitem> 
									 <para>Searchable</para> 
									 <para>Indicates that the cursor is capable of
										  performing searches through calls like FindKey and FindNearest. Note that the
										  search must be made against the same columns that were used to order the
										  result.</para> 
								</listitem> 
								<listitem> 
									 <para>Updatable</para> 
									 <para>Indicates that the cursor supports updates
										  through calls like Insert and Update.</para> 
								</listitem> 
								<listitem> 
									 <para>Truncatable</para> 
									 <para>Indicates that the cursor supports
										  truncation.</para> 
								</listitem> 
								<listitem> 
									 <para>Countable</para> 
									 <para>Indicates that the cursor supports retrieving
										  a count of the number of rows in the result.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The cursor definition allows any combination of these
						  capabilities to be requested. The Dataphor Server will attempt to provide a
						  cursor with the requested capabilities. An error occurs if the requested
						  capabilities cannot be provided. If no cursor capabilities are specified as
						  part of the cursor definition, the default capabilities of Navigable will be
						  requested. All cursors are guaranteed to support at least the Navigable
						  capability.</para> 
					 <para>The following sections consider each cursor capability in
						  detail. The functionality described in each section is available either as
						  operators in the D4 language, or through the CLI directly.</para> 
					 <sect3 id="DDGP2Navigable"> 
						  <title><indexterm><primary>Navigable Cursor
										  Capability</primary></indexterm>Navigable</title> 
						  <para>Navigable indicates that the cursor supports basic
								navigational access. All cursors support this level of functionality.</para> 
						  <para>The following functionality is available for cursors
								supporting the Navigable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">Select</phrase></entry><entry>Retrieves the current row of the
														  cursor. It is an error if either 
														  <phrase role="code">BOF</phrase> or
														  
														  <phrase role="code">EOF</phrase> is
														  true.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Next</phrase></entry><entry>Advances the current position of the
														  cursor by 1 row. If this moves past the last row in the result set, 
														  <phrase role="code">EOF</phrase>
														  will be true.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Last</phrase></entry><entry>Moves the current position of the
														  cursor past the last row in the result set. 
														  <phrase role="code">EOF</phrase>
														  will always be true after a call to 
														  <phrase
														  role="code">Last</phrase></entry> 
												</row> 
												<row><entry><phrase
														  role="code">BOF</phrase></entry><entry>Returns true if the current position of
														  the cursor is before the first row in the result set. 
														  <phrase role="code">BOF</phrase>
														  will always be true when the cursor is first opened.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">EOF</phrase></entry><entry>Returns true if the current position of
														  the cursor is after the last row in the result set. 
														  <phrase role="code">EOF</phrase>
														  will only be true after the cursor is first opened if the cursor is
														  empty.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">IsEmpty</phrase></entry><entry>Returns true if there are no rows in
														  the result set. This is equivalent to evaluating the expression 
														  <phrase role="code">BOF
																<emphasis role="bold">and</emphasis> EOF</phrase>. This functionality is not
														  exposed in D4.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Reset</phrase></entry><entry>Resets the cursor by requerying for
														  the result set. This is equivalent to closing and re-opening the
														  cursor.</entry> 
												</row></tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2BackwardsNavigable"> 
						  <title><indexterm><primary>Backwards Navigable Cursor
										  Capability</primary></indexterm>Backwards Navigable</title> 
						  <para>Backwards Navigable indicates that the cursor
								supports backwards navigation.</para> 
						  <para>The following functionality is included in the
								Backwards Navigable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">Prior</phrase></entry><entry>Moves the current position of the
														  cursor to the prior row. If this moves before the first row in the result set, 
														  <phrase role="code">BOF</phrase>
														  will be true.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">First</phrase></entry><entry>Moves the current position of the
														  cursor before the first row in the result set. 
														  <phrase role="code">BOF</phrase>
														  will always be true after a call to 
														  <phrase
														  role="code">First</phrase>.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Bookmarkable"> 
						  <title><indexterm><primary>Bookmarkable Cursor
										  Capability</primary></indexterm>Bookmarkable</title> 
						  <para>Bookmarkable indicates that the cursor supports
								navigation and location through the use of bookmarks. A bookmark is a system
								provided value which is like a handle to a specific position in the cursor. If
								a cursor supports bookmarks, this functionality can be used to remember certain
								locations within a cursor and return to them later. A bookmark is only valid
								for the cursor from which it was requested. All bookmarks are invalidated when
								the cursor closes. All bookmarks requested through the 
								<phrase role="code">GetBookmark</phrase> operator must
								be disposed using the 
								<phrase role="code">DisposeBookmark</phrase>
								call.</para> 
						  <para>Note that within D4, there is no reason to use the
								Bookmarkable cursor capability. It is exposed as an implementation mechanism
								for data access layer clients. If you request a Bookmarkable cursor within D4,
								it will be supported by the Searchable cursor capability described in the next
								section. For this reason, cursors declared within D4 should simply use the
								Searchable capability.</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">GetBookmark</phrase></entry><entry>Retrieves a bookmark for the
														  current position of the cursor which can be used in subsequent calls to other
														  Bookmarkable methods for the same cursor. A bookmark obtained with 
														  <phrase
														  role="code">GetBookmark</phrase> must be released with a call to one of the 
														  <phrase
														  role="code">DisposeBookmark</phrase> methods.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">GotoBookmark</phrase></entry><entry>Moves the current position of
														  the cursor to the row identified by the given bookmark. The bookmark must have
														  been obtained from a previous call to 
														  <phrase
														  role="code">GetBookmark</phrase> for this cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">CompareBookmarks</phrase></entry><entry>Compares two bookmarks and
														  returns an integer value indicating the relative order of the bookmarks. If the
														  first bookmark is less than the second, a -1 is returned. If the first bookmark
														  is equal to the second, a 0 is returned. Otherwise, a 1 is returned. Both
														  bookmarks must have been obtained from previous calls to 
														  <phrase
														  role="code">GetBookmark</phrase> for this cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">DisposeBookmark</phrase></entry><entry>Releases the given bookmark.
														  The bookmark must have been obtained from a previous call to 
														  <phrase
														  role="code">GetBookmark</phrase> for this cursor. This functionality is not
														  exposed in D4.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">DisposeBookmarks</phrase></entry><entry>Releases each of the given
														  bookmarks. All the bookmarks must have been obtained from previous calls to 
														  <phrase
														  role="code">GetBookmark</phrase> for this cursor. This functionality is not
														  exposed in D4.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Searchable"> 
						  <title><indexterm><primary>Searchable Cursor
										  Capability</primary></indexterm>Searchable</title> 
						  <para>Searchable indicates that the cursor supports
								searching based on the order of the rows within the result set. Searching must
								be done on a subset (not necessarily proper) of the columns that were used to
								order the result set.</para> 
						  <para>The following functionality is included in the
								Searchable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">Order</phrase></entry><entry>Describes the order of the rows in the
														  result set. This functionality is not exposed in D4.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">GetKey</phrase></entry><entry>Returns a row value with a column for
														  each column in the order of the result set, with the values set to the values
														  of the current row of the cursor. It is an error to request a key if either 
														  <phrase role="code">BOF</phrase> or
														  
														  <phrase role="code">EOF</phrase> is
														  true.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">FindKey</phrase></entry><entry>Attempts to position the cursor on
														  the row matching the values in the given row value. Returns true if a matching
														  row was found, and false otherwise.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">FindNearest</phrase></entry><entry>Positions the cursor on the row
														  most closely matching the values in the given row value.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Refresh</phrase></entry><entry>Refreshes the cursor by requerying
														  for the underlying result set. If a row is given, attempts to position the
														  cursor on that row, otherwise, attempts to maintain the current position of the
														  cursor in the result set.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Updatable"> 
						  <title><indexterm><primary>Updatable Cursor
										  Capability</primary></indexterm>Updatable</title> 
						  <para>Updatable indicates that the cursor is not readonly,
								i.e. data can be updated through the cursor. Whether or not the updates are
								visible through the cursor, and the position of the cursor after the updates
								are performed, is determined by the Cursor Type behavior.</para> 
						  <para>The following functionality is included in the
								Updateable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">Insert</phrase></entry><entry>Inserts the given row into the
														  database through the cursor. This has the same effect as attempting to insert
														  the row into a view defined by the expression used to generate the result set
														  for the cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Update</phrase></entry><entry>Updates the columns in the current
														  row of the cursor to the values in the given row through the cursor. This has
														  the same effect as attempting to update a view defined by the expression used
														  to generate the result set for the cursor and restricted to the current row in
														  the cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Delete</phrase></entry><entry>Deletes the current row of the
														  cursor. This has the same effect as attempting to delete the row from a view
														  defined by the expression used to generate the result set for the cursor and
														  restricted to the current row in the cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Default</phrase></entry><entry>Requests the default values for
														  columns in the result set for the cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Change</phrase></entry><entry>Requests the effect of the given
														  change to the columns of the current row of the result set for the
														  cursor.</entry> 
												</row> 
												<row><entry><phrase
														  role="code">Validate</phrase></entry><entry>Validates the values in columns of
														  the given row based on the columns of the result set for the cursor.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Truncatable"> 
						  <title><indexterm><primary>Truncatable Cursor
										  Capability</primary></indexterm>Truncatable</title> 
						  <para>Truncatable indicates that the result set may be
								completely deleted with a single call.</para> 
						  <para>The following functionality is included in the
								Truncateable category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">Truncate</phrase></entry><entry>Deletes all the rows in the cursor.
														  This functionality is not exposed in D4.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
					 <sect3 id="DDGP2Countable"> 
						  <title><indexterm><primary>Countable Cursor
										  Capability</primary></indexterm>Countable</title> 
						  <para>Countable indicates that the cursor supports counting
								of the rows in the result set. Note that the result of counting the rows in the
								result set depends on the type of the cursor. Repeated invocations may not
								return the same result.</para> 
						  <para>The following functionality included in the Countable
								category of behavior:</para> 
						  <para> 
								<informaltable> 
									 <tgroup cols="2"><colspec colnum="1" colname="col1"
										  colwidth=".25*"/><thead> 
												<row><entry>Operator</entry><entry>Description</entry>
													 
												</row></thead><tbody> 
												<row><entry><phrase
														  role="code">RowCount</phrase></entry><entry>Returns the number of rows in the
														  result set. The results of this call are not guaranteed to be an accurate
														  reflection of the current state of the database. If an accurate count is
														  desired, use an aggregate query. This functionality is not exposed in
														  D4.</entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGDataManipulation-SelectStatement-CursorIsolation"> 
					 <title><indexterm><primary>Cursor
									 Isolation</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Isolation</secondary></indexterm>Cursor
						  Isolation</title> 
					 <para>The isolation of a 
						  <ulink url="DDGP1Cursor.html" type="olinka">cursor</ulink>
						  determines how the cursor runs with respect to other active transactions in the
						  system. The settings for this behavior correspond roughly to the isolation
						  levels available for transaction processing.</para> 
					 <para>If no isolation level is specified as part of the cursor
						  definition, the default cursor isolation level of None will be used.</para> 
					 <informaltable> 
						  <tgroup cols="2"><colspec colnum="1" colname="col1"
								colwidth=".25*"/><thead> 
									 <row><entry>Method</entry><entry>Description</entry>
										  
									 </row></thead><tbody> 
									 <row><entry>None</entry><entry>Indicates that the
												cursor runs at the isolation level of the current transaction.</entry> 
									 </row> 
									 <row><entry>Browse</entry><entry>Indicates that the
												cursor should use optimistic concurrency control.</entry> 
									 </row> 
									 <row><entry>Isolated</entry><entry>Indicates that
												the cursor should use pessimistic concurrency control.</entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable> 
				</sect2> 
				<sect2 id="D4LGDataManipulation-SelectStatement-CursorType"> 
					 <title><indexterm><primary>Cursor
									 Type</primary></indexterm><indexterm><primary>Select
									 Statement</primary><secondary>Cursor Type</secondary></indexterm>Cursor
						  Type</title> 
					 <para>The type of a 
						  <ulink url="DDGP1Cursor.html" type="olinka">cursor</ulink>
						  determines how the cursor is materialized and how it behaves with respect to
						  updates being made through the cursor, and by other users of the system.
						  Cursors may be requested either static or dynamic.</para> 
					 <para>If no cursor type is specified as part of the cursor
						  definition, the default cursor type of Dynamic will be used.</para> 
					 <sect3 id="D4LGStatic"> 
						  <title><indexterm><primary>Static</primary></indexterm><indexterm><primary>Cursor
										  Type</primary><secondary>Static</secondary></indexterm>Static</title> 
						  <para>Indicates that the cursor is insensitive to updates
								made to the result set after the cursor has been opened.</para> 
						  <para>In a static cursor, updates made to rows in the
								result set, either by the user of the cursor, or updates that become visible
								based on the isolation level of the cursor from other transactions, are not
								visible. The result set is fully materialized on open, and no changes are made
								to this set. Note that calls like 
								<phrase role="code">Reset</phrase> and 
								<phrase role="code">Refresh</phrase> will necessarily
								requery the data from the underlying database, and the result set will be
								refreshed at that point.</para> 
					 </sect3> 
					 <sect3 id="D4LGDynamic"> 
						  <title><indexterm><primary>Dynamic</primary></indexterm><indexterm><primary>Cursor
										  Type</primary><secondary>Dynamic</secondary></indexterm>Dynamic</title> 
						  <para>Indicates that the cursor is sensitive to updates
								made to rows in the result set after the cursor has been opened.</para> 
						  <para>In a dynamic cursor, updates made to rows in the
								result set, either by the user of the cursor, or from other transactions that
								become visible based on the isolation level of the cursor, are visible through
								the cursor. The result set is dynamically queried for as it is requested. Note
								that this is not a guarantee that updates made by other transactions will be
								visible, only that the system is not required to exclude them. Depending on how
								the query is processed, and how the devices performing the processing
								manipulate the rows in the result set, external updates may or may not be
								visible. However, a dynamic cursor does guarantee that updates made through the
								cursor are visible.</para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGDataManipulation-InsertStatement"> 
				<title><indexterm><primary>Insert
								Statement</primary></indexterm><indexterm><primary>Data Manipulation
								Language</primary><secondary>Insert Statement</secondary></indexterm>Insert
					 Statement</title> 
				<para>The insert statement allows data to be inserted into a given
					 table variable or expression.</para> 
				<para>The insert statement in D4 has the following syntax: 
					 <programlisting>&lt;insert statement&gt; ::=
	<emphasis role="bold">insert</emphasis> [&lt;language modifiers&gt;] &lt;source&gt; <emphasis role="bold">into</emphasis> &lt;target&gt;

&lt;source&gt; ::=
	&lt;expression&gt;

&lt;target&gt; ::=
	&lt;expression&gt;</programlisting></para> 
				<para>The insert must not violate any constraint of the
					 database.</para> 
				<para>The value specified by 
					 <phrase role="code">&lt;source&gt;</phrase> must be
					 assignment-compatible with the variable or expression given by 
					 <phrase role="code">&lt;target&gt;</phrase>, with the exception
					 that the source value need not include all the columns of the target value.
					 Columns not specified in the insert are provided a default value if the
					 corresponding column, or the scalar type of the column, of the target has a
					 default specification.</para> 
				<para>The expression given by 
					 <phrase role="code">&lt;source&gt;</phrase> must be
					 table-valued. In other words, the expression must return a table. In order to
					 insert a single row, a table selector must be used to construct a table
					 value.</para> 
				<para>The variable or expression given by 
					 <phrase role="code">&lt;target&gt;</phrase> need not be a table
					 variable. The target can be a table expression of arbitrary complexity. In this
					 case, the updatability mechanism for views is used to perform the insert. For
					 more information on how modifications are made to views, refer to the
					 documentation for each table operator in this guide.</para> 
				<para>Note that the insert statement is essentially shorthand for
					 an equivalent table variable assignment. For example: 
					 <programlisting><emphasis role="bold">insert</emphasis> A <emphasis role="bold">into</emphasis> B;</programlisting>and 
					 <programlisting>B := B <emphasis role="bold">union</emphasis> A;</programlisting>are conceptually equivalent, with the exception that a
					 duplicate row that would be rejected by the insert statement would not
					 necessarily be rejected by the assignment statement. For example, if a given
					 row to be inserted is already present in the target, the assignment statement
					 will effectively ignore the insertion, whereas the insert statement will fail
					 with a duplicate key violation.</para> 
				<para>The following example illustrates the use of the D4 insert
					 statement: 
					 <programlisting><emphasis role="bold">insert</emphasis>
	<emphasis role="bold">table</emphasis>
	{ 
		<emphasis role="bold">row</emphasis> { "John Smith" Name }
	} 
	<emphasis role="bold">into</emphasis> Customer; </programlisting> </para> 
		  </sect1> 
		  <sect1 id="D4LGDataManipulation-UpdateStatement"> 
				<title><indexterm><primary>Update
								Statement</primary></indexterm><indexterm><primary>Data Manipulation
								Language</primary><secondary>Update Statement</secondary></indexterm>Update
					 Statement</title> 
				<para>The update statement allows the data in a given table
					 variable or expression to be changed. The update statement will also work
					 against row variables.</para> 
				<para>The update statement in D4 has the following syntax: 
					 <programlisting>&lt;update statement&gt; ::=
	<emphasis role="bold">update</emphasis> [&lt;language modifiers&gt;] &lt;expression&gt; 
		<emphasis role="bold">set</emphasis> "{"&lt;ne update column commalist&gt;"}" 
		[<emphasis role="bold">where</emphasis> &lt;expression term&gt;]

&lt;update column&gt; ::=
	&lt;target&gt; := &lt;expression term&gt;

&lt;target&gt; ::=
	&lt;expression&gt;</programlisting></para> 
				<para>The update must not violate any constraint of the
					 database.</para> 
				<para>The variable or expression given by 
					 <phrase role="code"><ulink
						  url="D4LGLanguageElements-Expressions.html"
						  type="link">&lt;expression&gt;</ulink></phrase> need not be a table variable.
					 The target can be a table expression of arbitrary complexity. In this case, the
					 updatability mechanism for views is used to perform the update. For more
					 information on how modifications are made to views, refer to the documentation
					 for each table operator in this guide.</para> 
				<para>The update target may also be a row variable. In this case
					 the update is a row update, and the where clause may not be specified.</para> 
				<para>The set clause specifies a list of columns to be updated in
					 the target, and the new values for each column. The values given for each
					 column must be assignment-compatible with the type of the column. The
					 expression specifying the new value for each column can access the current
					 values of the target row by name.</para> 
				<para>The update statement includes an optional 
					 <phrase role="code"><emphasis role="bold"><ulink
						  url="D4LGTableExpressions-Where.html"
						  type="link">where</ulink></emphasis></phrase> specification that indicates
					 which rows of the target expression are to be updated. It is an error to
					 specify an update condition when the target is a row variable.</para> 
				<para>The following example illustrates the use of the D4 update
					 statement: 
					 <programlisting><emphasis role="bold">update</emphasis> Customer <emphasis role="bold">set</emphasis> { Name := "Sally Johnson" } <emphasis role="bold">where</emphasis> ID = 5;</programlisting> </para> 
		  </sect1> 
		  <sect1 id="D4LGDataManipulation-DeleteStatement"> 
				<title><indexterm><primary>Delete
								Statement</primary></indexterm><indexterm><primary>Data Manipulation
								Language</primary><secondary>Delete Statement</secondary></indexterm>Delete
					 Statement</title> 
				<para>The delete statement allows the data in a given table
					 variable or expression to be removed.</para> 
				<para>The delete statement in D4 has the following syntax: 
					 <programlisting>&lt;delete statement&gt; ::=
	<emphasis role="bold">delete</emphasis> [&lt;language modifiers&gt;] &lt;expression&gt;</programlisting></para> 
				<para>The delete must not violate any constraint of the
					 database.</para> 
				<para>The variable or expression given by 
					 <phrase role="code"><ulink
						  url="D4LGLanguageElements-Expressions.html"
						  type="link">&lt;expression&gt;</ulink></phrase> need not be a table variable.
					 The target can be a table expression of arbitrary complexity. In this case, the
					 updatability mechanism for views is used to perform the delete. For more
					 information on how modifications are made to views, refer to the documentation
					 for each table operator in this guide.</para> 
				<para>The following examples illustrate the use of the D4 delete
					 statement: 
					 <programlisting>// deletes all employees with an ID greater than 3
<emphasis role="bold">delete</emphasis> Employee <emphasis role="bold">where</emphasis> ID &gt; 3;

<emphasis role="bold">delete</emphasis> Employee; // deletes all employees</programlisting> </para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGTableExpressions"> 
		  <title><indexterm><primary>Table
						  Operators</primary><secondary>Syntax</secondary></indexterm>Table
				Operators</title> 
		  <para>This section covers the various table operators available in D4.
				The various inference mechanisms and updatability rules are covered for each of
				the operators.</para> 
		  <para>The table operator clause in D4 has the following syntax: 
				<programlisting>&lt;table operator clause&gt; ::=
	&lt;where clause&gt; |
	&lt;over clause&gt; |
	&lt;remove clause&gt; |
	&lt;specify clause&gt; |
	&lt;add clause&gt; |
	&lt;rename clause&gt; |
	&lt;aggregate clause&gt; |
	&lt;quota clause&gt; |
	&lt;explode clause&gt; |
	&lt;adorn clause&gt; |
	&lt;redefine clause&gt; |
	&lt;union clause&gt; |
	&lt;intersect clause&gt; |
	&lt;minus clause&gt; |
	&lt;times clause&gt; |
	&lt;join clause&gt; |
	&lt;having clause&gt; |
	&lt;without clause&gt; |
	&lt;outer join clause&gt;</programlisting></para> 
		  <para><indexterm><primary>Closure</primary></indexterm>All D4 table
				operators are fully atomic and produce a new table value. This property is
				known as <emphasis>closure</emphasis> and allows the results of one table
				operator to be used as the argument to another. This allows operators within
				expressions to be <emphasis>nested</emphasis> as often as necessary, and in any
				order.</para> 
		  <para>The following sections cover each table operator in detail. The
				sample database provided will be used throughout the examples in this section: 
				<programlisting><emphasis role="bold">create table</emphasis> Employee
{ 
	ID : Integer,
	Name : String,
	<emphasis role="bold">key</emphasis> { ID }
}; 

<emphasis role="bold">insert</emphasis> 
	<emphasis role="bold">table</emphasis>	
	{
		<emphasis role="bold">row</emphasis> { 1 ID, "Joe" Name },
		<emphasis role="bold">row</emphasis> { 2, "John" },
		<emphasis role="bold">row</emphasis> { 3, "Josh" },
		<emphasis role="bold">row</emphasis> { 4, "Jeff" },
		<emphasis role="bold">row</emphasis> { 5, "Jake" },
		<emphasis role="bold">row</emphasis> { 6, "Jeff" }
	} 
	<emphasis role="bold">into</emphasis> Employee;

<emphasis role="bold">create table</emphasis> Manager
{
	Manager_ID : Integer,
	Employee_ID : Integer,
	<emphasis role="bold">key</emphasis> { Manager_ID, Employee_ID },
	<emphasis role="bold">reference</emphasis> Manager_Employee { Manager_ID } <emphasis role="bold">references</emphasis> Employee { ID },
	<emphasis role="bold">reference</emphasis> Employee_Employee { Employee_ID } <emphasis role="bold">references</emphasis> Employee { ID }
};

<emphasis role="bold">insert</emphasis> 
	<emphasis role="bold">table</emphasis>
	{
		<emphasis role="bold">row</emphasis> { 1 Manager_ID, 2 Employee_ID },
		<emphasis role="bold">row</emphasis> { 1 Manager_ID, 3 Employee_ID },
		<emphasis role="bold">row</emphasis> { 2 Manager_ID, 4 Employee_ID },
		<emphasis role="bold">row</emphasis> { 2 Manager_ID, 6 Employee_ID },
		<emphasis role="bold">row</emphasis> { 4 Manager_ID, 5 Employee_ID }
	}
	<emphasis role="bold">into</emphasis> Manager;

<emphasis role="bold">create table</emphasis> EmployeePhone 
{
	ID : Integer,
	Phone : String,
	<emphasis role="bold">key</emphasis> { ID, Phone }
};

EmployeePhone :=
	<emphasis role="bold">table</emphasis>
	{
		<emphasis role="bold">row</emphasis> { 1 ID, "555-1234" Phone },
		<emphasis role="bold">row</emphasis> { 1 ID, "555-1000" Phone }, 
		<emphasis role="bold">row</emphasis> { 2 ID, "555-4321" Phone },
		<emphasis role="bold">row</emphasis> { 4 ID, "555-4444" Phone },
		<emphasis role="bold">row</emphasis> { 5 ID, "555-5678" Phone },
		<emphasis role="bold">row</emphasis> { 10 ID, "411" Phone	},
		<emphasis role="bold">row</emphasis> { 12 ID, "911" Phone }
	};</programlisting> </para> 
		  <sect1 id="D4LGTableExpressions-Where"> 
				<title><indexterm><primary>Restriction - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">where</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Restriction
								(<phrase role="code"><phrase
									 role="code">where</phrase></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><phrase role="code">where</phrase></phrase>
								(Restriction)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">where</emphasis></phrase>
								(Restriction)</secondary></indexterm>Restriction</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> operator applies a condition to each row
					 of the input. Only rows for which the condition evaluates to true appear in the
					 result.</para> 
				<para>The where clause in D4 has the following syntax: 
					 <programlisting>&lt;where clause&gt; ::=
	<emphasis role="bold">where</emphasis> &lt;expression term&gt; [&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expression specified by 
					 <phrase role="code"><ulink
						  url="D4LGLanguageElements-Expressions.html"
						  type="link">&lt;expression&nbsp;term&gt;</ulink></phrase> must be
					 boolean-valued. Within the expression, access to the values of the input row
					 are available by column name.</para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> has the same columns, orders, references,
					 and metadata as the input table value. The restriction condition becomes a
					 constraint of the result. If the restriction condition uses an equality test
					 (<phrase role="code">=</phrase>) against a key column, that column will be
					 removed from the key if the equality comparison is part of a conjunction of
					 comparisons (<phrase role="code">&lt;comparison&gt; <emphasis
						  role="bold">and</emphasis> 
						  <phrase role="code">&lt;comparison&gt;</phrase>
						  <emphasis role="bold">and</emphasis>...</phrase>) that constitute the entire
					 restriction condition.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> are propagated directly to the input
					 table. The language modifier 
					 <phrase role="code">EnforcePredicate</phrase> can be used to
					 control whether or not the new row must satisfy the restriction condition. The
					 language modifier can be set to 
					 <phrase role="code">"true"</phrase> or 
					 <phrase role="code">"false"</phrase>. The default is 
					 <phrase role="code">"false"</phrase>.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">where</emphasis> ID &gt;= 4; </programlisting> 
					 <programlisting>ID Name
-- ---- 
4  Jeff
5  Jake
6  Jeff		</programlisting> </para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para> 
					 <ulink url="O-System.iRestrict.html"
					 type="olinka">System.iRestrict</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-OverandRemove"> 
				<title><indexterm><primary>Projection - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">over</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Projection
								(<phrase role="code"><emphasis role="bold">over</emphasis></phrase> and 
								<phrase role="code"><emphasis
									 role="bold">remove</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">over</emphasis></phrase>
								(Projection)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">remove</emphasis></phrase>
								(Projection)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">over</emphasis></phrase>
								(Projection)</secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">remove</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">remove</emphasis></phrase>
								(Projection)</secondary></indexterm>Projection</title> 
				<para>Projection allows a given set of columns to be removed from
					 the result. There are two methods for specifying the projection list in D4, 
					 <phrase role="code"><emphasis
						  role="bold">over</emphasis></phrase>, and 
					 <phrase role="code"><emphasis
						  role="bold">remove</emphasis></phrase>. The 
					 <phrase role="code"><emphasis
						  role="bold">over</emphasis></phrase> operator specifies the desired columns,
					 while 
					 <phrase role="code"><emphasis
						  role="bold">remove</emphasis></phrase> specifies the unwanted columns.</para> 
				<para>The over and remove clauses in D4 have the following syntax: 
					 <programlisting>&lt;over clause&gt; ::=
	<emphasis role="bold">over</emphasis> "{"&lt;column name commalist&gt;"}" [&lt;language modifiers&gt;]

&lt;remove clause&gt; ::=
	<emphasis role="bold">remove</emphasis> "{"&lt;column name commalist&gt;"}" [&lt;language modifiers&gt;]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The result of a projection has only the columns specified.
					 Only keys of the input which are completely included in the specified column
					 list are keys of the result. If all keys are excluded by the projection, the
					 key becomes all columns of the result, eliminating duplicates as necessary.
					 Only orders of the input which are completely included in the specified column
					 list are orders of the result. References of the input which are completely
					 included in the specified column list are references of the result.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">over</emphasis></phrase> or 
					 <phrase role="code"><emphasis
						  role="bold">remove</emphasis></phrase> are accomplished by performing the
					 corresponding modifications on the input table. An insert will be rejected if
					 the projection has excluded columns which do not have a default defined.</para>
				
				<para>The following example illustrates the use of the project
					 clause: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">over</emphasis> { Name }; </programlisting> 
					 <programlisting>Name 
---- 
Jake 
Jeff 
Joe 
John 
Josh </programlisting> </para> 
				<para>The following query is equivalent to the above example but
					 uses the remove clause instead: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">remove</emphasis> { ID }; </programlisting> 
					 <programlisting>Name 
---- 
Jake 
Jeff 
Joe 
John 
Josh </programlisting> </para> 
				<para> The following examples illustrate key inference in a
					 projection: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">where</emphasis> Name = "Jeff";</programlisting> 
					 <programlisting>ID Name 
-- ---- 
4  Jeff 
6  Jeff </programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">where</emphasis> Name = "Jeff" <emphasis role="bold">over</emphasis> { Name };</programlisting> 
					 <programlisting>Name 
---- 
Jeff </programlisting> </para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para><ulink url="O-System.iProject.html" type="olinka">
						  System.iProject</ulink> | 
					 <ulink url="O-System.iRemove.html"
					 type="olinka">System.iRemove</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Add"> 
				<title><indexterm><primary>Extension - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">add</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Extension
								(<phrase role="code"><emphasis
									 role="bold">add</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">add</emphasis></phrase>
								(Extension)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">add</emphasis></phrase>
								(Extension)</secondary></indexterm>Extension</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">add</emphasis></phrase> operator allows a table value to be
					 extended with new columns defined by expressions.</para> 
				<para>The add clause in D4 has the following syntax: 
					 <programlisting>&lt;add clause&gt; ::=
	<emphasis role="bold">add</emphasis> "{"&lt;ne named expression term commalist&gt;"}" [&lt;language modifiers&gt;]

&lt;named expression term&gt; ::=
	&lt;expression term&gt; &lt;qualified identifier&gt; &lt;metadata&gt;</programlisting></para> 
				<para>Expressions within the 
					 <phrase role="code">&lt;add&nbsp;clause&gt;</phrase> have
					 access to the values of the current row by column name.</para> 
				<para>The result of an 
					 <phrase role="code"><emphasis
						  role="bold">add</emphasis></phrase> has the same columns of the input, with the
					 additional columns as defined by 
					 <phrase
					 role="code">&lt;named&nbsp;expression&nbsp;term&nbsp;commalist&gt;</phrase>.
					 The result has the same keys, orders, references, and metadata as the input. In
					 addition, introduced columns based on order-preserving expressions of columns
					 that participate in keys in the input will result in keys in the output. For
					 example, the expression: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">add</emphasis> { ID ID1 }</programlisting> will have keys 
					 <phrase role="code">{ ID }</phrase> and 
					 <phrase role="code">{ ID1 }</phrase>.</para> 
				<para>Modifications to views defined using 
					 <phrase role="code"><emphasis
						  role="bold">add</emphasis></phrase> are propagated to the input by removing the
					 extended columns.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">add</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee 
	<emphasis role="bold">add</emphasis> { "Employee Name = " + Name NewName } 
	<emphasis role="bold">over</emphasis> { NewName }; </programlisting> 
					 <programlisting>NewName 
-------------------- 
Employee Name = Jake
Employee Name = Jeff
Employee Name = Joe
Employee Name = John
Employee Name = Josh </programlisting> </para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para><ulink url="O-System.iExtend.html"
					 type="olinka">System.iExtend</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Rename"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">rename</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">rename</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">rename</emphasis></phrase></secondary></indexterm>Rename</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">rename</emphasis></phrase> operator is used to rename columns in
					 the result. There are two variations of the 
					 <phrase role="code"><emphasis
						  role="bold">rename</emphasis></phrase> operator. One renames a specified set of
					 columns, and the other renames all the columns by qualifying each column name
					 with a given identifier.</para> 
				<para>The rename clause in D4 has the following syntax: 
					 <programlisting>&lt;rename clause&gt; ::=
	<emphasis role="bold">rename</emphasis> ("{"&lt;ne named column name commalist&gt;"}" | 
	(&lt;qualified identifier&gt; &lt;metadata&gt;))
	[&lt;language modifiers&gt;]

&lt;named column name&gt; ::=
	&lt;column name&gt; &lt;column name&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">rename</emphasis></phrase> operator has the same columns as the
					 input, with the names changed as specified. The keys, orders, and references
					 are included with the names of the columns involved updated appropriately. The
					 result has the same metadata as the input.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">rename</emphasis></phrase> are accomplished by transforming the
					 modifications as appropriate for the name changes.</para> 
				<para>The following examples illustrate the use of the 
					 <phrase role="code"><emphasis
						  role="bold">rename</emphasis></phrase> operator. 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">rename</emphasis> { ID EmployeeID, Name FirstName }; </programlisting> 
					 <programlisting>EmployeeID FirstName
---------- --------- 
1          Joe 
2          John
3          Josh
4          Jeff
5          Jake
6          Jeff </programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">rename</emphasis> X;</programlisting> 
					 <programlisting>X.ID X.Name
---- ------
1    Joe 
2    John 
3    Josh 
4    Jeff 
5    Jake 
6    Jeff</programlisting> </para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para><ulink url="O-System.iRename.html"
					 type="olinka">System.iRename</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Aggregate"> 
				<title><indexterm><primary>Aggregate - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">group</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Aggregate
								(<phrase role="code"><emphasis
									 role="bold">group</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">group</emphasis></phrase>
								(Aggregate)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">group</emphasis></phrase>
								(Aggregate)</secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis
									 role="bold">distinct</emphasis></phrase></primary></indexterm>Aggregate</title>
				
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">group</emphasis></phrase>, or <emphasis>aggregate</emphasis> table
					 operator allows operations based on sets of rows to be computed and added to
					 the result set. It should be noted that aggregation is not a primitive
					 operator, as it can be expressed in terms of other operators. For example, the
					 expression: 
					 <programlisting>Employee <emphasis role="bold">group by</emphasis> { Name } <emphasis role="bold">add</emphasis> { Count() NameCount }</programlisting>can also be expressed as: 
					 <programlisting>Employee <emphasis role="bold">over</emphasis> { Name } <emphasis role="bold">rename</emphasis> X
	<emphasis role="bold">add</emphasis> { Count(Employee <emphasis role="bold">where</emphasis> Name = X.Name) NameCount }</programlisting></para> 
				<para>The aggregate clause in D4 has the following syntax: 
					 <programlisting>&lt;aggregate clause&gt; ::=
	<emphasis role="bold">group</emphasis> [<emphasis role="bold">by</emphasis> "{"&lt;ne column name commalist&gt;"}"] 
		<emphasis role="bold">add</emphasis> "{"&lt;ne named aggregate expression commalist&gt;"}"
		[&lt;language modifiers&gt;]

&lt;named aggregate expression&gt; ::=
	&lt;aggregate expression&gt; &lt;column name&gt;

&lt;aggregate expression&gt; ::=
	&lt;operator name&gt;
	"("
		[<emphasis role="bold">distinct</emphasis>] 
		[&lt;column name commalist&gt;] 
		[<emphasis role="bold">order by</emphasis> "{"&lt;order column definition commalist&gt;"}"]
	")"

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;

&lt;operator name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The expression includes an optional 
					 <phrase role="code">&lt;by&nbsp;clause&gt;</phrase> which
					 specifies the grouping to be used for the aggregation. If no 
					 <phrase role="code">&lt;by&nbsp;clause&gt;</phrase> is
					 specified, the aggregation is performed for all the rows in the input.
					 Otherwise, the input is partitioned into groups based on the columns in the 
					 <phrase role="code">&lt;by&nbsp;clause&gt;</phrase>, and the
					 aggregation is performed once for each group. The optional 
					 <phrase role="code"><emphasis
						  role="bold">distinct</emphasis></phrase> specifier in the 
					 <phrase role="code">&lt;aggregate&nbsp;expression&gt;</phrase>
					 indicates that duplicates should be removed from the values for the source
					 column prior to performing the aggregation.</para> 
				<para>The 
					 <phrase role="code">&lt;aggregate&nbsp;expression&gt;</phrase>
					 specifies the aggregate operator to be invoked. This can be a system-provided
					 operator, or a user-defined operator, but it must be an aggregate operator. For
					 a complete description of aggregate operators, refer to the 
					 <ulink
					 url="D4LGCatalogElements-Operators-AggregateOperators.html"
					 type="xref">Aggregate Operators</ulink> discussion in this guide.</para> 
				<para>With the exception of the 
					 <phrase role="code">Count</phrase>, 
					 <phrase role="code">All</phrase>, and 
					 <phrase role="code">Any</phrase> operators, all the
					 system-provided aggregate operators return nil when invoked on an empty
					 set.</para> 
				<para>The result of the 
					 <phrase role="code"><emphasis
						  role="bold">group</emphasis></phrase> operation is a table with the columns
					 specified in the by clause and a column for each 
					 <phrase role="code">&lt;aggregate&nbsp;expression&gt;</phrase>.
					 The 
					 <phrase role="code">&lt;by&nbsp;clause&gt;</phrase> functions
					 as a projection so the keys of the result are determined the same as they would
					 be for projection over the columns in the 
					 <phrase role="code">&lt;by&nbsp;clause&gt;</phrase>. Orders,
					 references, and metadata are also inferred as they are for projection.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">group</emphasis></phrase> are accomplished by performing the
					 modifications as though the expression were written longhand. In other words,
					 the modifications are propagated through the equivalent projection and
					 extension operators.</para> 
				<para>For complete descriptions of the aggregate operators
					 available in D4, refer to 
					 <ulink url="O-System.AggregateOperators.html"
					 type="olinkb">Aggregate Operators</ulink> in the Dataphor System Library
					 Reference.</para> 
				<bridgehead renderas="sect3">See Also</bridgehead> 
				<para><ulink
					 url="D4LGCatalogElements-Operators-AggregateOperators.html"
					 type="xref">Aggregate Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Quota"> 
				<title><indexterm><primary>Quota - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Quota
								(<phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">return</emphasis></phrase>
								(Quota)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">return</emphasis></phrase>
								(Quota)</secondary></indexterm><indexterm><primary>Top - Quota
								Query</primary></indexterm><indexterm><primary>Bottom - Quota
								Query</primary></indexterm>Quota</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">return</emphasis></phrase>, or quota operator limits the result set
					 to a given number of rows based on a specified order. Note that invocation of
					 the 
					 <phrase role="code"><emphasis
						  role="bold">return</emphasis></phrase> operator does not guarantee that the
					 resulting set will have the given number of rows. There may be less, and there
					 may be more, depending on the data involved, as explained below.</para> 
				<para>The quota clause in D4 has the following syntax: 
					 <programlisting>&lt;quota clause&gt; ::=
	<emphasis role="bold">return</emphasis> &lt;expression term&gt; 
		[<emphasis role="bold">by</emphasis> "{"&lt;ne order column definition commalist&gt;"}"]
		[&lt;language modifiers&gt;]

&lt;order column definition&gt; ::=
	&lt;column name&gt; 
		[<emphasis role="bold">sort</emphasis> &lt;expression&gt;] 
		[<emphasis role="bold">asc</emphasis> | <emphasis role="bold">desc</emphasis>] 
		[(<emphasis role="bold">include</emphasis> | <emphasis role="bold">exclude</emphasis>) <emphasis role="bold">nil</emphasis>]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The expression specified by 
					 <phrase role="code">&lt;expression&nbsp;term&gt;</phrase> must
					 be integer-valued, and specifies the number of rows to be returned in the
					 result set. The actual number of rows returned may be lower if the input does
					 not have enough rows to fulfill the request.</para> 
				<para>Note that if the columns specified in the by clause do not
					 completely include some key of the input, then the actual cardinality of the
					 output may be more than the number specified by the return expression. This is
					 because the result will include rows that have the same values for the columns
					 specified in the by clause. If the by clause is omitted, the compiler will
					 select a key of the input to be used as the by specifier for the
					 operation.</para> 
				<para>If the quota operator specifies that a single row should be
					 returned (and the compiler can make this determination at compile time, i.e.
					 the return expression is literal and evaluates to 
					 <phrase role="code">1</phrase>), and the quota operation is
					 performed by some key of the input, the key of the output is the empty key.
					 Otherwise, every key of the input is also a key of the output.</para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">return</emphasis></phrase> operator has the same columns, orders,
					 references, and metadata as the input.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">return</emphasis></phrase> are propagated directly to the input.
					 The language modifier 
					 <phrase role="code">EnforcePredicate</phrase> can be used to
					 control whether or not the new row must satisfy the quota condition. The
					 language modifier can be set to 
					 <phrase role="code">"true"</phrase> or 
					 <phrase role="code">"false"</phrase>. The default is 
					 <phrase role="code">"false"</phrase>.</para> 
				<para>The following examples illustrate the use of the quota
					 operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">return</emphasis> 3 <emphasis role="bold">by</emphasis> { Name };</programlisting> 
					 <programlisting>ID Name
-- ----
5  Jake
4  Jeff
6  Jeff
1  Joe</programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">return</emphasis> 3 <emphasis role="bold">by</emphasis> { Name, ID };</programlisting> 
					 <programlisting>ID Name
-- ----
5  Jake
4  Jeff
6  Jeff				</programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">return</emphasis> 3 <emphasis role="bold">by</emphasis> { Name <emphasis role="bold">desc</emphasis> };		</programlisting> 
					 <programlisting>ID Name
-- ----
3  Josh
2  John
1  Joe </programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iQuota.html"
					 type="olinkb">System.iQuota</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Explode"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">explode</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">explode</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">explode</emphasis></phrase></secondary></indexterm><indexterm><primary>Hierarchical
								Queries</primary></indexterm>Explode</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">explode</emphasis></phrase> operator allows hierarchical queries to
					 be expressed. Optional include specifications allow both the sequence within
					 the hierarchy, and the level of the hierarchy to be included in the result
					 set.</para> 
				<para>The explode clause in D4 has the following syntax: 
					 <programlisting>&lt;explode clause&gt; ::=
	<emphasis role="bold">explode by</emphasis> &lt;expression term&gt; <emphasis role="bold">where</emphasis> &lt;expression term&gt; 
		[<emphasis role="bold">order by</emphasis> "{"&lt;order column definition commalist&gt;"}"]
		[<emphasis role="bold">include level</emphasis> [&lt;column name&gt;] &lt;metadata&gt;]
		[<emphasis role="bold">include sequence</emphasis> [&lt;column name&gt;] &lt;metadata&gt;]
		[&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expressions specified in the by clause and the 
					 <ulink url="D4LGTableExpressions-Where.html"
					 type="link">where</ulink> clause must be boolean-valued. The by clause
					 specifies the explode condition, and the where clause specifies the root
					 condition. Within the explode condition, the values of the current parent row
					 are accessible by the name of the column preceeded by the 
					 <phrase role="code"><emphasis
						  role="bold">parent</emphasis></phrase> keyword.</para> 
				<para>The optional 
					 <phrase role="code"><emphasis role="bold">order
						  by</emphasis></phrase> specification provides a mechanism for describing the
					 order in which rows will be processed in the explode.</para> 
				<para>The optional 
					 <phrase role="code"><emphasis role="bold">include
						  level</emphasis></phrase> specification indicates that a column of type 
					 <phrase role="code">System.Integer</phrase> and named 
					 <phrase role="code"><emphasis
						  role="bold">level</emphasis></phrase>, or 
					 <phrase role="code">&lt;column&nbsp;name&gt;</phrase> if
					 supplied, be included in the result set. The value for this column is the
					 nesting level for the row within the hierarchy.</para> 
				<para>The optional 
					 <phrase role="code"><emphasis role="bold">include
						  sequence</emphasis></phrase> specification indicates that a column of type 
					 <phrase role="code">System.Integer</phrase> and named 
					 <phrase role="code"><emphasis
						  role="bold">sequence</emphasis></phrase>, or 
					 <phrase role="code">&lt;column&nbsp;name&gt;</phrase> if
					 supplied, be included in the result set. The value for this column is the
					 sequence of the row within the hierarchy. The sequence column becomes a key of
					 the result.</para> 
				<para>Note that if level or sequence are included, the input to the
					 explode is required to be well-ordered (ordered by at least a key). This
					 requirement ensures that the operation is well-defined when used on graphs that
					 may have multiple parents for a single node (networks vs. hierarchies).</para> 
				<para>The result of an 
					 <phrase role="code"><emphasis
						  role="bold">explode</emphasis></phrase> operator has all the columns of the
					 input plus any included columns. All the keys are preserved, plus the key for
					 the sequence, if included. The orders, references, and metadata of the input
					 are preserved.</para> 
				<para>Modifications to views defined using 
					 <phrase role="code"><emphasis
						  role="bold">explode</emphasis></phrase> are propagated directly to the
					 input.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">explode</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Manager
		<emphasis role="bold">join</emphasis> (Employee <emphasis role="bold">rename</emphasis> { ID Manager_ID, Name Manager_Name })	
		<emphasis role="bold">join</emphasis> (Employee <emphasis role="bold">rename</emphasis> { ID Employee_ID, Name Employee_Name })	
		<emphasis role="bold">explode</emphasis> 
			<emphasis role="bold">by</emphasis> Manager_ID = <emphasis role="bold">parent</emphasis> Employee_ID
			<emphasis role="bold">where</emphasis> Manager_ID = 1 		
			<emphasis role="bold">include level</emphasis>		
			<emphasis role="bold">include sequence</emphasis>;</programlisting> 
					 <programlisting>Manager_ID Employee_ID Manager_Name Employee_Name level sequence
---------- ----------- ------------ ------------- ----- --------
1          2           Joe          John          1     1
2          4           John         Jeff          2     2
4          5           Jeff         Jake          3     3
2          6           John         Jeff          2     4
1          3           Joe          Josh          1     5</programlisting></para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iExplode.html"
					 type="olinkb">System.iExplode</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Adorn"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">adorn</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">adorn</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">adorn</emphasis></phrase></secondary></indexterm>Adorn</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator allows metadata and structural
					 information to be added to the result set.</para> 
				<para>The adorn clause in D4 has the following syntax: 
					 <programlisting>&lt;adorn clause&gt; ::=
	<emphasis role="bold">adorn</emphasis> ["{"&lt;ne adorn item definition commalist&gt;"}"] 
		&lt;metadata&gt;
		&lt;alter metadata&gt;
		[&lt;language modifiers&gt;]

&lt;adorn item definition&gt; ::=
	&lt;adorn column&gt; |
	&lt;key definition&gt; |
	(<emphasis role="bold">alter key</emphasis> "{"&lt;column name commalist&gt;"}" &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop key</emphasis> "{"&lt;column name commalist&gt;"}") |
	&lt;order definition&gt; |
	(<emphasis role="bold">alter order</emphasis> "{"&lt;order column definition commalist&gt;"}" &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop order</emphasis> "{"&lt;order column definition commalist&gt;"}") |
	&lt;row constraint definition&gt; |
	&lt;reference definition&gt; |
	(<emphasis role="bold">alter reference</emphasis> &lt;reference name&gt; &lt;alter metadata&gt;) |
	(<emphasis role="bold">drop reference</emphasis> &lt;reference name&gt;)
	
&lt;adorn column&gt; ::=
	&lt;column name&gt; 
		&lt;nilable definition&gt;
		["{"&lt;ne column definition item commalist&gt;"}"] 
		&lt;metadata&gt; 
		&lt;alter metadata&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator allows the definition of column
					 defaults, column constraints, column metadata, keys, orders, and constraints,
					 as well as the ability to alter the metadata for derived references, and
					 exclude inferred keys, orders, and references. Each of these constructs is
					 declared exactly as they are in the corresponding DDL statements. Note that
					 keys and references introduced by the adorn operator are only used as
					 structural information in the result set and are not enforced in the resulting
					 expression, or within the database. Other types of constraints introduced by
					 the 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator, such as row and transition
					 constraints, are enforced.</para> 
				<para>The result of an 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> operator has the same columns, keys,
					 orders, references, and metadata as the input, with the additional structural
					 and metadata information specified by the operator.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">adorn</emphasis></phrase> are propagated directly to the
					 input.</para> 
				<para>The following example illustrates the use of the adorn
					 operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">adorn</emphasis>
	{
		ID { <emphasis role="bold">default</emphasis> 0 } <emphasis role="bold">tags</emphasis> { Frontend.Width = "5" },
		<emphasis role="bold">constraint</emphasis> IDValid ID &gt; 5 
		<emphasis role="bold">tags</emphasis> { DAE.Message = "ID must be greater than 5" }
	};	</programlisting> 
					 <programlisting>ID Name 
-- ---- 
6  Jeff </programlisting></para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iAdorn.html"
					 type="olinkb">System.iAdorn</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Redefine"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">redefine</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">redefine</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">redefine</emphasis></phrase></secondary></indexterm>Redefine</title>
				
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">redefine</emphasis></phrase> operator is shorthand for an 
					 <phrase role="code"><emphasis
						  role="bold">add-remove-rename</emphasis></phrase> operation. For example, the
					 expression: 
					 <programlisting>Employee <emphasis role="bold">redefine</emphasis> { ID := ID * 2 }</programlisting>is equivalent to the following expression: 
					 <programlisting>Employee <emphasis role="bold">add</emphasis> { ID * 2 X } <emphasis role="bold">remove</emphasis> { ID } <emphasis role="bold">rename</emphasis> { X ID }</programlisting></para> 
				<para>The redefine clause in D4 has the following syntax: 
					 <programlisting>&lt;redefine clause&gt; ::=
	<emphasis role="bold">redefine</emphasis> "{"&lt;redefine column commalist&gt;"}" [&lt;language modifiers&gt;]
	
&lt;redefine column&gt; ::=
	&lt;column name&gt; := &lt;expression term&gt;

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>Each column is redefined in terms of an expression. Values of
					 the current row are accessible by name within the expression.</para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">redefine</emphasis></phrase> operation has the same column names as
					 the input, with the specified columns redefined as specified. If any redefined
					 column participates in a key, order, or reference, that structure is no longer
					 part of the result. If this results in the elimination of all the keys, the key
					 of the result is all the columns of the result.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">redefine</emphasis></phrase> are propagated as though the
					 equivalent 
					 <phrase role="code"><emphasis
						  role="bold">add-remove-rename</emphasis></phrase> expression had been
					 used.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">redefine</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">redefine</emphasis> { ID := ID * 2 };</programlisting> 
					 <programlisting>ID Name
-- ----
2  Joe
4  John
6  Josh
8  Jeff
10 Jake
12 Jeff</programlisting></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Specify"> 
				<title><indexterm><primary><phrase role="code">{}</phrase> -
								Specify Table Operator</primary></indexterm><indexterm><primary>Specify - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code">{}</phrase>
								(Specify)</secondary></indexterm><indexterm><primary>Operators</primary><secondary>Specify
								(<phrase
								role="code">{}</phrase>)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code">{}</phrase>
								(Specify)</secondary></indexterm>Specify</title> 
				<para>The specify operator (<phrase role="code">{}</phrase>) is
					 shorthand for an 
					 <phrase role="code"><emphasis
						  role="bold">add-project-rename</emphasis></phrase> operation. It allows the
					 desired column list to be specified in a single operation. The operation will
					 only include extension, and rename if necessary, but will always include a
					 projection over the specified column list.</para> 
				<para>The specify clause in D4 has the following syntax: 
					 <programlisting>&lt;specify clause&gt; ::=
	"{"&lt;optionally named expression commalist&gt;"}" [&lt;language modifiers&gt;]

&lt;optionally named expression&gt; ::=
	&lt;expression&gt; [&lt;column name&gt;]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>Each column specifies either a column from the source table,
					 or an expression that will be evaluated in terms of the source table, to be
					 included in the result set. If the column specifies an expression, it must also
					 specify a name for the column in the result set. Otherwise, the column may
					 optionally specify a new name for the column in the result set.</para> 
				<para>The following examples illustrate the use of the specify
					 operator: 
					 <programlisting>// Specify as projection
<emphasis role="bold">select</emphasis> Employee { ID };</programlisting> 
					 <programlisting>ID 
-- 
1  
2  
3  
4  
5  
6</programlisting> 
					 <programlisting>// Specify as rename
<emphasis role="bold">select</emphasis> Employee { ID Employee_ID, Name Employee_Name }</programlisting> 
					 <programlisting>Employee_ID Employee_Name 
----------- ------------- 
1           Joe           
2           John          
3           Josh          
4           Jeff          
5           Jake          
6           Jeff          </programlisting> 
					 <programlisting>// Specify as extension
<emphasis role="bold">select</emphasis> Employee { ID, Name, ID + 1 NewID }</programlisting> 
					 <programlisting>ID Name NewID 
-- ---- ----- 
1  Joe  2     
2  John 3     
3  Josh 4     
4  Jeff 5     
5  Jake 6     
6  Jeff 7     </programlisting></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Union"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">union</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">union</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">union</emphasis></phrase></secondary></indexterm>Union</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase> operator allows the rows of two table
					 values to be included in a single result set. If a given row appears in both
					 inputs, it will only appear once in the result. In other words, the 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase> operation eliminates duplicates.</para> 
				<para>The union clause in D4 has the following syntax: 
					 <programlisting>&lt;union clause&gt; ::=
	<emphasis role="bold">union</emphasis> &lt;expression term&gt; [&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expression given by 
					 <phrase role="code"><ulink
						  url="D4LGLanguageElements-Expressions.html"
						  type="link">&lt;expression&nbsp;term&gt;</ulink></phrase> must be table-valued.
					 Both inputs to the 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase> operation must be of the same table
					 type.</para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase> operation has the same type as the
					 inputs. The key of the result is all columns of the table. The result has the
					 orders, references, and metadata from both inputs.</para> 
				<para>Modifications to views defined using 
					 <phrase role="code"><emphasis
						  role="bold">union</emphasis></phrase> are propagated to the inputs 
					 <phrase role="code">A</phrase> and 
					 <phrase role="code">B</phrase> as follows: 
					 <itemizedlist> 
						  <listitem> 
								<para>Insert</para> 
								<para>If the newly inserted row can be inserted into 
									 <phrase role="code">A</phrase> or 
									 <phrase role="code">B</phrase>, it is. Note that
									 this implies that if the row can be inserted into both 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> it will appear in
									 both. Only if the row cannot be inserted into either 
									 <phrase role="code">A</phrase> or 
									 <phrase role="code">B</phrase> will the insert be
									 rejected.</para> 
						  </listitem> 
						  <listitem> 
								<para>Update</para> 
								<para>Update is treated as a delete of the original
									 row, followed by an insert of the new row. If both operations can be performed
									 against 
									 <phrase role="code">A</phrase> or 
									 <phrase role="code">B</phrase>, the operation is
									 accepted. Note that this implies that if the row can be updated in both 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase>, the update will be
									 performed on both. Only if the modification fails on both 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> is the update
									 rejected.</para> 
						  </listitem> 
						  <listitem> 
								<para>Delete</para> 
								<para>If the deleted row can be deleted from 
									 <phrase role="code">A</phrase> or 
									 <phrase role="code">B</phrase>, it is. Note that
									 this implies that if the row can be deleted from both 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> it will be deleted
									 from both. Only if the row cannot be delted from either 
									 <phrase role="code">A</phrase> or 
									 <phrase role="code">B</phrase> will the delete be
									 rejected.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following example illustrates the use of the union
					 operator: 
					 <programlisting><emphasis role="bold">select</emphasis> (Employee <emphasis role="bold">where</emphasis> ID &lt;= 4) <emphasis role="bold">union</emphasis> (Employee <emphasis role="bold">where</emphasis> ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name
-- ----
1  Joe
2  John
3  Josh
4  Jeff
5  Jake
6  Jeff </programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iUnion.html"
					 type="olinkb">System.iUnion</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Intersect"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">intersect</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">intersect</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">intersect</emphasis></phrase></secondary></indexterm>Intersect</title>
				
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">intersect</emphasis></phrase> operator computes the intersection of
					 two table values. If a given row appears in both inputs, it will appear in the
					 result.</para> 
				<para>The intersect clause in D4 has the following syntax: 
					 <programlisting>&lt;intersect clause&gt; ::=
	<emphasis role="bold">intersect</emphasis> &lt;expression term&gt; [&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expression given by 
					 <phrase role="code">&lt;expression term&gt;</phrase> must be
					 table-valued. Both inputs to the intersect operator must be of the same table
					 type.</para> 
				<para>Because 
					 <phrase role="code"><emphasis
						  role="bold">intersect</emphasis></phrase> is a special case of 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase>, it has the same semantics for type
					 inference and updatability. For this information, see 
					 <phrase role="code"><emphasis role="bold"><ulink
						  url="D4LGTableExpressions-Join.html"
						  type="xref">join</ulink></emphasis></phrase>.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">intersect</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> (Employee <emphasis role="bold">where</emphasis> ID &lt;= 4) <emphasis role="bold">intersect</emphasis> (Employee <emphasis role="bold">where</emphasis> ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name 
-- ---- 
3  Josh 
4  Jeff </programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="D4LGTableExpressions-Join.html"
					 type="link">Join</ulink> | 
					 <ulink url="D4LGTableExpressions-Times.html"
					 type="link">Times</ulink> | 
					 <ulink url="O-System.iJoin.html"
					 type="olinkb">Sytem.iJoin</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Minus"> 
				<title><indexterm><primary>Difference - Table
								Operator</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Difference
								(<phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">minus</emphasis></phrase>
								(Difference)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">minus</emphasis></phrase>
								(Difference)</secondary></indexterm>Minus</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">minus</emphasis></phrase> operator computes the difference of two
					 table values. Only rows appearing in the first input and not the second will
					 appear in the result.</para> 
				<para>The minus clause in D4 has the following syntax: 
					 <programlisting>&lt;minus clause&gt; ::=
	<emphasis role="bold">minus</emphasis> &lt;expression term&gt; [&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expression given by 
					 <phrase role="code">&lt;expression&nbsp;term&gt;</phrase> must
					 be table-valued. Both inputs to the 
					 <phrase role="code"><emphasis
						  role="bold">minus</emphasis></phrase> operator must be of the same table
					 type.</para> 
				<para>The result of the 
					 <phrase role="code"><emphasis
						  role="bold">minus</emphasis></phrase> operator has the same table type as both
					 of the inputs. Keys, orders, references, and metadata are inferred from the
					 first input.</para> 
				<para>Modifications to views defined using 
					 <phrase role="code"><emphasis
						  role="bold">minus</emphasis></phrase> are propagated to the inputs 
					 <phrase role="code">A</phrase> and 
					 <phrase role="code">B</phrase> as follows: 
					 <itemizedlist> 
						  <listitem> 
								<para>Insert</para> 
								<para>If the newly inserted row can be inserted into 
									 <phrase role="code">B</phrase>, it violates the
									 predicate of the difference, and an error is returned. Otherwise, it is
									 inserted into 
									 <phrase role="code">A</phrase>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Update</para> 
								<para>If the new version of the row can be inserted
									 into 
									 <phrase role="code">B</phrase>, it violates the
									 predicate of the difference, and an error is returned. Otherwise, the update is
									 performed against 
									 <phrase role="code">A</phrase>.</para> 
						  </listitem> 
						  <listitem> 
								<para>Delete</para> 
								<para>The deleted row is deleted from 
									 <phrase role="code">A</phrase>.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The following example illustrates the use of the minus
					 operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">minus</emphasis> (Employee where ID &gt;= 3); </programlisting> 
					 <programlisting>ID Name
-- ----
1  Joe
2  John </programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iDifference.html"
					 type="olinkb">System.iDifference</ulink> | 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Times"> 
				<title><indexterm><primary>Cartesian Product - Table
								Operator</primary></indexterm><indexterm><primary>Cross
								Join</primary><see><phrase role="code"><emphasis
									 role="bold">times</emphasis></phrase> - Table
								Operator</see></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">times</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Cartesian
								Product (<phrase role="code"><emphasis
									 role="bold">times</emphasis></phrase>)</secondary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">times</emphasis></phrase> (Cartesian
								Product)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">times</emphasis></phrase> (Cartesian
								Product)</secondary></indexterm>Times</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">times</emphasis></phrase> operator computes the cartesian product
					 (also called the cross join) of the inputs. For every row in the first input, a
					 row appears in the result for every row in the second input that is the
					 concatenation of both rows.</para> 
				<para>The times clause in D4 has the following syntax: 
					 <programlisting>&lt;times clause&gt; ::=
	<emphasis role="bold">times</emphasis> &lt;expression term&gt; [&lt;language modifiers&gt;]</programlisting></para> 
				<para>The expression given by 
					 <phrase role="code">&lt;expression&nbsp;term&gt;</phrase> must
					 be table-valued. Inputs must have no column names in common.</para> 
				<para>Because 
					 <phrase role="code"><emphasis
						  role="bold">times</emphasis></phrase> is a special case of 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase>, it has the same semantics for type
					 inference and updatability. For this information, see 
					 <phrase role="code"><emphasis role="bold"><ulink
						  url="D4LGTableExpressions-Join.html"
						  type="xref">join</ulink></emphasis></phrase>.</para> 
				<para>The following example illustrates the use of the 
					 <phrase role="code"><emphasis
						  role="bold">times</emphasis></phrase> operator: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">times</emphasis> (Employee <emphasis role="bold">rename</emphasis> { Name FirstName } <emphasis role="bold">over</emphasis> { FirstName }); </programlisting> 
					 <programlisting>ID Name FirstName
-- ---- ---------
1  Joe  Jake
1  Joe  Jeff
1  Joe  Joe
1  Joe  John
1  Joe  Josh
2  John Jake
2  John Jeff
2  John Joe
2  John John
2  John Josh
3  Josh Jake
3  Josh Jeff
3  Josh Joe
3  Josh John
3  Josh Josh
4  Jeff Jake
4  Jeff Jeff
4  Jeff Joe
4  Jeff John
4  Jeff Josh
5  Jake Jake
5  Jake Jeff
5  Jake Joe
5  Jake John
5  Jake Josh
6  Jeff Jake
6  Jeff Jeff
6  Jeff Joe
6  Jeff John
6  Jeff Josh</programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iJoin.html"
					 type="olinkb">System.iJoin</ulink> | 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Join"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">join</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">join</emphasis></phrase></secondary></indexterm>Join</title> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator computes the combination of two
					 table values based on the matching rows for a given set of columns. There are
					 two types of joins in D4, the <emphasis>natural join</emphasis> and the
					 <emphasis>conditioned join</emphasis>. </para> 
				<para>The natural join simply takes two table values as input and
					 uses the commonly named columns to perform the join. The conditioned join
					 includes a by clause which specifies the join condition.</para> 
				<para>Note that the two forms of the 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator are equivalent in terms of
					 expressive power. Both forms are included in D4 to allow for different user
					 preferences. The natural join lends itself to a database design in which column
					 names are unique across the database, while the conditioned join lends itself
					 to a design in which column names are only unique within tables.</para> 
				<para>The join clause in D4 has the following syntax: 
					 <programlisting>&lt;join clause&gt; ::=
	<emphasis role="bold">join</emphasis> &lt;join specifier&gt; [&lt;language modifiers&gt;]

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [<emphasis role="bold">by</emphasis> &lt;expression term&gt;]</programlisting></para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator on inputs 
					 <phrase role="code">A</phrase> and 
					 <phrase role="code">B</phrase> having column sets 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase>, where 
					 <phrase role="code">A</phrase> has the columns 
					 <phrase role="code">{ X, Y }</phrase> and 
					 <phrase role="code">B</phrase> has the columns 
					 <phrase role="code">{ Y, Z }</phrase> has the columns 
					 <phrase role="code">{ X, Y, Z }</phrase>. 
					 <phrase role="code">Y</phrase> represents the columns common to
					 both inputs. Note that each of 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase> may be an empty set. For a
					 conditioned join, 
					 <phrase role="code">Y</phrase> is required to be an empty
					 set.</para> 
				<para>The body of the result has a row for each row in 
					 <phrase role="code">A</phrase> that matches the values for the
					 columns given in 
					 <phrase role="code">Y</phrase> for natural joins, or the
					 condition for conditioned joins, for each row in 
					 <phrase role="code">B</phrase>. The 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator is equivalent to a cartesian
					 product of the inputs, followed by a restriction using the join
					 condition.</para> 
				<para>Based on the join condition and the key information of the
					 join operands, the <emphasis>cardinality</emphasis> of the join can be
					 determined. The cardinality of a given join is the relationship between the
					 number of rows in the left input and the number of potentially matching rows in
					 the right input. There are four possibilities: 
					 <itemizedlist> 
						  <indexterm><primary>Join Cardinality</primary></indexterm> 
						  <listitem> 
								<indexterm><primary>One-to-one
										  Join</primary></indexterm> 
								<para>One-to-one</para> 
								<para>If the join columns completely include some key
									 in both inputs, the join is one-to-one. In other words, there will only ever be
									 one matching row in the right input for a given row in the left input, and vice
									 versa.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>One-to-many
										  Join</primary></indexterm> 
								<para>One-to-many</para> 
								<para>If the join columns completely include some key
									 of the left input, but not of the right input, the join is one-to-many. In
									 other words, there may be any number of rows in the right input for any given
									 row in the left input.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Many-to-one
										  Join</primary></indexterm> 
								<para>Many-to-one</para> 
								<para>If the join columns completely include some key
									 of the right input, but not of the left input, the join is many-to-one. In
									 other words, there may be any number of rows in the left input for any given
									 row in the right input.</para> 
						  </listitem> 
						  <listitem> 
								<indexterm><primary>Many-to-many
										  Join</primary></indexterm> 
								<para>Many-to-many</para> 
								<para>If the join columns do not completely include any
									 key of the left or right inputs, the join is many-to-many. In other words,
									 there may be any number of rows in the left input that match any number of rows
									 in the right input, and vice versa.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>The cardinality of a join effectively determines the
					 cardinality of the result. In addition to aiding the Dataphor Server in access
					 path selection and optimization tasks, this information is used to determine
					 how keys and orders are inferred through the join operation: 
					 <itemizedlist> 
						  <indexterm><primary>Join Key
									 Inference</primary></indexterm> 
						  <listitem> 
								<para>One-to-one</para> 
								<para>For one-to-one joins, every key of the left and
									 right inputs is also a key of the output. In the case of natural joins,
									 duplicate keys are eliminated, resulting in a single key in the output.</para> 
								<para>For one-to-one joins, every order of the left and
									 right inputs is also an order of the output, with duplicate orders eliminated
									 in the case of natural joins.</para> 
						  </listitem> 
						  <listitem> 
								<para>One-to-many</para> 
								<para>For one-to-many joins, every key of the right
									 input is also a key of the output, plus a key for each key of the right input
									 with join columns replaced by their correlated columns from the left
									 input.</para> 
								<para>For one-to-many joins, every order of the right
									 input is also an order of the output, with duplicate orders eliminated in the
									 case of natural joins.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-one</para> 
								<para>For many-to-one joins, every key of the left
									 input is also a key of the output, plus a key for each key of the left input
									 with join columns replaced by their correlated columns from the right
									 input.</para> 
								<para>For many-to-one joins, every order of the left
									 input is also an order of the output, with duplicate orders eliminated in the
									 case of natural joins.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-many</para> 
								<para>For many-to-many joins, every key of the left
									 input is combined with every key of the right output to form a key in the
									 output. In other words, the output has the cartesian product of all keys of
									 both inputs, with duplicates eliminated in the case of natural joins. In
									 addition, for conditioned joins only one column from each join condition will
									 appear in any given key.</para> 
								<para>No orders are inferred for many-to-many
									 joins.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>For all types of joins, every source or target reference from
					 both inputs that does not completely include the join columns is a source or
					 target reference of the output, respectively. In other words, references that
					 include the common columns of the join will not be inferred.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> are supported by projecting the
					 modifications over the columns of each input.</para> 
				<para>The following sections describe the natural and conditioned
					 joins.</para> 
				<sect2 id="D4LGTableExpressions-Join-NaturalJoins"> 
					 <title><indexterm><primary>Natural Join - Table
									 Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Natural
									 Join (<phrase role="code"><emphasis
										  role="bold">join</emphasis></phrase>)</secondary></indexterm><indexterm><primary><phrase
									 role="code"><emphasis role="bold">join</emphasis></phrase> - Table
									 Operator</primary><secondary>Natural Joins</secondary></indexterm>Natural
						  Joins</title> 
					 <para>The natural join uses the commonly named columns, if any,
						  in the inputs to perform the join. A natural join is by definition an
						  <emphasis>equi-join</emphasis>. The commonly named columns are only included
						  once in the result.</para> 
					 <para>If the inputs have no column names in common, the natural
						  join degrades to times. If the inputs have all column names in common, the
						  natural join becomes an intersection. In both cases, type inference and
						  updatability are unaffected. Note that if a natural join results in a times
						  operation, the compiler will report a warning that a possibly incorrect times
						  expression has been issued 
						  <footnote> 
								<para>This warning can be suppressed using the 
									 <phrase role="code">IsTimes</phrase>
									 modifier.</para> 
						  </footnote>.</para> 
					 <para>The following example illustrates the use of the natural 
						  <phrase role="code"><emphasis
								role="bold">join</emphasis></phrase> operator: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">join</emphasis> EmployeePhone;			  </programlisting> 
						  <programlisting>ID Name   Phone
--  ----  --------
1  Joe    555-1000 
1  Joe    555-1234 
2  John   555-4321
4  Jeff   555-4444 
5  Jake   555-5678 </programlisting> </para> 
				</sect2> 
				<sect2 id="D4LGTableExpressions-Join-ConditionedJoins"> 
					 <title><indexterm><primary>Conditioned Join - Table
									 Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Conditioned
									 Join (<phrase role="code"><emphasis
										  role="bold">join</emphasis>..<emphasis
										  role="bold">by</emphasis></phrase>)</secondary></indexterm><indexterm><primary><phrase
									 role="code"><emphasis role="bold">join</emphasis></phrase> - Table
									 Operator</primary><secondary>Conditioned
									 Joins</secondary></indexterm>Conditioned Joins</title> 
					 <para>The conditioned join allows the join condition to be
						  specified as part of the join. The input tables must have no column names in
						  common.</para> 
					 <para>The expression specified within the by clause by 
						  <phrase role="code"><ulink
								url="D4LGLanguageElements-Expressions.html"
								type="link">&lt;expression&nbsp;term&gt;</ulink></phrase> must be
						  boolean-valued and must specify an equi-join. These requirements are enforced
						  by the compiler. Within the expression, the current values of both rows are
						  accessible by column name.</para> 
					 <para>The following example illustrates the use of the
						  conditioned 
						  <phrase role="code"><emphasis
								role="bold">join</emphasis></phrase> operator: 
						  <programlisting><emphasis role="bold">select</emphasis> (Employee <emphasis role="bold">rename</emphasis> E) 
	<emphasis role="bold">join</emphasis> (EmployeePhone <emphasis role="bold">rename</emphasis> EP) 
		<emphasis role="bold">by</emphasis> E.ID = EP.ID<emphasis role="bold"> 
	remove</emphasis> { EP.ID };</programlisting> 
						  <programlisting>E.ID   E.Name    EP.Phone
------ --------  ----------- 
1      Joe       555-1000 
1      Joe       555-1234 
2      John      555-4321 
4      Jeff      555-4444 
5      Jake      555-5678 </programlisting> </para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink url="O-System.iJoin.html"
						  type="olinkb">System.iJoin</ulink> | 
						  <ulink url="D4LGTableExpressions.html" type="xref">Table
								Operators</ulink></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-OuterJoin"> 
				<title><indexterm><primary>Outer Join - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary>Outer
								Join</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary>Outer Join (<phrase role="code"><emphasis
									 role="bold">left</emphasis></phrase> or 
								<phrase role="code"><emphasis role="bold">right
									 join</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">lookup</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis
									 role="bold">lookup</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">lookup</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">join</emphasis></phrase> - Table
								Operator</primary><secondary>Outer
								Join</secondary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">left join</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">left
									 join</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis role="bold">left
									 join</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">right join</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">right
									 join</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis role="bold">right
									 join</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">left lookup</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">left
									 lookup</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis role="bold">left
									 lookup</emphasis></phrase></secondary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">right lookup</emphasis></phrase> - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">right
									 lookup</emphasis></phrase></secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis role="bold">right
									 lookup</emphasis></phrase></secondary></indexterm><indexterm><primary>RowExists
								- Join Column</primary></indexterm>Outer Join</title> 
				<para>The result of an outer 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> is the same as a 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase>, except that rows in one side for which no
					 matching row was found are still included in the result set, with the columns
					 for the side with no matching row in the input set to nil.</para> 
				<para>In addition to specifying a natural or conditioned outer
					 join, the outer join may be 
					 <phrase role="code"><emphasis
						  role="bold">left</emphasis></phrase> or 
					 <phrase role="code"><emphasis
						  role="bold">right</emphasis></phrase>. Left indicates that all rows in the left
					 input should be preserved, while right indicates that all rows in the right
					 input should be preserved.</para> 
				<para>The outer join clause in D4 has the following syntax: 
					 <programlisting>&lt;outer join clause&gt; ::=
	(<emphasis role="bold">left</emphasis> | <emphasis role="bold">right</emphasis>) (<emphasis role="bold">join</emphasis> | <emphasis role="bold">lookup</emphasis>) &lt;join specifier&gt;
		[<emphasis role="bold">include rowexists</emphasis> [&lt;column name&gt;] &lt;metadata&gt;]
		[&lt;language modifiers&gt;]

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [<emphasis role="bold">by</emphasis> &lt;expression term&gt;]

&lt;column name&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
				<para>The keys of the result are inferred from the keys of both
					 inputs, and the cardinality of the join: 
					 <itemizedlist> 
						  <listitem> 
								<para>One-to-one:</para> 
								<para>The result has all the keys of the left and right
									 input tables. If the join is left outer, the keys of the right table are
									 inferred as <emphasis>sparse</emphasis> keys. If the join is right outer, the
									 keys of the left table are inferred as sparse keys.</para> 
						  </listitem> 
						  <listitem> 
								<para>One-to-many:</para> 
								<para>The result has all the keys of the right input,
									 plus a corresponding key for each key of the right input that has columns in
									 common with the join columns. The join columns in the corresponding keys are
									 replaced with the corresponding join columns in the left input. If the join is
									 left outer, the corresponding keys are inferred as sparse keys.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-one:</para> 
								<para>The result has all the keys of the left input,
									 plus a corresponding key for each key of the left input that has columns in
									 common with the join columns. The join columns in the corresponding keys are
									 replaced with the corresponding join columns in the right input. If the join is
									 right outer, the corresponding keys are inferred as sparse keys.</para> 
						  </listitem> 
						  <listitem> 
								<para>Many-to-many:</para> 
								<para>For each key in the first input, for each key in
									 the second input, the result has a key that is the union of the columns in both
									 keys. In other words, the result has the cartesian product of the keys of both
									 inputs. In addition, for conditioned joins only one column from each join
									 condition will appear in any given key.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Order and reference inference for an outer 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> is the same as for a standard 
					 <phrase role="code"><emphasis role="bold"><ulink
						  url="D4LGTableExpressions-Join.html"
						  type="link">join</ulink></emphasis></phrase>.</para> 
				<para>The optional 
					 <phrase role="code"><emphasis
						  role="bold">rowexists</emphasis></phrase> column is used to indicate whether a
					 row is an actual join match, or is included in the result because the 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> is outer. This column is boolean-valued,
					 and will be true whenever the row is a join match, and false otherwise. This
					 column is updatable, and causes the insertion or deletion of a row in the outer
					 input of the operation. Setting the 
					 <phrase role="code"><emphasis
						  role="bold">rowexists</emphasis></phrase> column true causes a row to be
					 inserted into the outer input, while setting the 
					 <phrase role="code"><emphasis
						  role="bold">rowexists</emphasis></phrase> column false causes a row to be
					 deleted from the outer input.</para> 
				<para>The 
					 <phrase role="code"><emphasis
						  role="bold">lookup</emphasis></phrase> operator has the same semantics for
					 retrieval, but modifications do not propagate through the 
					 <phrase role="code"><emphasis
						  role="bold">lookup</emphasis></phrase>. For example, in a view defined by 
					 <phrase role="code">A <emphasis role="bold">left
						  lookup</emphasis> B</phrase>, an insert would be propagated to 
					 <phrase role="code">A</phrase>, but not to 
					 <phrase role="code">B</phrase>. The 
					 <phrase role="code"><emphasis
						  role="bold">lookup</emphasis></phrase> operator is used primarily by client
					 applications to control the update semantics involved in an expression.</para> 
				<para>The following examples illustrate the use of the outer 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operators: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">left join</emphasis> EmployeePhone;</programlisting> 
					 <programlisting>ID  Name Phone 
-- ----  ---------- 
1  Joe   555-1000 
1  Joe   555-1234 
2  John  555-4321 
3  Josh  &lt;no value&gt; 
4  Jeff  555-4444 
5  Jake  555-5678 
6  Jeff  &lt;no value&gt; </programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">right join</emphasis> EmployeePhone;	  </programlisting> 
					 <programlisting>ID  Name       Phone 
--  ---------- -------- 
1   Joe        555-1000
1   Joe        555-1234 
2   John       555-4321 
4   Jeff       555-4444 
5   Jake       555-5678 
10 &lt;no value&gt;  411 
12 &lt;no value&gt;  911 </programlisting> 
					 <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">left lookup</emphasis> EmployeePhone <emphasis role="bold">include rowexists</emphasis> Extended; </programlisting> 
					 <programlisting>ID Name Extended Phone 
-- ---- -------- ----------
1  Joe  True     555-1000 
1  Joe  True     555-1234 
2  John True     555-4321 
3  Josh False    &lt;no value&gt; 
4  Jeff True     555-4444 
5  Jake True     555-5678 
6  Jeff False    &lt;no value&gt; </programlisting> 
					 <programlisting><emphasis role="bold">create view</emphasis> EmpWithPhone
	Employee <emphasis role="bold">left lookup</emphasis> EmployeePhone;

<emphasis role="bold">select</emphasis> EmpWithPhone; </programlisting> 
					 <programlisting>ID Name Phone
-- ---- ----------
1  Joe  555-1000
1  Joe  555-1234 
2  John 555-4321 
3  Josh &lt;no value&gt; 
4  Jeff 555-4444 
5  Jake 555-5678 
6  Jeff &lt;no value&gt; </programlisting> 
					 <programlisting>// will be ignored since phone is across lookup
<emphasis role="bold">update</emphasis> EmpWithPhone <emphasis role="bold">set</emphasis> { Phone := "1701" };
<emphasis role="bold">select</emphasis> EmpWithPhone; </programlisting> 
					 <programlisting>ID Name  Phone
-- ----  ----------
1  Joe   555-1000
1  Joe   555-1234 
2  John  555-4321 
3  Josh  &lt;no value&gt; 
4  Jeff  555-4444 
5  Jake  555-5678 
6  Jeff  &lt;no value&gt; </programlisting> </para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iJoin.html"
					 type="olinkb">System.iJoin</ulink> | 
					 <ulink url="O-System.iLeftJoin.html"
					 type="olinkb">System.iLeftJoin</ulink> | 
					 <ulink url="O-System.iRightJoin.html"
					 type="olinkb">System.iRightJoin</ulink> | 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Having"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">having</emphasis></phrase> (Semijoin) - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">having</emphasis></phrase>
								(Semijoin)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">having</emphasis></phrase>
								(Semijoin)</secondary></indexterm><indexterm><primary>Semijoin</primary><see><phrase
								role="code"><emphasis
									 role="bold">having</emphasis></phrase></see></indexterm>Semijoin</title> 
				<para>In addition to the traditional join, the D4 language includes
					 a semijoin operator called 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase>. Loosely speaking, the operator computes
					 the set of rows from the left input for which a matching row exists in the
					 right input. It is equivalent to a join, followed by a projection over the
					 columns of the right input. For example, the following query expressed using 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase>: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">having</emphasis> (EmployeeDepartment { Employee_ID ID })</programlisting>is equivalent to the following 
					 <phrase role="code"><emphasis
						  role="bold">join-project</emphasis></phrase>: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">join</emphasis> (EmployeeDepartment { Employee_ID ID, Department_ID })
	<emphasis role="bold">over</emphasis> { ID, Name }</programlisting></para> 
				<para>As with the 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator, there are two flavors of
					 semijoin, the natural and conditioned semijoin. However, because the result set
					 will always be projected over the columns of the left input, conditioned
					 semijoins are not required to have unique column names. For example, the 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> above could be written: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">having</emphasis> EmployeeDepartment
		<emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting></para> 
				<para>In addition, the semijoin condition can make use of the
					 keywords 
					 <phrase role="code"><emphasis
						  role="bold">left</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">right</emphasis></phrase> to distinguish potentially ambiguous
					 column names, as in: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">having</emphasis> EmployeeDepartment
		<emphasis role="bold">by</emphasis> <emphasis role="bold">left</emphasis>.ID = <emphasis role="bold">right</emphasis>.Employee_ID</programlisting></para> 
				<para>The having clause in D4 has the following syntax: 
					 <programlisting>&lt;having clause&gt; ::=
	<emphasis role="bold">having</emphasis> &lt;join specifier&gt; [&lt;language modifiers&gt;]

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [<emphasis role="bold">by</emphasis> &lt;expression term&gt;]</programlisting></para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> operator on inputs 
					 <phrase role="code">A</phrase> and 
					 <phrase role="code">B</phrase> having column sets 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase>, where 
					 <phrase role="code">A</phrase> has the columns 
					 <phrase role="code">{ X, Y }</phrase> and 
					 <phrase role="code">B</phrase> has the columns 
					 <phrase role="code">{ Y, Z }</phrase> has the columns 
					 <phrase role="code">{ X, Y }</phrase>. As with the 
					 <phrase role="code">join</phrase> operator, 
					 <phrase role="code">Y</phrase> represents the columns common to
					 both inputs, and each of 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase> may be an empty set. Unlike the 
					 <phrase role="code">join</phrase>, 
					 <phrase role="code">Y</phrase> is not required to be empty for
					 a conditioned semijoin.</para> 
				<para>The body of the result has a row for each row in 
					 <phrase role="code">A</phrase> that matches the values for the
					 columns given in 
					 <phrase role="code">Y</phrase> for natural joins, or the
					 condition for conditioned joins, for any row in 
					 <phrase role="code">B</phrase>. Note carefully the difference
					 in cardinality from a 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator. The cardinality of the result of
					 a 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> will always be less than or equal to the
					 cardinality of the left input.</para> 
				<para>As stated above, the semijoin is equivalent to a 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> followed by a projection over the columns
					 of the left input.</para> 
				<para>Another way of expressing the semijoin operation is with the 
					 <phrase role="code"><emphasis
						  role="bold">exists</emphasis></phrase> operator in a restriction condition. For
					 example: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">where exists</emphasis> (EmployeeDepartment <emphasis role="bold">where</emphasis> Employee_ID = ID)</programlisting>In other words, the semijoin operator is a restriction based
					 on the existence of a matching row in the right input. Because of this, the
					 rules governing inference and updatability for the 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> operator most closely resemble that of
					 the 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> operator. Namely, all columns, keys,
					 orders, references, and metadata of the left input are inferred for the
					 result.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> are propagated directly to the left
					 input. The language modifier 
					 <phrase role="code">EnforcePredicate</phrase> can be used to
					 control whether or not the new row must satisfy the semijoin condition. The
					 language modifier can be set to 
					 <phrase role="code">"true"</phrase> or 
					 <phrase role="code">"false"</phrase>, with 
					 <phrase role="code">"false"</phrase> being the default.</para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iJoin.html"
					 type="olinkb">System.iHaving</ulink> | 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-Without"> 
				<title><indexterm><primary><phrase role="code"><emphasis
									 role="bold">without</emphasis></phrase> (Semiminus) - Table
								Operator</primary></indexterm><indexterm><primary>Operators</primary><secondary><phrase
								role="code"><emphasis role="bold">without</emphasis></phrase>
								(Semiminus)</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary><phrase role="code"><emphasis
									 role="bold">without</emphasis></phrase>
								(Semiminus)</secondary></indexterm><indexterm><primary>Semiminus</primary><see><phrase
								role="code"><emphasis
									 role="bold">without</emphasis></phrase></see></indexterm>Semiminus</title> 
				<para>The semiminus, or 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase>, operator computes the set of rows from
					 the left input for which a matching row does not exist in the right input. This
					 operator is effectively the opposite of a semijoin, in that it is a restriction
					 with a 
					 <phrase role="code"><emphasis role="bold">not
						  exists</emphasis></phrase> in the condition. For example: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">without</emphasis> (EmployeeDepartment { Employee_ID ID, Department_ID })</programlisting>is equivalent to: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">where not exists</emphasis> (EmployeeDepartment <emphasis role="bold">where</emphasis> Employee_ID = ID)</programlisting></para> 
				<para>As with the 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">having</emphasis></phrase> operators, there are two flavors of
					 semiminus, the natural and conditioned semiminus. The result set will always be
					 projected over the columns of the left input, so the conditioned semiminus is
					 not required to have unique column names. For example, the 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase> above could be written: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">without</emphasis> EmployeeDepartment
		<emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting></para> 
				<para>In addition, the semiminus condition can make use of the
					 keywords 
					 <phrase role="code"><emphasis
						  role="bold">left</emphasis></phrase> and 
					 <phrase role="code"><emphasis
						  role="bold">right</emphasis></phrase> to distinguish potentially ambiguous
					 column names, as in: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">without</emphasis> EmployeeDepartment
		<emphasis role="bold">by</emphasis> <emphasis role="bold">left</emphasis>.ID = <emphasis role="bold">right</emphasis>.Employee_ID</programlisting></para> 
				<para>The without clause in D4 has the following syntax: 
					 <programlisting>&lt;without clause&gt; ::=
	<emphasis role="bold">without</emphasis> &lt;join specifier&gt; [&lt;language modifiers&gt;]

&lt;join specifier&gt; ::=
	&lt;expression term&gt; [<emphasis role="bold">by</emphasis> &lt;expression term&gt;]</programlisting></para> 
				<para>The result of a 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase> operator on inputs 
					 <phrase role="code">A</phrase> and 
					 <phrase role="code">B</phrase> having column sets 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase>, where 
					 <phrase role="code">A</phrase> has the columns 
					 <phrase role="code">{ X, Y }</phrase> and 
					 <phrase role="code">B</phrase> has the columns 
					 <phrase role="code">{ Y, Z }</phrase> has the columns 
					 <phrase role="code">{ X, Y }</phrase>. As with the 
					 <phrase role="code">join</phrase> operator, 
					 <phrase role="code">Y</phrase> represents the columns common to
					 both inputs, and each of 
					 <phrase role="code">X</phrase>, 
					 <phrase role="code">Y</phrase>, and 
					 <phrase role="code">Z</phrase> may be an empty set. Unlike the 
					 <phrase role="code">join</phrase>, 
					 <phrase role="code">Y</phrase> is not required to be empty for
					 a conditioned semiminus.</para> 
				<para>The body of the result has a row for each row in 
					 <phrase role="code">A</phrase> that has no matching row in 
					 <phrase role="code">B</phrase> based on the values for the
					 columns given in 
					 <phrase role="code">Y</phrase> for natural joins, or the
					 condition for conditioned joins. The cardinality of the result of a 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase> will always be less than or equal to
					 the cardinality of the left input.</para> 
				<para>Another way of expressing the semijoin operation is with the 
					 <phrase role="code"><emphasis
						  role="bold">exists</emphasis></phrase> operator in a restriction condition. For
					 example: 
					 <programlisting><emphasis role="bold">select</emphasis> Employee
	<emphasis role="bold">where exists</emphasis> (EmployeeDepartment <emphasis role="bold">where</emphasis> Employee_ID = ID)</programlisting>As with the semijoin, the semiminus operator is basically a
					 restriction of the left input. Because of this, the rules governing inference
					 and updatability for the 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase> operator most closely resemble that of
					 the 
					 <phrase role="code"><emphasis
						  role="bold">where</emphasis></phrase> operator. Namely, all columns, keys,
					 orders, references, and metadata of the left input are inferred for the
					 result.</para> 
				<para>Data modifications against views defined using 
					 <phrase role="code"><emphasis
						  role="bold">without</emphasis></phrase> are propagated directly to the left
					 input. The language modifier 
					 <phrase role="code">EnforcePredicate</phrase> can be used to
					 control whether or not the new row must satisfy the semijoin condition. The
					 language modifier can be set to 
					 <phrase role="code">"true"</phrase> or 
					 <phrase role="code">"false"</phrase>, with 
					 <phrase role="code">"false"</phrase> being the default.</para> 
				<bridgehead>See Also</bridgehead> 
				<para><ulink url="O-System.iWithout.html"
					 type="olinkb">System.iWithout</ulink> | 
					 <ulink url="D4LGTableExpressions.html" type="xref">Table
						  Operators</ulink></para> 
		  </sect1> 
		  <sect1 id="D4LGTableExpressions-ComparisonOperators"> 
				<title><indexterm><primary>Comparison
								Operators</primary><secondary>For
								Tables</secondary></indexterm><indexterm><primary>Table
								Operators</primary><secondary>Comparison
								Operators</secondary></indexterm>Comparison Operators</title> 
				<para>The following comparison operators are defined for tables: 
					 <itemizedlist> 
						  <listitem> 
								<para><phrase role="code"><ulink
										  url="O-System.iEqual.html" type="olinka">iEqual</ulink></phrase>(<phrase
									 role="code">=</phrase>) and 
									 <phrase role="code"><ulink
										  url="O-System.iNotEqual.html" type="olinka">iNotEqual</ulink></phrase>(<phrase
									 role="code">&lt;&gt;</phrase>)</para> 
								<para>iEqual returns true if the given table values are
									 equal. iNotEqual returns true if the two table values are not equal.</para> 
								<para> Two table values are equal if they are of the
									 same table type, and they have the same set of rows. For example: 
									 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable1 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };
	<emphasis role="bold">var</emphasis> LTable2 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };

	<emphasis role="bold">if not</emphasis>(LTable1 = LTable2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("Table values are not equal");

	// equivalent formulation
	<emphasis role="bold">if not exists</emphasis>(LTable1 <emphasis role="bold">minus</emphasis> LTable2) <emphasis role="bold">and</emphasis> 
		<emphasis role="bold">not exists</emphasis> (LTable2 <emphasis role="bold">minus</emphasis> LTable1) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("Table values are equal");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">iLess</phrase>(<phrase
									 role="code">&lt;</phrase>)</para> 
								<para>Returns true if the first table value is a proper
									 subset of the second table value. A given table value 
									 <phrase role="code">A</phrase> is a proper subset
									 of some table value 
									 <phrase role="code">B</phrase> if 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> are both of the same
									 table type, and all the rows in 
									 <phrase role="code">A</phrase> are in 
									 <phrase role="code">B</phrase>, and there is at
									 least one row in 
									 <phrase role="code">B</phrase> that is not in 
									 <phrase role="code">A</phrase>. For example: 
									 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable1 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID } };
	<emphasis role="bold">var</emphasis> LTable2 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };

	<emphasis role="bold">if not</emphasis>(LTable1 &lt; LTable2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("LTable1 is not a proper subset of LTable2");

	// equivalent formulation
	<emphasis role="bold">if not exists</emphasis> (LTable1 <emphasis role="bold">minus</emphasis> LTable2) <emphasis role="bold">and</emphasis> 
		<emphasis role="bold">exists</emphasis> (LTable2 <emphasis role="bold">minus</emphasis> LTable1) <emphasis role="bold">then</emphasis> 
		<emphasis role="bold">raise</emphasis> Error("LTable1 is a proper subset of LTable2");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">iInclusiveLess</phrase>(<phrase role="code">&lt;=</phrase>)</para> 
								<para>Returns true if the first table value is a
									 subset, not necessarily proper, of the second table value. A given table value 
									 <phrase role="code">A</phrase> is a subset of some
									 table value 
									 <phrase role="code">B</phrase> if 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> are both of the same
									 table type, and all the rows in 
									 <phrase role="code">A</phrase> are in 
									 <phrase role="code">B</phrase>. For example: 
									 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable1 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID } };
	<emphasis role="bold">var</emphasis> LTable2 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };

	<emphasis role="bold">if not</emphasis>(LTable1 &lt;= LTable2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("LTable1 is not a subset of LTable2");

	// equivalent formulation
	<emphasis role="bold">if not exists</emphasis> (LTable1 <emphasis role="bold">minus</emphasis> LTable2) <emphasis role="bold">then</emphasis> 
		<emphasis role="bold">raise</emphasis> Error("LTable1 is a subset of LTable2");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">iGreater</phrase>(<phrase
									 role="code">&gt;</phrase>)</para> 
								<para>Returns true if the first table value is a proper
									 superset of the second table value. A given table value 
									 <phrase role="code">A</phrase> is a proper superset
									 of some table value 
									 <phrase role="code">B</phrase> if 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> are both of the same
									 table type, and all the rows in 
									 <phrase role="code">B</phrase> are in 
									 <phrase role="code">A</phrase>, and there is at
									 least one row in 
									 <phrase role="code">A</phrase> that is not in 
									 <phrase role="code">B</phrase>. For example: 
									 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable1 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };
	<emphasis role="bold">var</emphasis> LTable2 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID } };

	<emphasis role="bold">if not</emphasis>(LTable1 &gt; LTable2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("LTable1 is not a proper superset of LTable2");

	// equivalent formulation
	<emphasis role="bold">if not exists</emphasis> (LTable2 <emphasis role="bold">minus</emphasis> LTable1) <emphasis role="bold">and</emphasis> 
		<emphasis role="bold">exists</emphasis> (LTable1 <emphasis role="bold">minus</emphasis> LTable2) <emphasis role="bold">then</emphasis> 
		<emphasis role="bold">raise</emphasis> Error("LTable1 is a proper superset of LTable2");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><phrase
									 role="code">iInclusiveGreater</phrase>(<phrase
									 role="code">&gt;=</phrase>)</para> 
								<para>Returns true if the first table value is a
									 superset, not necessarily proper, of the second table value. A given table
									 value 
									 <phrase role="code">A</phrase> is a superset of
									 some table value 
									 <phrase role="code">B</phrase> if 
									 <phrase role="code">A</phrase> and 
									 <phrase role="code">B</phrase> are both of the same
									 table type, and all the rows in 
									 <phrase role="code">B</phrase> are in 
									 <phrase role="code">A</phrase>. For example: 
									 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable1 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID }, <emphasis role="bold">row</emphasis> { 7 ID } };
	<emphasis role="bold">var</emphasis> LTable2 : <emphasis role="bold">table</emphasis> { ID : Integer } := 
		<emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 5 ID }, <emphasis role="bold">row</emphasis> { 6 ID } };

	<emphasis role="bold">if not</emphasis> (LTable1 &gt;= LTable2) <emphasis role="bold">then</emphasis>
		<emphasis role="bold">raise</emphasis> Error("LTable1 is not a superset of LTable2");

	// equivalent formulation
	<emphasis role="bold">if not exists</emphasis> (LTable2 <emphasis role="bold">minus</emphasis> LTable1) <emphasis role="bold">then</emphasis> 
		<emphasis role="bold">raise</emphasis> Error("LTable1 is a superset of LTable2");
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  </listitem> 
						  <listitem> 
								<para><phrase role="code">iCompare</phrase>(<phrase
									 role="code">?=</phrase>)</para> 
								<para>The 
									 <phrase role="code">iCompare</phrase> operator is
									 defined in terms of the other comparison operators: 
									 <programlisting>A ?= B = <emphasis role="bold">if</emphasis> A = B <emphasis role="bold">then</emphasis> 0 else <emphasis role="bold">if</emphasis> A &lt; B <emphasis role="bold">then</emphasis> -1 <emphasis role="bold">else</emphasis> 1;</programlisting></para> 
						  </listitem> 
					 </itemizedlist></para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGImperativeStatements"> 
		  <title><indexterm><primary>Imperative
						  Statements</primary></indexterm>Imperative Statements</title> 
		  <para>This section covers the imperative statements available in the D4
				language. These include variable declaration and assignment, flow control
				constructs, and exception handling statements.</para> 
		  <para>Imperative statements in D4 have the following syntax: 
				<programlisting>&lt;imperative statement&gt; ::=
	<ulink url="D4LGImperativeStatements-BlocksandScoping.html" type="link">&lt;block&gt;</ulink> |
	<ulink url="D4LGLanguageElements-Expressions.html" type="link">&lt;expression&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-Variables-VariableDeclarationStatement.html" type="link">&lt;variable declaration statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-Variables-AssignmentStatement.html" type="link">&lt;assignment statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-FlowControl-ExitStatement.html" type="link">&lt;exit statement&gt;</ulink> |
	<ulink url="D4LGIfStatement.html" type="link">&lt;if statement&gt;</ulink> |
	<ulink url="D4LGWhileStatement.html" type="link">&lt;while statement&gt;</ulink> |
	<ulink url="D4LGDoWhileStatement.html" type="link">&lt;do while statement&gt;</ulink> |
	<ulink url="D4LGForStatement.html" type="link">&lt;for statement&gt;</ulink> |
	<ulink url="D4LGRepeatUntilStatement.html" type="link">&lt;repeat statement&gt;</ulink> |
	<ulink url="D4LGBreakandContinue.html" type="link">&lt;break statement&gt;</ulink> |
	<ulink url="D4LGBreakandContinue.html" type="link">&lt;continue statement&gt;</ulink> |
	<ulink url="D4LGCaseStatement.html" type="link">&lt;case statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-ExceptionHandling-TryFinallyStatement.html" type="link">&lt;try finally statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement.html" type="link">&lt;try except statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-ExceptionHandling-TryCommitStatement.html" type="link">&lt;try commit statement&gt;</ulink> |
	<ulink url="D4LGImperativeStatements-ExceptionHandling-RaiseStatement.html" type="link">&lt;raise statement&gt;</ulink></programlisting></para> 
		  <para>The following sections cover each statement in detail.</para> 
		  <sect1 id="D4LGImperativeStatements-Variables"> 
				<title><indexterm><primary>Variables</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Variables</secondary></indexterm>Variables</title>
				
				<para>There are two types of variables in D4, global, and local.
					 Only table variables may be global, and are declared through the data
					 definition language statements of D4. Local variables may be of any type, and
					 are only valid for the scope in which they are declared. For more information
					 on scoping, see the Blocks and Scoping section.</para> 
				<sect2
				id="D4LGImperativeStatements-Variables-VariableDeclarationStatement"> 
					 <title><indexterm><primary>Declaration Statement -
									 Variables</primary></indexterm><indexterm><primary>Variables</primary><secondary>Declaration
									 Statement</secondary></indexterm>Variable Declaration Statement</title> 
					 <para>Variable declaration statements in D4 have the following
						  syntax: 
						  <programlisting>&lt;variable declaration statement&gt; ::=
	<emphasis role="bold">var</emphasis> &lt;ne variable definition commalist&gt;
	
&lt;variable definition&gt; ::=
	&lt;qualified identifier&gt; [: &lt;type specifier&gt;] [:= &lt;expression&gt;]</programlisting></para> 
					 <para>Each 
						  <phrase
						  role="code">&lt;variable&nbsp;definition&gt;</phrase> includes an optional
						  initialization expression which is the initial value for the variable. If no
						  initialization expression is specified, the variable is assigned the default
						  value for the type. If no default is specified, the variable is 
						  <ulink url="D4LGNilSemantics.html" type="link">nil</ulink>,
						  or has no value.</para> 
					 <para>The 
						  <phrase role="code"><ulink
								url="D4LGLanguageElements-Types.html"
								type="link">&lt;type&nbsp;specifier&gt;</ulink></phrase> is optional if and
						  only if an initialization expression is specified. In this case, the compiler
						  uses the type of the initialization expression to determine the type of the
						  variable.</para> 
				</sect2> 
				<sect2 id="D4LGImperativeStatements-Variables-AssignmentStatement">
					 
					 <title><indexterm><primary>Assignment
									 Statement</primary></indexterm><indexterm><primary>Variables</primary><secondary>Assignment
									 Statement</secondary></indexterm><indexterm><primary>:=</primary></indexterm>Assignment
						  Statement</title> 
					 <para>Assignment statements in D4 have the following syntax: 
						  <programlisting>&lt;assignment statement&gt; ::=
	&lt;target&gt; := &lt;expression&gt;

&lt;target&gt; ::=
	&lt;expression&gt;</programlisting></para> 
					 <para>The expression specified by 
						  <phrase role="code">&lt;target&gt;</phrase> must be a valid
						  assignment target. This includes properties of representations of scalar
						  values, and updatable expressions like table expressions. The expression
						  specified by 
						  <phrase role="code"><ulink
								url="D4LGLanguageElements-Expressions.html"
								type="link">&lt;expression&gt;</ulink></phrase> must be
						  <emphasis>assignment-compatible</emphasis> with the assignment target. For a
						  definition of assignment-compatibility, refer to the 
						  <ulink
						  url="D4LGCatalogElements-Operators-OperatorResolution.html"
						  type="link">Operator Resolution</ulink> discussion.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGImperativeStatements-BlocksandScoping"> 
				<title><indexterm><primary>Blocks and
								Scoping</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Blocks and
								Scoping</secondary></indexterm><indexterm><primary>Scope</primary></indexterm><indexterm><primary><phrase
								role="code"><emphasis role="bold">begin..end</emphasis></phrase>
								Blocks</primary></indexterm><indexterm><primary><phrase role="code"><emphasis
									 role="bold">end</emphasis></phrase> - 
								<phrase role="code"><emphasis
									 role="bold">begin..end</emphasis></phrase> Blocks</primary></indexterm>Blocks
					 and Scoping</title> 
				<para>Blocks are the primary means of establishing scope in D4. A
					 <emphasis>scope</emphasis> defines the lifetime of variables within D4.
					 Globally scoped variables are persisted with the database state, while locally
					 scoped variables are only available within the scope in which they are
					 defined.</para> 
				<para>Local scopes may be nested to any level. Variables declared
					 within a local scope must be uniquely named, but may hide variables declared in
					 the global scope. Within a nested local scope, variables declared in parent
					 scopes are visible.</para> 
				<para>The following constructs also establish scope within their
					 respective blocks: 
					 <itemizedlist> 
						  <listitem> 
								<para><ulink url="D4LGDoWhileStatement.html"
									 type="xref">Do-while statement</ulink>.</para> 
						  </listitem> 
						  <listitem> 
								<para><ulink url="D4LGRepeatUntilStatement.html"
									 type="xref">Repeat-until statement</ulink>.</para> 
						  </listitem> 
						  <listitem> 
								<para><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement.html"
									 type="xref">Try-except statement</ulink>, in both the try block, and each
									 exception handler.</para> 
						  </listitem> 
						  <listitem> 
								<para><ulink
									 url="D4LGImperativeStatements-ExceptionHandling-TryFinallyStatement.html"
									 type="xref">Try-finally statements</ulink>, in both the try block, and the
									 finally block.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Blocks in D4 have the following syntax: 
					 <programlisting>&lt;block&gt; ::=
	<emphasis role="bold">begin</emphasis>
		&lt;terminated statement list&gt;
	<emphasis role="bold">end</emphasis></programlisting></para> 
				<para>The following example illustrates the use of blocks in D4: 
					 <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer := 1;
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">var</emphasis> J : Integer := 5;
		J := J + I; // I is visible;

		// Global variables are visible
		J := J + Count(System.Objects); 
	<emphasis role="bold">end</emphasis>;
	I := I + 1; // J is out of scope
<emphasis role="bold">end</emphasis>;</programlisting></para> 
		  </sect1> 
		  <sect1 id="D4LGImperativeStatements-FlowControl"> 
				<title><indexterm><primary>Flow
								Control</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Flow Control</secondary></indexterm>Flow
					 Control</title> 
				<para>Flow control statements allow control over the execution in a
					 D4 program. These include branching statements and looping statements.</para> 
				<sect2 id="D4LGImperativeStatements-FlowControl-ExitStatement"> 
					 <title><indexterm><primary>Exit
									 Statement</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Exit Statement</secondary></indexterm>Exit
						  Statement</title> 
					 <para>The exit statement unconditionally exits an operator.
						  Control passes immediately back to the caller. If an exit statement is used
						  within a try-finally, the finally block is executed.</para> 
					 <para>Exit statements in D4 have the following syntax: 
						  <programlisting>&lt;exit statement&gt; ::=
	<emphasis role="bold">exit</emphasis></programlisting></para> 
					 <para>The following example illustrates the use of the exit
						  statement: 
						  <programlisting><emphasis role="bold">create operator</emphasis> TestExit(<emphasis role="bold">var</emphasis> AValue : Integer)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">if</emphasis> AValue &lt; 0 <emphasis role="bold">then</emphasis>
		<emphasis role="bold">exit</emphasis>;

	/* 
	   this statement will not be executed
	   if AValue is less than zero
	*/
	AValue := AValue * 10; 
<emphasis role="bold">end</emphasis>;</programlisting></para> 
				</sect2> 
				<sect2
				id="D4LGImperativeStatements-FlowControl-BranchingStatements"> 
					 <title><indexterm><primary>Branching
									 Statements</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Branching
									 Statements</secondary></indexterm>Branching Statements</title> 
					 <para>Branching statements allow for the conditional execution
						  of different blocks of code based on a specified expression.</para> 
					 <sect3 id="D4LGIfStatement"> 
						  <title><indexterm><primary>If
										  Statement</primary></indexterm><indexterm><primary>Branching
										  Statements</primary><secondary>If Statement</secondary></indexterm>If
								Statement</title> 
						  <para>The if statement allows statements to be executed
								conditionally.</para> 
						  <para>If statements in D4 have the following syntax: 
								<programlisting>&lt;if statement&gt; ::=
	<emphasis role="bold">if</emphasis> &lt;expression&gt; <emphasis role="bold">then</emphasis>
		&lt;statement&gt;
	[<emphasis role="bold">else</emphasis> &lt;statement&gt;]</programlisting></para> 
						  <para>The expression specified by 
								<phrase role="code"><ulink
									 url="D4LGLanguageElements-Expressions.html"
									 type="link">&lt;expression&gt;</ulink></phrase> must be boolean-valued. If the
								expression evaluates to true, the statement given by 
								<phrase role="code"><ulink
									 url="D4LGLanguageElements-Statements.html"
									 type="link">&lt;statement&gt;</ulink></phrase> is executed. The if statement
								may include an optional else clause which specifies a statement to be executed
								if the expression evaluates to false or nil. Note that if an else clause is
								specified, it is part of the if statement, so the statement separator (<phrase
								role="code"><ulink url="D4LGScriptsandExecution.html"
									 type="link">;</ulink></phrase>) is invalid before the 
								<phrase role="code"><emphasis
									 role="bold">else</emphasis></phrase> keyword.</para> 
						  <para>The following example illustrates the use of the if
								statement: 
								<programlisting><emphasis role="bold">if</emphasis> Count(System.Objects) = 0 <emphasis role="bold">then</emphasis>
	<emphasis role="bold">raise</emphasis> Error("No objects defined in the system catalog")
<emphasis role="bold">else</emphasis>
	<emphasis role="bold">raise</emphasis> Error("Count of objects in the system is " + 
		Count(System.Objects).ToString());</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink url="D4LGConditionalExpression.html"
								type="link">if expression</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGCaseStatement"> 
						  <title><indexterm><primary>Case
										  Statement</primary></indexterm><indexterm><primary>Branching
										  Statements</primary><secondary>Case Statement</secondary></indexterm>Case
								Statement</title> 
						  <para>Case statements allow the execution of a specific
								statement based on a list of conditions. Case statements are a syntactic
								shorthand for an iterated if statement.</para> 
						  <para>The case statement has two forms. One is based on an
								expression, one allows a conditional to be associated with each case
								item.</para> 
						  <para>In the first form, the case statement is based on an
								expression. Each case statement item contains a single expression which is
								compared against the case expression. If the case item expression is equal to
								the case expression, the statement associated with the item is selected. Each
								case item is compared with the case expression until a match is found. If no
								match is found, the default case item is selected.</para> 
						  <para>In the second form, the case statement is not based
								on an expression, rather, each case item contains a boolean-valued condition.
								The first case item for which the condition evaluates to true is selected. The
								default case item is selected if no case item expression evaluates to
								true.</para> 
						  <para> If no case item is selected the statement is
								effectively a no-op. Once a statement has been selected, it is executed, and
								control passes to the first statement following the case statement.</para> 
						  <para>Case statements in D4 have the following syntax: 
								<programlisting>&lt;case statement&gt; ::=
	<emphasis role="bold">case</emphasis> [&lt;expression&gt;]
		&lt;ne case statement item list&gt;
		[<emphasis role="bold">else</emphasis> &lt;terminated statement&gt;]
	<emphasis role="bold">end</emphasis>

&lt;case statement item&gt; ::=
	<emphasis role="bold">when</emphasis> &lt;expression&gt; <emphasis role="bold">then</emphasis> &lt;terminated statement&gt;</programlisting></para> 
						  <para>The following examples illustrate the use of the case
								statement in D4: 
								<programlisting><emphasis role="bold">create operator</emphasis> DigitToWords(<emphasis role="bold">const</emphasis> ADigit : Integer) : String
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">case</emphasis> ADigit
		<emphasis role="bold">when</emphasis> 0 <emphasis role="bold">then result</emphasis> := 'Zero';
		<emphasis role="bold">when</emphasis> 1 <emphasis role="bold">then result</emphasis> := 'One';
		<emphasis role="bold">when</emphasis> 2 <emphasis role="bold">then result</emphasis> := 'Two';
		<emphasis role="bold">when</emphasis> 3 <emphasis role="bold">then result</emphasis> := 'Three';
		<emphasis role="bold">when</emphasis> 4 <emphasis role="bold">then result</emphasis> := 'Four';
		<emphasis role="bold">when</emphasis> 5 <emphasis role="bold">then result</emphasis> := 'Five';
		<emphasis role="bold">when</emphasis> 6 <emphasis role="bold">then result</emphasis> := 'Six';
		<emphasis role="bold">when</emphasis> 7 <emphasis role="bold">then result</emphasis> := 'Seven';
		<emphasis role="bold">when</emphasis> 8 <emphasis role="bold">then result</emphasis> := 'Eight';
		<emphasis role="bold">when</emphasis> 9 <emphasis role="bold">then result</emphasis> := 'Nine';
		<emphasis role="bold">else</emphasis>
			<emphasis role="bold">raise</emphasis> Error("Digit out of range: " + ADigit.ToString());
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting> 
								<programlisting><emphasis role="bold">create operator</emphasis> DigitToWords(<emphasis role="bold">const</emphasis> ADigit : Integer) : String
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">case</emphasis>
		<emphasis role="bold">when</emphasis> ADigit = 0 <emphasis role="bold">then result</emphasis> := 'Zero';
		<emphasis role="bold">when</emphasis> ADigit = 1 <emphasis role="bold">then result</emphasis> := 'One';
		<emphasis role="bold">when</emphasis> ADigit = 2 <emphasis role="bold">then result</emphasis> := 'Two';
		<emphasis role="bold">when</emphasis> ADigit = 3 <emphasis role="bold">then result</emphasis> := 'Three';
		<emphasis role="bold">when</emphasis> ADigit = 4 <emphasis role="bold">then result</emphasis> := 'Four';
		<emphasis role="bold">when</emphasis> ADigit = 5 <emphasis role="bold">then result</emphasis> := 'Five';
		<emphasis role="bold">when</emphasis> ADigit = 6 <emphasis role="bold">then result</emphasis> := 'Six';
		<emphasis role="bold">when</emphasis> ADigit = 7 <emphasis role="bold">then result</emphasis> := 'Seven';
		<emphasis role="bold">when</emphasis> ADigit = 8 <emphasis role="bold">then result</emphasis> := 'Eight';
		<emphasis role="bold">when</emphasis> ADigit = 9 <emphasis role="bold">then result</emphasis> := 'Nine';
		<emphasis role="bold">else</emphasis>
			<emphasis role="bold">raise</emphasis> Error("Digit out of range: " + ADigit.ToString());
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink url="D4LGConditionalExpression.html"
								type="link">case expression</ulink></para> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGImperativeStatements-FlowControl-LoopingStatements">
					 
					 <title><indexterm><primary>Looping
									 Statements</primary></indexterm><indexterm><primary>Flow
									 Control</primary><secondary>Looping Statements</secondary></indexterm>Looping
						  Statements</title> 
					 <para>Looping statements allow for a given statement to be
						  executed multiple times. There are four types of looping statements in D4: the
						  for statement, the while statement, the do-while statement, and the
						  repeat-until statement.</para> 
					 <para>Note that all these looping constructs can be expressed
						  in terms of a simple while loop. The variations are provided to allow the
						  developer to build more readable statements, as each loop is appropriate for
						  different scenarios.</para> 
					 <sect3 id="D4LGForStatement"> 
						  <title><indexterm><primary>For
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>For Statement</secondary></indexterm>For
								Statement</title> 
						  <para>The for statement allows a given statement to be
								executed a specified number of times.</para> 
						  <para>For statements in D4 have the following syntax: 
								<programlisting>&lt;for statement&gt; ::=
	<emphasis role="bold">for</emphasis> 
		[<emphasis role="bold">var</emphasis>] &lt;qualified identifier&gt; [: &lt;type specifier&gt;] 
		:= &lt;expression&gt; (<emphasis role="bold">to</emphasis> | <emphasis role="bold">downto</emphasis>) &lt;expression&gt; 
		[<emphasis role="bold">step</emphasis> &lt;expression&gt;] 
		<emphasis role="bold">do</emphasis> &lt;statement&gt;</programlisting></para> 
						  <para>The for statement uses an <emphasis>iteration control
								variable</emphasis>, or ICV, to control statement iteration. The ICV may be an
								existing variable within the scope, or it may be declared by specifying the 
								<phrase role="code"><emphasis
									 role="bold">var</emphasis></phrase> keyword prior to the variable name, or the
								type of the variable within the for statement. If the 
								<phrase role="code"><emphasis
									 role="bold">var</emphasis></phrase> keyword is specified, the type specifier is
								optional. </para> 
						  <para>In all cases, the ICV must be initialized to the
								initial bound for the iteration. The final bound is then specified as well as
								the iteration direction. An optional step clause specifies the magnitude of the
								increment or decrement to the ICV. The for statement is a post-test loop, so
								the statement is run, then the ICV is tested against the final bound. The type
								of the variable used for the ICV must have addition or subtraction operators
								defined as appropriate, as well as the necessary comparison operators.</para> 
						  <para>Note that the boundary condition will be evaluated on
								every iteration. If this condition has side-effects, this may result in
								unexpected behavior.</para> 
						  <para>The following example illustrates the use of the for
								statement: 
								<programlisting><emphasis role="bold">create table</emphasis> Data { ID : Integer, <emphasis role="bold">key</emphasis> { ID } };

<emphasis role="bold">for</emphasis> I : Integer := 10 <emphasis role="bold">to</emphasis> 100 <emphasis role="bold">step</emphasis> 10 <emphasis role="bold">do</emphasis>
	<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { I ID } } <emphasis role="bold">into</emphasis> Data;

<emphasis role="bold">select</emphasis> Data;</programlisting> 
								<programlisting>ID  
--- 
10  
20  
30  
40  
50  
60  
70  
80  
90  
100</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink> | 
								<ulink url="D4LGBreakandContinue.html"
								type="xref">Break and Continue</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGWhileStatement"> 
						  <title><indexterm><primary>While
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>While Statement</secondary></indexterm>While
								Statement</title> 
						  <para>The while statement allows a given statement to be
								executed as long as a specified condition is true. The while statement is a
								pre-test loop, meaning that the condition is checked, and then the statement is
								executed.</para> 
						  <para>While statements in D4 have the following syntax: 
								<programlisting>&lt;while statement&gt; ::=
	<emphasis role="bold">while</emphasis> &lt;expression&gt; <emphasis role="bold">do</emphasis> &lt;statement&gt;</programlisting></para> 
						  <para>The expression specified by 
								<phrase role="code">&lt;expression&gt;</phrase> must be
								boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								while statement: 
								<programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer := 0;
	<emphasis role="bold">while</emphasis> I &lt; 20 <emphasis role="bold">do</emphasis>
		I := I + 1;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink> | 
								<ulink url="D4LGBreakandContinue.html"
								type="xref">Break and Continue</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGDoWhileStatement"> 
						  <title><indexterm><primary>Do While
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Do While Statement</secondary></indexterm>Do
								While Statement</title> 
						  <para>The do-while statement allows a given block to be
								executed as long as a specified condition is true. The do-while statement is a
								post-test loop, meaning that the statement is executed, then the condition is
								tested.</para> 
						  <para>Do while statements in D4 have the following syntax: 
								<programlisting>&lt;do while statement&gt; ::=
	<emphasis role="bold">do</emphasis> &lt;terminated statement list&gt; <emphasis role="bold">while</emphasis> &lt;expression&gt;</programlisting></para> 
						  <para>The expression specified by 
								<phrase role="code"><ulink
									 url="D4LGLanguageElements-Expressions.html"
									 type="link">&lt;expression&gt;</ulink></phrase> must be boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								do-while statement: 
								<programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer := 0;
	<emphasis role="bold">do</emphasis>
		I := I + 1;
	<emphasis role="bold">while</emphasis> I &lt; 20;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink> | 
								<ulink url="D4LGBreakandContinue.html"
								type="xref">Break and Continue</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGRepeatUntilStatement"> 
						  <title><indexterm><primary>Repeat Until
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Repeat Until
										  Statement</secondary></indexterm>Repeat Until Statement</title> 
						  <para>The repeat-until statement allows a given block to be
								executed until a specified condition returns true. The repeat until is a
								post-test loop, meaning that the statement is executed, then the condition is
								tested.</para> 
						  <para>Repeat until statements in D4 have the following
								syntax: 
								<programlisting>&lt;repeat statement&gt; ::=
	<emphasis role="bold">repeat</emphasis> &lt;terminated statement list&gt; <emphasis role="bold">until</emphasis> &lt;condition&gt;
	
&lt;condition&gt; ::=
	&lt;expression&gt;</programlisting></para> 
						  <para>The expression given by 
								<phrase role="code">&lt;condition&gt;</phrase> must be
								boolean-valued.</para> 
						  <para>The following example illustrates the use of the
								repeat-until statement: 
								<programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> I : Integer := 0;
	<emphasis role="bold">repeat</emphasis>
		I := I + 1;
	<emphasis role="bold">until</emphasis> I &gt;= 20;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink> | 
								<ulink url="D4LGBreakandContinue.html"
								type="xref">Break and Continue</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGForeachStatement"> 
						  <title><indexterm><primary>Foreach
										  Statement</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Foreach Statement</secondary></indexterm>Foreach
								Statement</title> 
						  <para>The foreach statement provides a convenient shorthand
								for performing cursor or list iteration operations.</para> 
						  <para>Foreach statements in D4 have the following syntax: 
								<programlisting>&lt;for statement&gt; ::=
	<emphasis role="bold">foreach row</emphasis> | ([<emphasis role="bold">var</emphasis>] &lt;qualified identifier&gt;)
		<emphasis role="bold">in</emphasis> &lt;cursor definition&gt;
		<emphasis role="bold">do</emphasis> &lt;statement&gt;</programlisting></para> 
						  <para>The foreach statement is expanded by the compiler
								based on the result type of the iteration target expression. If the iteration
								target is a cursor-valued expression, the foreach statement is expanded into a
								cursor definition and the statement to be performed is placed inside a while
								loop iterating over each row in the result set of the cursor. Otherwise, the
								foreach statement is expanded into a list-style iteration using a for loop, an
								invocation of the 
								<phrase role="code">Count</phrase> operator, and an
								indexer expression within each iteration.</para> 
						  <para> 
								<programlisting>#if &lt;cursor definition&gt; is cursor valued ::=	
	<emphasis role="bold">begin</emphasis>
		<emphasis role="bold">var</emphasis> LCursor := &lt;expression&gt;;
		<emphasis role="bold">try</emphasis>
			#if <emphasis role="bold">var</emphasis> is specified
			<emphasis role="bold">var</emphasis> &lt;qualified identifier&gt; : <emphasis role="bold">typeof</emphasis>(LCursor.Select());
			#end
			<emphasis role="bold">while</emphasis> LCursor.Next() <emphasis role="bold">do</emphasis>
			<emphasis role="bold">begin</emphasis>
				#if &lt;qualified identifier&gt; is specified
				&lt;qualified identifier&gt; := LCursor.Select();
				#else
				#stackpush LCursor.Select()
				#end
				&lt;statement&gt;;
				#if &lt;qualified identifier&gt; is not specified
				#stackpop
				#end
			<emphasis role="bold">end</emphasis>;
		<emphasis role="bold">finally</emphasis>
			LCursor.Close();
		<emphasis role="bold">end</emphasis>;
	<emphasis role="bold">end</emphasis>;
#else
	<emphasis role="bold">begin</emphasis>
		#if var is specified
		<emphasis role="bold">var</emphasis> &lt;qualified identifier&gt; : <emphasis role="bold">typeof</emphasis>(&lt;expression&gt;[0]);
		#end
		<emphasis role="bold">for var</emphasis> LIndex := 1 <emphasis role="bold">to</emphasis> &lt;expression&gt;.Count() <emphasis role="bold">do</emphasis>
		<emphasis role="bold">begin</emphasis>
			&lt;qualified identifier&gt; := &lt;expression&gt;[LIndex];
			&lt;statement&gt;;
		<emphasis role="bold">end</emphasis>;
	<emphasis role="bold">end</emphasis>;
#end</programlisting></para> 
						  <para>If the <emphasis role="bold">row</emphasis> keyword
								is used, the columns of the row will be available within 
								<phrase role="code">&lt;statement&gt;</phrase> as
								variables.</para> 
						  <para>The following examples illustrate the use of the
								foreach statement: 
								<programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LTable := <emphasis role="bold">table of</emphasis> { X : Integer, Y : Integer } { };
	<emphasis role="bold">for var</emphasis> LIndex := 1 <emphasis role="bold">to</emphasis> 100 <emphasis role="bold">do</emphasis>
		<emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { LIndex X, 101 - LIndex Y } } <emphasis role="bold">into</emphasis> LTable;
	
	<emphasis role="bold">var</emphasis> LSum := 0;
	<emphasis role="bold">foreach row in</emphasis> LTable <emphasis role="bold">do</emphasis>
		LSum := LSum + X;
	
	LSum := 0;
	<emphasis role="bold">foreach var</emphasis> LRow <emphasis role="bold">in</emphasis> LTable <emphasis role="bold">do</emphasis>
		LSum := LSum + LRow.X;
		
	LSum := 0;
	<emphasis role="bold">var</emphasis> LRow : <emphasis role="bold">typeof</emphasis>(LTable[]);
	<emphasis role="bold">foreach</emphasis> LRow <emphasis role="bold">in</emphasis> LTable <emphasis role="bold">do</emphasis>
		LSum := LSum + LRow.X;
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LList := { "A", "B", "C", "D", "E" };
	
	<emphasis role="bold">var</emphasis> LString := "";
	<emphasis role="bold">foreach var</emphasis> LItem <emphasis role="bold">in</emphasis> LList <emphasis role="bold">do</emphasis>
		LString := LString + LItem;
		
	LString := "";
	<emphasis role="bold">var</emphasis> LItem : String;
	<emphasis role="bold">foreach</emphasis> LItem <emphasis role="bold">in</emphasis> LList <emphasis role="bold">do</emphasis>
		LString := LString + LItem;
<emphasis role="bold">end</emphasis>;</programlisting> </para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink> | 
								<ulink url="D4LGBreakandContinue.html"
								type="xref">Break and Continue</ulink></para> 
					 </sect3> 
					 <sect3 id="D4LGBreakandContinue"> 
						  <title><indexterm><primary>Break and
										  Continue</primary></indexterm><indexterm><primary>Looping
										  Statements</primary><secondary>Break and
										  Continue</secondary></indexterm><indexterm><primary>Continue and
										  Break</primary></indexterm>Break and Continue</title> 
						  <para>Break and continue statements allow for fine grained
								control of loop iteration. The break statement breaks out of a given loop,
								passing control to the first statement after the loop. The continue statement
								jumps to the beginning of the next iteration, passing control to the beginning
								of the iterated statement.</para> 
						  <para>Break and continue statements in D4 have the
								following syntax: 
								<programlisting>&lt;break statement&gt; ::=
	<emphasis role="bold">break</emphasis>

&lt;continue statement&gt; ::=
	<emphasis role="bold">continue</emphasis></programlisting></para> 
						  <para>It is an error to use a break or continue statement
								outside of a looping construct.</para> 
						  <para>The following examples illustrate the use of the
								break and continue statements: 
								<programlisting><emphasis role="bold">while true do</emphasis>
	<emphasis role="bold">break</emphasis>;</programlisting> 
								<programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> EvenSum : Integer := 0;
	<emphasis role="bold">for</emphasis> I : Integer := 1 <emphasis role="bold">to</emphasis> 10 <emphasis role="bold">do</emphasis>
		<emphasis role="bold">if</emphasis> I <emphasis role="bold">mod</emphasis> 2 = 0 <emphasis role="bold">then</emphasis>
			EvenSum := EvenSum + I
		<emphasis role="bold">else</emphasis>
			<emphasis role="bold">continue</emphasis>;
	<emphasis role="bold">raise</emphasis> Error("EvenSum: " + EvenSum.ToString());
<emphasis role="bold">end</emphasis>;</programlisting></para> 
						  <bridgehead>See Also</bridgehead> 
						  <para><ulink
								url="D4LGImperativeStatements-FlowControl-LoopingStatements.html"
								type="xref">Looping Statements</ulink></para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGImperativeStatements-ExceptionHandling"> 
				<title><indexterm><primary>Exception
								Handling</primary></indexterm><indexterm><primary>Imperative
								Statements</primary><secondary>Exception
								Handling</secondary></indexterm><indexterm><primary>Resource Protection
								Block</primary></indexterm>Exception Handling</title> 
				<para>Exception handling statements allow for the creation and
					 handling of exceptions. An <emphasis>exception</emphasis> is used in D4 to
					 indicate that an error has occurred. By relegating error handling to
					 specialized statement blocks, the main body of a given operation can be
					 developed optimistically. Only if something goes wrong is the error handling
					 code invoked.</para> 
				<para>There are three types of error handling constructs in D4: the
					 exception trap, the resource protection block, and the commit block. The 
					 <ulink
					 url="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement.html"
					 type="link">exception trap</ulink> allows exceptions of a specific type to be
					 handled, the 
					 <ulink
					 url="D4LGImperativeStatements-ExceptionHandling-TryFinallyStatement.html"
					 type="link">resource protection block</ulink> ensures that a specified
					 statement is always executed, even if an exception occurs, and the 
					 <ulink
					 url="D4LGImperativeStatements-ExceptionHandling-TryCommitStatement.html"
					 type="link">commit block</ulink> is a shorthand for protecting a block of
					 statements within a transaction.</para> 
				<sect2
				id="D4LGImperativeStatements-ExceptionHandling-RaiseStatement"> 
					 <title><indexterm><primary>Raise
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Raise Statement</secondary></indexterm>Raise
						  Statement</title> 
					 <para>The raise statement is used to throw a new exception.
						  Control immediately passes from the raise statement to the first exception
						  handler. If no exception handler is encountered, execution stops and the error
						  message is reported to the client application. Note that if an implicit
						  transaction was started by the CLI, the exception will cause the transaction to
						  be rolled back, including any nested transactions that were started within the
						  implicit transaction.</para> 
					 <para>Raise statements in D4 have the following syntax: 
						  <programlisting>&lt;raise statement&gt; ::=
	<emphasis role="bold">raise</emphasis> [&lt;expression&gt;]</programlisting></para> 
					 <para>The 
						  <ulink url="T-System.Error.html" type="olinka">error
								value</ulink> given by 
						  <phrase role="code"><ulink
								url="D4LGLanguageElements-Expressions.html"
								type="link">&lt;expression&gt;</ulink></phrase> must be error-valued. The
						  expression is optional only if the raise is invoked within an exception
						  handler, in which case the error being handled is re-raised.</para> 
					 <para>The following example illustrates the use of the raise
						  statement: 
						  <programlisting><emphasis role="bold">if</emphasis> Count(TableVars) = 0 <emphasis role="bold">then</emphasis>
	<emphasis role="bold">raise</emphasis> Error("No table variables declared.");</programlisting></para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink
						  url="D4LGImperativeStatements-ExceptionHandling.html" type="xref">Exception
								Handling</ulink></para> 
				</sect2> 
				<sect2
				id="D4LGImperativeStatements-ExceptionHandling-TryExceptStatement"> 
					 <title><indexterm><primary>Try Except
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Except Statement</secondary></indexterm>Try
						  Except Statement</title> 
					 <para>The try except statement acts as an exception filter,
						  allowing the developer to trap for specific errors and take appropriate
						  action.</para> 
					 <para>Try except statements in D4 have the following syntax: 
						  <programlisting>&lt;try except statement&gt; ::=
	<emphasis role="bold">try</emphasis>
		&lt;terminated statement list&gt;
	<emphasis role="bold">except</emphasis>
		&lt;terminated statement list&gt; | &lt;exception handler list&gt;
	<emphasis role="bold">end</emphasis>
	
&lt;exception handler&gt; ::=
	<emphasis role="bold">on</emphasis> [&lt;exception variable&gt; :] &lt;type specifier&gt; <emphasis role="bold">do</emphasis> 
		&lt;terminated statement&gt;

&lt;exception variable&gt; ::=
	&lt;qualified identifier&gt;</programlisting></para> 
					 <para>When an exception is raised within the try block, control
						  immediately passes to the except block of the statement. If the except block is
						  simply a list of statements, they are executed. If the except block is a list
						  of exception handlers, the type of the exception is compared against each
						  exception handler. Control is passed to the first exception handler matching
						  the type of the exception. If no exception handler is found, control passes to
						  the next try-except block in the program. This continues until an exception
						  handler is found, or there are no containing try-except blocks, resulting in
						  program termination.</para> 
					 <para>Once an exception handler has been found, the exception
						  is considered handled, and control passes to the first statement following the
						  try-except block. Within an except block, the raise statement may be used
						  without an argument to indicate that the exception should be re-raised from the
						  exception block.</para> 
					 <para>The following example illustrates the use of the
						  try-except statement: 
						  <programlisting><emphasis role="bold">begin</emphasis>	
		BeginTransaction();
		<emphasis role="bold">try</emphasis>
			<emphasis role="bold">raise</emphasis> Error("An error has occurred");
			CommitTransaction();
		<emphasis role="bold">except</emphasis>
		<emphasis role="bold">on</emphasis> LException : Error <emphasis role="bold">do</emphasis>
		<emphasis role="bold">begin</emphasis>
			RollbackTransaction();
			<emphasis role="bold">raise</emphasis>;
		<emphasis role="bold">end</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink
						  url="D4LGImperativeStatements-ExceptionHandling.html" type="xref">Exception
								Handling</ulink></para> 
				</sect2> 
				<sect2
				id="D4LGImperativeStatements-ExceptionHandling-TryFinallyStatement"> 
					 <title><indexterm><primary>Try Finally
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Finally Statement</secondary></indexterm>Try
						  Finally Statement</title> 
					 <para>The try finally statement in D4 allows a specified block
						  of statements to be executed regardless of whether an exception occurs.</para> 
					 <para>Try finally statements in D4 have the following syntax: 
						  <programlisting>&lt;try finally statement&gt; ::=
	<emphasis role="bold">try</emphasis>
		&lt;terminated statement list&gt;
	<emphasis role="bold">finally</emphasis>
		&lt;terminated statement list&gt;
	<emphasis role="bold">end</emphasis></programlisting></para> 
					 <para>If no exception occurs within the try block, the finally
						  block is executed normally. If an exception occurs within the try block,
						  control passes immediately to the first statement in the finally block. All
						  statements in the finally block are executed, and then exception processing
						  continues as described in the try-except statement.</para> 
					 <para>The following example illustrates the use of the
						  try-finally statement: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	<emphasis role="bold">var</emphasis> LCursor : <emphasis role="bold">cursor</emphasis>(<emphasis role="bold">table</emphasis> { Name : Name });
	LCursor := <emphasis role="bold">cursor</emphasis>(Objects <emphasis role="bold">over</emphasis> { Name });
	<emphasis role="bold">try</emphasis>
		// ... if an error occurs within this block
		// the cursor will still be closed
	<emphasis role="bold">finally</emphasis>
		LCursor.Close();
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink
						  url="D4LGImperativeStatements-ExceptionHandling.html" type="xref">Exception
								Handling</ulink></para> 
				</sect2> 
				<sect2
				id="D4LGImperativeStatements-ExceptionHandling-TryCommitStatement"> 
					 <title><indexterm><primary>Try Commit
									 Statement</primary></indexterm><indexterm><primary>Exception
									 Handling</primary><secondary>Try Commit Statement</secondary></indexterm>Try
						  Commit Statement</title> 
					 <para>The try commit statement in D4 protects a specified block
						  of statements within a transaction.</para> 
					 <para>Try commit statements in D4 have the following syntax: 
						  <programlisting>&lt;try commit statement&gt; ::=
	<emphasis role="bold">try</emphasis>
		&lt;terminated statement lisst&gt;
	<emphasis role="bold">commit</emphasis></programlisting></para> 
					 <para> The try commit statement is shorthand for an equivalent
						  try except statement with transaction management calls. For example, the
						  following statement: 
						  <programlisting><emphasis role="bold">try</emphasis>
	<emphasis role="bold">insert</emphasis> <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 6 ID, 'Jacob' Name } } <emphasis role="bold">into</emphasis> Employee;
<emphasis role="bold">commit</emphasis>;</programlisting></para> 
					 <para>Is equivalent to the following try except statement: 
						  <programlisting><emphasis role="bold">begin</emphasis>
	BeginTransaction();
	<emphasis role="bold">try</emphasis>
		<emphasis role="bold">insert</emphasis> <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { 6 ID, 'Jacob' Name } } <emphasis role="bold">into</emphasis> Employee;
		CommitTransaction();
	<emphasis role="bold">except</emphasis>
		RollbackTransaction();
		<emphasis role="bold">raise</emphasis>;
	<emphasis role="bold">end</emphasis>;
<emphasis role="bold">end</emphasis>;</programlisting></para> 
					 <bridgehead>See Also</bridgehead> 
					 <para><ulink
						  url="D4LGImperativeStatements-ExceptionHandling.html" type="xref">Exception
								Handling</ulink></para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="D4LGComparisonWithSQL"> 
		  <title><indexterm><primary>Comparison With
						  SQL</primary></indexterm>Comparison With SQL</title> 
		  <para>This section provides a comparison between the D4 and SQL
				languages. For users familiar with SQL, this section provides a quick-start to
				D4, as it explains how the constructs of SQL are expressed in D4. In addition,
				this section highlights many of the important features of the D4 language which
				are not available in SQL. This section has the following basic outline: 
				<itemizedlist> 
					 <listitem> 
						  <para>Introduction</para> 
						  <para>This section provides a brief overview of the two
								languages and provides a high-level comparison.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Common SQL</para> 
						  <para>This section introduces a hypothetical SQL dialect
								called Common SQL. This language will provide a concrete syntax that can be
								used to demonstrate and explain the differences between SQL and D4.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Vendor Dialects</para> 
						  <para>This section introduces several of the more popular
								dialects of SQL, and highlights the idiosynchrasies of each.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Mapping an SQL Query Into D4</para> 
						  <para>This section describes how each component of an SQL
								query can be mapped into D4 operators.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Data Management Differences</para> 
						  <para>This section describes some of the fundamental
								differences between the way the two languages deal with data.</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>Note: This section is <emphasis>not</emphasis> intended for users
				who are not familiar with SQL. If the reader does not already know SQL fairly
				well, he or she would do better not to read this section.</para> 
		  <sect1 id="D4LGComparisonWithSQL-Introduction"> 
				<title>Introduction</title> 
				<para>SQL was first developed as a prototype interface for use with
					 the System R project from IBM. As such, it was never intended to be a
					 production language for use in real applications. It was designed to be
					 <emphasis>some</emphasis> interface for a relational prototype that would serve
					 to convince the world that relational database management was a viable
					 technology [6].</para> 
				<para>D4, on the other hand, was built from the very beginning as a
					 solution to everyday data management problems faced by application developers.
					 It is especially significant that the designers of D4 have extensive
					 backgrounds in database application development using SQL-based DBMSs. The
					 entire Dataphor product evolved from a set of in-house software development
					 tools used to develop commercial applications. The logical model for the D4
					 language is based on The Third Manifesto, by C. J. Date and Hugh Darwen. The
					 syntax of D4 is based largely on Pascal and Tutorial D, a hypothetical syntax
					 used in The Third Manifesto as a vehicle for describing the concepts. D4 is an
					 'Industrial D' as described in The Third Manifesto.</para> 
				<para>In addition, SQL was designed as a 'database sublanguage.' It
					 was intended to be used from 3GL programming environments as a means of
					 retrieving and manipulating data in the database. As such, it had no facilities
					 for imperative programming. This implies that application development is done
					 in one language, while data manipulation is done in another. This disparity of
					 language environments is called <emphasis>impedance mismatch</emphasis>.</para>
				
				<para>D4 is really just an imperative programming language where
					 one of the types of data that can be described is a table. As a result,
					 applications can be developed entirely in D4, with no resulting impedance
					 mismatch.</para> 
				<para>The following table briefly lists some of the ways in which
					 D4 differs from SQL (the standard as well as the major implementations of that
					 standard):</para> 
				<para> 
					 <informaltable> 
						  <tgroup cols="2">
								<colspec colwidth="*" colname="col1" colnum="1"/>
								<colspec colwidth="*" colname="col2" colnum="2"/> 
								<thead> 
									 <row> 
										  <entry colname="col1"> 
												<para>D4</para> </entry> 
										  <entry colname="col2"> 
												<para>SQL</para> </entry> 
									 </row> 
								</thead> 
								<tbody> 
									 <row> 
										  <entry colname="col1"> 
												<para>Uses the relational algebra</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Mixed calculus and algebra</para>
												</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Tables are sets of rows</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Tables are allowed to contain
													 duplicates.</para> </entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Highly orthogonal (easy to learn and
													 use)</para> </entry> 
										  <entry colname="col2"> 
												<para>Complex rules and exceptions</para>
												</entry> 
									 </row> 
									 <row> 
										  <entry colname="col1"> 
												<para>Intrinsic imperative language</para>
												</entry> 
										  <entry colname="col2"> 
												<para>Proprietary extensions to support
													 imperative programming</para> </entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
				<para>In addition to the syntactic differences between the two
					 languages, there are numerous features of D4 that are not supported by, or are
					 poorly implemented in SQL such as user-defined types, user-defined functions,
					 user-defined aggregate functions, exception-handling, user-defined relational
					 operators, updatable views, support for quota queries, etc.,. There are
					 numerous criticisms of SQL in the literature, and we will not endeavour to
					 repeat them here, except as it pertains to the functionality being described.
					 The interested reader is referred to the References section of this
					 manual.</para> 
		  </sect1> 
		  <sect1 id="D4LGComparisonWithSQL-CommonSQL"> 
				<title><indexterm><primary>Common
								SQL</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Common SQL</secondary></indexterm>Common SQL</title> 
				<para>In order to illustrate the differences between SQL and D4, we
					 must agree on a common dialect of SQL to perform the comparison. Because the
					 standard version of SQL has never been completely implemented, we use the
					 <emphasis>lowest common denominator</emphasis>, or that portion of the language
					 that all the various dialects support in some form or another. We call this
					 hypothetical language <emphasis>Common SQL</emphasis>. Note that Common SQL
					 does not exist, even in principle, as even when two dialects support a common
					 feature set, they may have different syntax for the same feature. As such, we
					 make no claim that this dialect is standard in any way, or that it could be
					 used to communicate with any actual DBMS. It is merely a pedagogical tool for
					 use in demonstrating the differences between the de-facto standard SQL and
					 D4.</para> 
				<para>Firstly, we make explicit the fact that we will only be
					 discussing the data manipulation language statements of SQL. In practice, the
					 Dataphor Server must also communicate using data definition language (and the
					 syntactic variations here are even more profound than for DML), but here we
					 will only concern ourselves with the data manipulation aspects of each
					 language.</para> 
				<para>Secondly, we assume that we will only be discussing single
					 statements. The rules for grouping statements into execution blocks also differ
					 for each dialect and DBMS, and so we will only be concerned with the effects of
					 a single data manipulation language statement.</para> 
				<para>In order to describe the Common SQL language, we will use a
					 modified version of Extended Backus-Naur Form (EBNF) notation. For a complete
					 description of this notation, refer to 
					 <ulink url="D4LGIntroduction-SyntacticConventions.html"
					 type="xref">Syntactic Conventions</ulink>.</para> 
				<para>Here then is the syntax for the data manipulation language
					 statement in Common SQL: 
					 <programlisting>&lt;dml statement&gt; ::=
	&lt;select statement&gt; |
	&lt;insert statement&gt; |
	&lt;update statement&gt; |
	&lt;delete statement&gt;</programlisting></para> 
				<sect2 id="D4LGComparisonWithSQL-CommonSQL-SelectStatement"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Select Statement</secondary></indexterm>Select
						  Statement</title> 
					 <para>The bulk of our discussion will center around the select
						  statement, as the mapping for the modification statements is relatively
						  straightforward.</para> 
					 <para>The select statement in 
						  <ulink url="D4LGComparisonWithSQL-CommonSQL.html"
						  type="xref">Common SQL</ulink> has the following syntax: 
						  <programlisting>&lt;select statement&gt; ::=
	&lt;query expression&gt;
	[&lt;order by clause&gt;]

&lt;query expression&gt; ::=
	&lt;select expression&gt; {&lt;table operator clause&gt;}

&lt;select expression&gt; ::=
	<emphasis role="bold">select</emphasis> (* | &lt;column expression commalist&gt;)
		&lt;from clause&gt;
		[&lt;where clause&gt;]
		[&lt;group by clause&gt;]
		[&lt;having clause&gt;]

&lt;column expression&gt; ::=
	&lt;expression&gt; [<emphasis role="bold">as</emphasis> &lt;column alias&gt;]

&lt;from clause&gt; ::=
	<emphasis role="bold">from</emphasis> &lt;table specifier&gt; [&lt;join clause list&gt;]

&lt;where clause&gt; ::=
	<emphasis role="bold">where</emphasis> &lt;conditional expression&gt;

&lt;group by clause&gt; ::=
	<emphasis role="bold">group by</emphasis> &lt;expression commalist&gt;

&lt;having clause&gt; ::=
	<emphasis role="bold">having</emphasis> &lt;conditional expression&gt;

&lt;table specifier&gt; ::=
	&lt;table identifier&gt; | "("&lt;query expression&gt;")" [<emphasis role="bold">as</emphasis> &lt;table alias&gt;]

&lt;join clause&gt; ::=
	[<emphasis role="bold">cross</emphasis> | <emphasis role="bold">inner</emphasis> | ((<emphasis role="bold">left</emphasis> | <emphasis role="bold">right</emphasis>) [<emphasis role="bold">outer</emphasis>])] <emphasis role="bold">join</emphasis> 
     &lt;table specifier&gt; [<emphasis role="bold">on</emphasis> &lt;conditional expression&gt;]

&lt;table operator clause&gt; ::=
	((<emphasis role="bold">union</emphasis> | <emphasis role="bold">intersect</emphasis> | <emphasis role="bold">except</emphasis>) [<emphasis role="bold">all</emphasis>]) &lt;select expression&gt;

&lt;order by clause&gt; ::=
	<emphasis role="bold">order by</emphasis> &lt;order column expression commalist&gt;

&lt;order column expression&gt; ::=
	&lt;column identifier&gt; [<emphasis role="bold">asc</emphasis> | <emphasis role="bold">desc</emphasis>]</programlisting></para> 
					 <para>The syntax is relatively straightforward, and most
						  dialects can be described with only slight modifications. This statement covers
						  all the major operations available in commercial SQL-based DBMSs today. Note
						  that we chose the ANSI standard version of the join clause, rather than the 
						  <phrase
						  role="code">&lt;table&nbsp;specifier&nbsp;commalist&gt;</phrase> flavor common
						  in many implementations.</para> 
					 <sect3 id="D4LGQueryExpression"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Query
										  Expression</tertiary></indexterm>Query Expression</title> 
						  <para>The 
								<phrase
								role="code">&lt;query&nbsp;expression&gt;</phrase> production specifies a 
								<phrase
								role="code">&lt;select&nbsp;expression&gt;</phrase> followed by any number of 
								<phrase
								role="code">&lt;table&nbsp;operator&nbsp;clause&gt;</phrase> productions. We
								refer to these as <emphasis>union-compatible</emphasis> operators, because both
								operands for each operator are required to have the same number of columns, and
								assignment-compatible data types for each column, left-to-right.</para> 
					 </sect3> 
					 <sect3 id="D4LGSelectExpression"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Select
										  Expression</tertiary></indexterm>Select Expression</title> 
						  <para>The 
								<phrase
								role="code">&lt;select&nbsp;expression&gt;</phrase> production is the bulk of
								the SQL syntax. This is the familiar 
								<phrase role="code"><emphasis
									 role="bold">select...from...where</emphasis></phrase> construct. The 
								<phrase
								role="code">&lt;column&nbsp;expression&nbsp;commalist&gt;</phrase> specifies
								the columns to be preserved in the result set. The wildcard 
								<phrase role="code">*</phrase> indicates that all
								columns of the result should be preserved. The 
								<phrase
								role="code">&lt;column&nbsp;expression&gt;</phrase> production includes an
								optional as clause which indicates what the column should be named in the final
								result.</para> 
					 </sect3> 
					 <sect3 id="D4LGFromClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>From
										  Clause</tertiary></indexterm>From Clause</title> 
						  <para>The 
								<phrase role="code">&lt;from&nbsp;clause&gt;</phrase>
								is required and specifies the initial table from which the result should be
								gathered. Note that the 
								<phrase
								role="code">&lt;table&nbsp;specifier&gt;</phrase> is allowed to be a 
								<phrase
								role="code">&lt;query&nbsp;expression&gt;</phrase> in itself. This is known as
								a <emphasis>nested from</emphasis> and is only supported by some systems. We
								choose to support it in 
								<ulink url="D4LGComparisonWithSQL-CommonSQL.html"
								type="xref">Common SQL</ulink> because it is an <emphasis>extremely</emphasis>
								useful extension to SQL. Indeed, without it, SQL is not relationally
								complete.</para> 
					 </sect3> 
					 <sect3 id="D4LGJoinClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Join
										  Clause</tertiary></indexterm>Join Clause</title> 
						  <para>The 
								<phrase role="code">&lt;join&nbsp;clause&gt;</phrase>
								is optional and specifies an additional table to bring in to the query. The
								various qualifiers in the join clause specify the type of join to be done, and
								an optional 
								<phrase
								role="code">&lt;conditional&nbsp;expression&gt;</phrase> is used to indicate
								how inner and outer joins are to be performed. Note here again that the 
								<phrase
								role="code">&lt;table&nbsp;specifier&gt;</phrase> is allowed to be a 
								<phrase
								role="code">&lt;query&nbsp;expression&gt;</phrase>, and that only a handful of
								systems support this type of nesting. Even among those that do, there is
								inconsistency about the types of expressions that are allowed to be
								nested.</para> 
					 </sect3> 
					 <sect3 id="D4LGWhereClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Where
										  Clause</tertiary></indexterm>Where Clause</title> 
						  <para>The 
								<phrase role="code">&lt;where&nbsp;clause&gt;</phrase>
								is optional and specifies a filter that is applied to the rows in the result.
								Only rows for which the expression specified by 
								<phrase
								role="code">&lt;conditional&nbsp;expression&gt;</phrase> evaluates to true
								appear in the result. Values of columns for the row being processed are
								accessible within the expression by name. Note that references to column
								aliases are not allowed, only columns of actual tables in the query can be
								referenced. This limitation can be worked around using a nested from, which is
								one of the reasons it is so useful.</para> 
					 </sect3> 
					 <sect3 id="D4LGGroupByClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Group By
										  Clause</tertiary></indexterm>Group By Clause</title> 
						  <para>The 
								<phrase
								role="code">&lt;group&nbsp;by&nbsp;clause&gt;</phrase> is optional, so long as
								the 
								<phrase
								role="code">&lt;column&nbsp;expression&nbsp;commalist&gt;</phrase> contains no
								aggregate operator invocations, or contains only aggregate operator
								invocations. If there is a mixture of aggregate and non-aggregate expressions,
								the group by clause must specify all the non-aggregate expressions.</para> 
					 </sect3> 
					 <sect3 id="D4LGHavingClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Having
										  Clause</tertiary></indexterm>Having Clause</title> 
						  <para>The 
								<phrase role="code">&lt;having&nbsp;clause&gt;</phrase>
								is optional, and specifies a filter that is applied to the rows in the result
								after any aggregation in the query. As with the 
								<phrase role="code">&lt;where&nbsp;clause&gt;</phrase>,
								references to column aliases are not allowed, but references to the aggregate
								operator invocations are.</para> 
					 </sect3> 
					 <sect3 id="D4LGOrderByClause"> 
						  <title><indexterm><primary>Comparison With
										  SQL</primary><secondary>Select Statement</secondary><tertiary>Order By
										  Clause</tertiary></indexterm>Order By Clause</title> 
						  <para>The 
								<phrase
								role="code">&lt;order&nbsp;by&nbsp;clause&gt;</phrase> is optional, and
								specifies an overall ordering for the result.</para> 
					 </sect3> 
				</sect2> 
				<sect2 id="D4LGComparisonWithSQL-CommonSQL-InsertStatement"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Insert Statement</secondary></indexterm>Insert
						  Statement</title> 
					 <para>The insert statement in SQL allows a row or rows to be
						  inserted into a given table variable. The insert statement in 
						  <ulink url="D4LGComparisonWithSQL-CommonSQL.html"
						  type="xref">Common SQL</ulink> has the following syntax: 
						  <programlisting>&lt;insert statement&gt; ::=
	<emphasis role="bold">insert into</emphasis> &lt;table name&gt;"("&lt;column name commalist&gt;")"
		(&lt;values clause&gt; | &lt;query expression&gt;)

&lt;values clause&gt; ::=
	<emphasis role="bold">values</emphasis> "("&lt;expression commalist&gt;")"</programlisting></para> 
				</sect2> 
				<sect2 id="D4LGComparisonWithSQL-CommonSQL-UpdateStatement"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Update Statement</secondary></indexterm>Update
						  Statement</title> 
					 <para>The update statement in SQL allows the data in a given
						  table variable to be updated. The update statement in 
						  <ulink url="D4LGComparisonWithSQL-CommonSQL.html"
						  type="xref">Common SQL</ulink> has the following syntax: 
						  <programlisting>&lt;update statement&gt; ::=
	<emphasis role="bold">update</emphasis> &lt;table name&gt; 
		<emphasis role="bold">set</emphasis> &lt;update column expression colmmalist&gt;
		[&lt;where clause&gt;]</programlisting></para> 
				</sect2> 
				<sect2 id="D4LGComparisonWithSQL-CommonSQL-DeleteStatement"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Delete Statement</secondary></indexterm>Delete
						  Statement</title> 
					 <para>The delete statement in SQL allows the data in a given
						  table variable to be deleted. The delete statement in 
						  <ulink url="D4LGComparisonWithSQL-CommonSQL.html"
						  type="xref">Common SQL</ulink> has the following syntax: 
						  <programlisting>&lt;delete statement&gt; ::=
	<emphasis role="bold">delete</emphasis> &lt;table name&gt;
		[&lt;where clause&gt;]</programlisting></para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGComparisonWithSQL-VendorDialects"> 
				<title><indexterm><primary>Comparison With
								SQL</primary><secondary>Vendor Dialects</secondary></indexterm>Vendor
					 Dialects</title> 
				<para>There are probably more dialects of SQL than there are
					 programming languages. Each DBMS has its own definition of what the language
					 is, what features it supports, how it manages data, and what the syntax of
					 specific statements is. This section discusses a few of the more pervasive
					 implementations, and how they differ from 
					 <ulink url="D4LGComparisonWithSQL-CommonSQL.html"
					 type="xref">Common SQL</ulink>, and from each other.</para> 
				<para>Note that the differences outlined here are mainly syntactic
					 in nature. When the semantics of the different languages are considered as
					 well, the problems of finding a common language become almost unmanageable. For
					 this comparison we largely ignore these issues, but be aware that the Dataphor
					 Server is dealing with them underneath.</para> 
				<sect2 id="D4LGComparisonWithSQL-VendorDialects-Transact-SQL"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Vendor
									 Dialects</secondary><tertiary>Transact-SQL</tertiary></indexterm>Transact-SQL</title>
					 
					 <para>Microsoft SQL Server uses a dialect of SQL called
						  Transact-SQL or T-SQL. This dialect is very similar to Common SQL except that
						  it supports both flavors of join specification in the from clause, and it has
						  no support for the intersect and except operators. Intersect is not necessary
						  because it is a special case of join, but except is a critical operator, and
						  the lack of support for it is a serious drawback of this dialect.</para> 
					 <para>A peculiarity of this dialect is the way in which outer
						  joins are specified when the 
						  <phrase
						  role="code">&lt;table&nbsp;specifier&nbsp;commalist&gt;</phrase> style of from
						  clause is used. The outer join is specified by using a special comparison
						  operator when defining the join in the where clause. The symbol 
						  <phrase role="code">*=</phrase> is used for left joins,
						  while 
						  <phrase role="code">=*</phrase> is used for right joins.
						  There are also some associated restrictions with using these operators, but we
						  chose to avoid the syntax entirely and so do not discuss them here.</para> 
					 <para>Another difference is the treatment of the wildcard
						  (<phrase role="code">*</phrase>) in the 
						  <phrase
						  role="code">&lt;column&nbsp;expression&nbsp;commalist&gt;</phrase>. T-SQL
						  allows table qualifiers on the wildcard to indicate that all the columns of a
						  particular table are to be included in the result. While this is a useful
						  extension, we did not chose to support in Common SQL, as it is not
						  necessary.</para> 
					 <para>The 
						  <phrase role="code">&lt;from&nbsp;clause&gt;</phrase> in
						  T-SQL is optional, in which case the statement is based on the table with one
						  row, and only the columns specified in the 
						  <phrase
						  role="code">&lt;column&nbsp;expression&nbsp;commalist&gt;</phrase>. While this
						  is also a useful extension, it is not as general as allowing table and row
						  selectors. As such we chose not to support it in Common SQL.</para> 
					 <para>Nested froms are allowed in T-SQL, but there is a problem
						  with certain constructs in which the nested expression can only reference
						  columns in the outer query to two levels of nesting. Incidentally, Sybase SQL
						  also suffers from this problem, which is not surprising, given the history of
						  the two systems.</para> 
				</sect2> 
				<sect2 id="D4LGComparisonWithSQL-VendorDialects-OracleSQL"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Vendor Dialects</secondary><tertiary>Oracle
									 SQL</tertiary></indexterm>Oracle SQL</title> 
					 <para>Oracle database systems use a dialect of SQL called
						  Oracle SQL, appropriately enough. This dialect differs mostly in its support
						  for the 
						  <phrase role="code">&lt;from&nbsp;clause&gt;</phrase>.
						  Prior to version 9i, The dialect only supports the 
						  <phrase
						  role="code">&lt;table&nbsp;specifier&nbsp;commalist&gt;</phrase> flavor, and
						  has some severe limitations on the usage of nested from. As of 9i, the ANSI
						  standard join specification is supported.</para> 
					 <para>This dialect also has a peculiar way of specifying outer
						  joins it the 
						  <phrase
						  role="code">&lt;table&nbsp;specifier&nbsp;commalist&gt;</phrase> is used. This
						  is done by using the 
						  <phrase role="code">(+)</phrase> symbol next to the name of
						  the column within the table which is to be the outer table. While we did not
						  find the same restrictions on usage as T-SQL has, we find the syntax clumsy and
						  counter-intuitive.</para> 
					 <para>Nested froms are allowed in Oracle SQL, but the nested
						  expression may not reference columns in the main query. This is in violation of
						  Core SQL as specified by the ANSI-SQL 1999 standard, and is a major drawback of
						  this dialect.</para> 
				</sect2> 
				<sect2 id="D4LGComparisonWithSQL-VendorDialects-DB2SQL"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Vendor Dialects</secondary><tertiary>DB2
									 SQL</tertiary></indexterm>DB2 SQL</title> 
					 <para>DB2 database systems use a dialect of SQL which we will
						  call DB2 SQL. This dialect is very similar to Common SQL, and does not require
						  much modification to represent. It is worth noting that the dialect does suffer
						  from a nested from anomaly as well.</para> 
					 <para>Nested froms are allowed in DB2 SQL, but the nested
						  expression may not reference columns in the main query unless the keyword 
						  <phrase role="code"><emphasis
								role="bold">TABLE</emphasis></phrase> is specified as part of the nested from
						  definition. This seems to be a general solution to the problem, and so it is
						  little more than a peculiarity.</para> 
				</sect2> 
		  </sect1> 
		  <sect1 id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4"> 
				<title><indexterm><primary>Mapping an SQL Query Into
								D4</primary></indexterm><indexterm><primary>Comparison With
								SQL</primary><secondary>Mapping an SQL Query Into
								D4</secondary></indexterm>Mapping an SQL Query Into D4</title> 
				<para>In order to show how an arbitrary SQL statement can be
					 expressed in D4, it is useful to have a sample database definition to work
					 with. The sample is given in D4, but the syntax is similar to SQL and the
					 semantics should be clear: 
					 <programlisting><emphasis role="bold">create table</emphasis> Employee
{ 
	ID : Integer,
	Name : String,
	<emphasis role="bold">key</emphasis> { ID }
}; 

<emphasis role="bold">insert</emphasis> 
	<emphasis role="bold">table</emphasis>	
	{
		<emphasis role="bold">row</emphasis> { 1 ID, "Joe" Name },
		<emphasis role="bold">row</emphasis> { 2, "John" },
		<emphasis role="bold">row</emphasis> { 3, "Josh" },
		<emphasis role="bold">row</emphasis> { 4, "Jeff" },
		<emphasis role="bold">row</emphasis> { 5, "Jake" },
		<emphasis role="bold">row</emphasis> { 6, "Jeff" }
	} 
	<emphasis role="bold">into</emphasis> Employee;

<emphasis role="bold">create table</emphasis> Manager
{
	Employee_ID : Integer,
	Manager_ID : Integer,
	<emphasis role="bold">key</emphasis> { Employee_ID },
	<emphasis role="bold">reference</emphasis> Manager_Employee { Employee_ID } <emphasis role="bold">references</emphasis> Employee { ID },
	<emphasis role="bold">reference</emphasis> Manager_Manager { Manager_ID } <emphasis role="bold">references</emphasis> Employee { ID }
};

<emphasis role="bold">insert</emphasis> 
	<emphasis role="bold">table</emphasis>
	{
		<emphasis role="bold">row</emphasis> { 2 Employee_ID, 1 Manager_ID },
		<emphasis role="bold">row</emphasis> { 3 Employee_ID, 1 Manager_ID },
		<emphasis role="bold">row</emphasis> { 4 Employee_ID, 2 Manager_ID },
		<emphasis role="bold">row</emphasis> { 6 Employee_ID, 2 Manager_ID },
		<emphasis role="bold">row</emphasis> { 5 Employee_ID, 4 Manager_ID }
	}
	<emphasis role="bold">into</emphasis> Manager;

<emphasis role="bold">create table</emphasis> Department
{
	ID : Integer,
	Description : String,
	<emphasis role="bold">key</emphasis> { ID }
};

<emphasis role="bold">insert</emphasis>
	<emphasis role="bold">table</emphasis>
	{
		<emphasis role="bold">row</emphasis> { 1 ID, 'Development' Description },
		<emphasis role="bold">row</emphasis> { 2 ID, 'Support' Description },
		<emphasis role="bold">row</emphasis> { 3 ID, 'Testing' Description }
	}
	<emphasis role="bold">into</emphasis> Department;

<emphasis role="bold">create table</emphasis> EmployeeDepartment
{
	Employee_ID : Integer,
	Department_ID : Integer,
	<emphasis role="bold">key</emphasis> { Employee_ID },
	<emphasis role="bold">reference</emphasis> EmployeeDepartment_Employee { Employee_ID } <emphasis role="bold">references</emphasis> Employee { ID },
	<emphasis role="bold">reference</emphasis> EmployeeDepartment_Department { Department_ID } <emphasis role="bold">references</emphasis> Department { ID }
};

<emphasis role="bold">insert</emphasis>
	<emphasis role="bold">table</emphasis>	
	{
		<emphasis role="bold">row</emphasis> { 1 Employee_ID, 1 Department_ID },
		<emphasis role="bold">row</emphasis> { 2 Employee_ID, 1 Department_ID },
		<emphasis role="bold">row</emphasis> { 3 Employee_ID, 2 Department_ID },
		<emphasis role="bold">row</emphasis> { 4 Employee_ID, 2 Department_ID },
		<emphasis role="bold">row</emphasis> { 5 Employee_ID, 3 Department_ID }
	}
	<emphasis role="bold">into</emphasis> EmployeeDepartment;

<emphasis role="bold">create table</emphasis> EmployeePhone 
{
	Employee_ID : Integer,
	Phone : String,
	<emphasis role="bold">key</emphasis> { ID, Phone },
	<emphasis role="bold">reference</emphasis> EmployeePhone_Employee { Employee_ID } <emphasis role="bold">references</emphasis> Employee { ID }
};

EmployeePhone :=
	<emphasis role="bold">table</emphasis>
	{
		<emphasis role="bold">row</emphasis> { 1 Employee_ID, "555-1234" Phone },
		<emphasis role="bold">row</emphasis> { 1 Employee_ID, "555-1000" Phone }, 
		<emphasis role="bold">row</emphasis> { 2 Employee_ID, "555-4321" Phone },
		<emphasis role="bold">row</emphasis> { 4 Employee_ID, "555-4444" Phone },
		<emphasis role="bold">row</emphasis> { 5 Employee_ID, "555-5678" Phone }
	};</programlisting></para> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-DataRetrieval"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>Data
									 Retrieval</tertiary></indexterm>Data Retrieval</title> 
					 <para>We begin by mapping basic data retrieval. Suppose we are
						  asked 'Get IDs and Names of all employees.' This simple query can be answered
						  using the SQL statement: 
						  <programlisting><emphasis role="bold">select</emphasis> * <emphasis role="bold">from</emphasis> Employee</programlisting></para> 
					 <para>This is the simplest select statement possible in Common
						  SQL and indicates that all the columns and all the rows of the Employee table
						  should be included in the result. Notice that we have not done any manipulation
						  to the result, in other words, no operators have been invoked. We have simply
						  referenced the name of a table variable within an expression.</para> 
					 <para>If this is true, why the '<phrase role="code">*
								<emphasis role="bold">from</emphasis></phrase>' portion of the query? Clearly
						  it is an artifact of the rigid structure required of SQL statements. By
						  contrast, the equivalent D4 statement: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee;</programlisting></para> 
					 <para>This is the simplest select statement possible in D4 and
						  is precisely what we wanted, all the columns and all the rows of the Employee
						  table, without any extra artifacts. The point is, because we invoked no
						  operators, no extra information needs to be specified, the reference to the
						  table variable is enough. While this may not seem like much right now, keep in
						  mind this is the simplest select statement possible. As the statements become
						  more complex, these differences will become more and more apparent.</para> 
					 <para>Also note that unlike SQL, the keyword 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGDataManipulation-SelectStatement.html"
								type="link">select</ulink></emphasis></phrase> in D4 is only part of the
						  statement, it is not part of the expression.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-TheWhereClause"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>The
									 Where Clause</tertiary></indexterm>The Where Clause</title> 
					 <para>Next, we consider a simple restriction. Suppose we are
						  asked 'Get the IDs and Names of Employees whose ID is greater than 3.' In SQL,
						  we have: 
						  <programlisting><emphasis role="bold">select</emphasis> * <emphasis role="bold">from</emphasis> Employee <emphasis role="bold">where</emphasis> ID &gt; 3;</programlisting></para> 
					 <para>The 
						  <phrase role="code">&lt;where clause&gt;</phrase> applies a
						  filter to the result. Only rows for which the specified conditional expression
						  evaluates to true are included in the result. In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">where</emphasis> ID &gt; 3;</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Where.html"
								type="link">where</ulink></emphasis></phrase> operator in D4 performs the same
						  type of filtering on the result.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-UnravelingtheColumnList"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into
									 D4</secondary><tertiary>Unraveling the Column
									 List</tertiary></indexterm>Unraveling the Column List</title> 
					 <para>The column list in an SQL query is actually performing
						  four distinct operations in the query: projection, extension, renaming, and
						  part of aggregation. In this section, we consider the first of these,
						  projection. Suppose we are asked 'Get the Names of Employees.' In SQL we would
						  write: 
						  <programlisting><emphasis role="bold">select</emphasis> <emphasis role="bold">distinct</emphasis> Name <emphasis role="bold">from</emphasis> Employee</programlisting></para> 
					 <para>The projection step indicates that only the Name column
						  from the Employee table should appear in the result.</para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">over</emphasis> { Name };</programlisting></para> 
					 <para>Projection in D4 is always done using one of two
						  operators, 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-OverandRemove.html"
								type="link">over</ulink></emphasis></phrase> and 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-OverandRemove.html"
								type="link">remove</ulink></emphasis></phrase>. Over allows the desired columns
						  to be specified, while remove allows the unwanted columns to be specified. Thus
						  an alternative formulation of the query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">remove</emphasis> { ID };</programlisting></para> 
					 <para>There is another important difference between the SQL
						  version of projection, and the projection of D4: the elimination of duplicates.
						  In the SQL version of the query, we had to specify 
						  <phrase role="code"><emphasis
								role="bold">distinct</emphasis></phrase> in order to tell the system that
						  duplicates should be eliminated from the result. In D4, the result is never
						  allowed to contain duplicates, so no 
						  <phrase role="code"><emphasis
								role="bold">distinct</emphasis></phrase> keyword is required.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-AddingColumns"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into
									 D4</secondary><tertiary>Adding Columns</tertiary></indexterm>Adding
						  Columns</title> 
					 <para>Next we consider the effect of columns defined in terms
						  of expressions. Suppose we are asked 'Get IDs, and Names of all employees,
						  together with the length of the name for each employee.' In SQL, we would
						  write: 
						  <programlisting><emphasis role="bold">select</emphasis> ID, Name, Length(Name) <emphasis role="bold">from</emphasis> Employee</programlisting></para> 
					 <para>This query illustrates the second of the four tasks
						  specified in the 
						  <ulink
						  url="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-UnravelingtheColumnList.html"
						  type="link">column list</ulink>, that of extension. In SQL, an expression is
						  allowed to define the value for a given column in the result. </para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">add</emphasis> { Length(Name) NameLength };</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Add.html" type="link">add</ulink></emphasis></phrase>
						  operator of D4 allows columns to be added to the result. The values for the new
						  columns are given by the expressions in the add clause.</para> 
					 <para>An important point can be illustrated by asking a simple
						  question about the result of the SQL version of the query: What is the name of
						  the column containing the length of the name of each employee? The answer is,
						  it is undefined. The SQL syntax does not force the column to be named, and
						  without a name, it cannot be referenced by anything else in the query. This
						  fact has severe implications when we attempt to use queries of this type in
						  more complex expressions of SQL. By contrast, in the D4 version, the name is
						  specified as part of the definition of the column, so the problem is completely
						  avoided.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-RenamingColumns"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into
									 D4</secondary><tertiary>Renaming Columns</tertiary></indexterm>Renaming
						  Columns</title> 
					 <para>Next we discuss the renaming of columns in a result.
						  Suppose we want the 
						  <phrase role="code">Name</phrase> column in the result to
						  be called 
						  <phrase role="code">LastName</phrase>. In SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> ID, Name <emphasis role="bold">as</emphasis> LastName <emphasis role="bold">from</emphasis> Employee</programlisting></para> 
					 <para>This query illustrates the third of the four tasks being
						  specified by the 
						  <ulink
						  url="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-UnravelingtheColumnList.html"
						  type="link">column list</ulink>, that of renaming columns. The optional 
						  <phrase role="code"><emphasis
								role="bold">as</emphasis></phrase> keyword is used to specify a new name for
						  the given column.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">rename</emphasis> { Name LastName };</programlisting></para> 
					 <para>The 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Rename.html"
								type="link">rename</ulink></emphasis></phrase> operator of D4 allows the names
						  of the columns in a result to be changed. This operator has no effect on the
						  values of the columns in the result.</para> 
					 <para>To illustrate a point about the names of columns in the
						  result, consider the following SQL query: 
						  <programlisting><emphasis role="bold">select</emphasis> ID, Name, Name <emphasis role="bold">from</emphasis> Employee</programlisting>This query is perfectly legal in SQL, but the result has the
						  same name for two columns. Again, we are faced with the problem that the column
						  cannot be referenced by anything else in the query. In D4, all the columns of a
						  given result must be unique, so again, the problem is completely
						  avoided.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-TheGroupByandHavingClauses"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>The
									 Group By and Having Clauses</tertiary></indexterm>The Group By and Having
						  Clauses</title> 
					 <para>Now we consider queries in which columns in the result
						  are defined with aggregate expressions. Suppose we are asked 'Get the number of
						  employees.' In SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> Count(*) <emphasis role="bold">from</emphasis> Employee</programlisting>This invokes the aggregate operator 
						  <phrase role="code">Count(*)</phrase> on the 
						  <phrase role="code">Employee</phrase> table.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">group add</emphasis> { Count() EmployeeCount };</programlisting></para> 
					 <para>On the surface the SQL version of the query looks very
						  similar to the extend operator, but in reality, the task is completely
						  different, and is the fourth task specified in the 
						  <ulink
						  url="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-UnravelingtheColumnList.html"
						  type="link">column list</ulink>, that of 
						  <ulink url="D4LGTableExpressions-Aggregate.html"
						  type="link">aggregation</ulink>. Actually, the task is split between the
						  expressions in the column list, and the group by clause, a fact which serves to
						  complicate matters even further.</para> 
					 <para>By changing the query slightly to 'Get the names of
						  employees together with the number of employees that have that name' we get the
						  new statement: 
						  <programlisting><emphasis role="bold">select</emphasis> Name, Count(*) 
	<emphasis role="bold">from</emphasis> Employee 
	<emphasis role="bold">group by</emphasis> Name</programlisting></para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee 
	<emphasis role="bold">group by</emphasis> { Name } <emphasis role="bold">add</emphasis> { Count() EmployeeCount };</programlisting></para> 
					 <para>In the SQL version of the query, because the column list
						  includes both aggregate and non-aggregate expressions, we are forced to use the
						  group by clause to express the desired grouping. In SQL, the task of specifying
						  an aggregation is split between the select list where the columns to be
						  computed are specified, and the group by clause, where the grouping columns are
						  specified. In D4, the group operator allows the grouping columns to be
						  specified directly. This is followed immediately by the specification of the
						  aggregates to compute.</para> 
					 <para>Note that the group by in SQL is not allowed to reference
						  aliases. With that in mind, consider the following two equivalent SQL queries: 
						  <programlisting><emphasis role="bold">select</emphasis> ID / 2, Count(*)
	<emphasis role="bold">from</emphasis> Employee
	<emphasis role="bold">group by</emphasis> ID / 2</programlisting> 
						  <programlisting><emphasis role="bold">select</emphasis> ID / 2, Count(*)
	<emphasis role="bold">from</emphasis> Employee
	<emphasis role="bold">group by</emphasis> ID * 0.5</programlisting></para> 
					 <para>Clearly, these two queries are equivalent, but one is a
						  legal SQL query, and the other is not. Because the group by clause must contain
						  at least the non-aggregate columns in the select list, we are forced to write
						  out the expression multiple times, and we cannot use what are clearly
						  equivalent formulations of the expression. In D4, this query becomes: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee 
	<emphasis role="bold">add</emphasis> { ID / 2 HalfID } 
	<emphasis role="bold">group by</emphasis> { HalfID } <emphasis role="bold">add</emphasis> { Count() EmployeeCount };</programlisting></para> 
					 <para>Note that the actual task of computing the expression to
						  be grouped on is relegated to the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Add.html" type="link">add</ulink></emphasis></phrase>
						  operator, rather than intermixed with the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Aggregate.html"
								type="link">group</ulink></emphasis></phrase> operator. By cleanly separating
						  the tasks involved, the complexity of the language is reduced, while the power
						  is increased.</para> 
					 <para>To pursue this example further, suppose we only want rows
						  in the result for which the 
						  <phrase role="code">EmployeeCount</phrase> is greater than
						  one. In SQL, the query becomes: 
						  <programlisting><emphasis role="bold">select</emphasis> ID / 2, Count(*)
	<emphasis role="bold">from</emphasis> Employee
	<emphasis role="bold">group by</emphasis> ID / 2
	<emphasis role="bold">having</emphasis> Count(*) &gt; 1</programlisting></para> 
					 <para>The addition of the having clause allows us to filter the
						  result based on the values computed for aggregate expressions in the select
						  list. Again, column aliases cannot be referenced, so we are forced to write out
						  the same aggregate expression (with the same restrictions on usage, namely it
						  must be syntactically the same expression, not semantically) in order to
						  express the desired filter. In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee 
	<emphasis role="bold">add</emphasis> { ID / 2 HalfID } 
	<emphasis role="bold">group by</emphasis> { HalfID } <emphasis role="bold">add</emphasis> { Count() EmployeeCount } 
	<emphasis role="bold">where</emphasis> EmployeeCount &gt; 1;</programlisting></para> 
					 <para>There is no need to introduce a new concept for
						  filtering, we already have that functionality in the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Where.html"
								type="link">where</ulink></emphasis></phrase> operator. Because D4 is an
						  algebra, the result of any operator can be used as an argument to the next
						  operator. This allows us to simply add another where referencing the 
						  <phrase role="code">EmployeeCount</phrase> column.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-TheFromandJoinClauses"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>The
									 From and Join Clauses</tertiary></indexterm>The From and Join Clauses</title> 
					 <para>With the column list completely unraveled, we now turn
						  our attention to the from clause. Up till now, we have been using a very simple
						  from clause in all our queries: 
						  <phrase role="code"><emphasis role="bold">from</emphasis>
								Employee</phrase>. In SQL, the from clause is allowed to contain any number of
						  references to tables together with the specification of how those tables should
						  be brought together in the result. Suppose we are asked 'Get IDs, Names and
						  Phone Numbers of all Employees.' The information to satisfy this query is in
						  two different tables, 
						  <phrase role="code">Employee</phrase> and 
						  <phrase role="code">EmployeePhone</phrase>. In SQL, we use
						  a join and write: 
						  <programlisting><emphasis role="bold">select</emphasis> * 
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">on</emphasis> ID = Employee_ID</programlisting></para> 
					 <para>This query references the 
						  <phrase role="code">Employee</phrase> table, then joins it
						  to the 
						  <phrase role="code">EmployeePhone</phrase> table using the
						  relationship 
						  <phrase role="code">ID = Employee_ID</phrase>. This type of
						  join is also called an inner join, and the keyword 
						  <phrase role="code"><emphasis
								role="bold">inner</emphasis></phrase> may even be specified in the join clause.
						  We can further categorize this type of join as an equi-join, meaning that the
						  condition specified to perform the join consists only of equality comparisons
						  between columns in opposite tables of the join, and that all such comparisons
						  are required to be true in order for a match to appear in the result (in other
						  words, only the 
						  <phrase role="code"><emphasis
								role="bold">and</emphasis></phrase> operator is used between column equality
						  comparisons).</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee 
	<emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID;</programlisting></para> 
					 <para>Note again the disappearance of the '<phrase
						  role="code">* <emphasis role="bold">from</emphasis></phrase>' portion of the
						  query. Because no projection is being performed, it is simply not specified.
						  Note also that in D4 there is no 
						  <phrase role="code"><emphasis
								role="bold">inner</emphasis></phrase> keyword.</para> 
					 <para>To illustrate the next kind of 
						  <ulink url="D4LGTableExpressions-Join.html"
						  type="link">join</ulink>, suppose we are asked 'Get all possible combinations
						  of two employees.' In SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> * 
	<emphasis role="bold">from</emphasis> Employee 
		<emphasis role="bold">cross join</emphasis> Employee</programlisting></para> 
					 <para>This is known as the cross-product, or 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Times.html"
								type="link">times</ulink></emphasis></phrase> operator, and specifies that for
						  each row in the left table and each row in the right table a row should appear
						  in the result that is the concatenation of both rows. Note that we now have two
						  of each column in the result, and are faced with another naming problem. In
						  order to solve this problem in SQL, we can make use of the concept of
						  <emphasis>table aliases</emphasis>. By rewriting the query as: 
						  <programlisting><emphasis role="bold">select</emphasis> * 
	<emphasis role="bold">from</emphasis> Employee E1 
		<emphasis role="bold">cross join</emphasis> Employee E2</programlisting>we can now uniquely reference all the columns in the result.
						  </para> 
					 <para>In D4, the first query would be: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">times</emphasis> Employee;</programlisting>but this would fail with a compile-time error stating that
						  duplicate names exist in the result. In order to express the query, we can make
						  use of the rename operator: 
						  <programlisting><emphasis role="bold">select</emphasis> (Employee <emphasis role="bold">rename</emphasis> { ID E1.ID, Name E1.Name }) 
	<emphasis role="bold">times</emphasis> (Employee <emphasis role="bold">rename</emphasis> { ID E2.ID, Name E2.Name });</programlisting></para> 
					 <para>Clearly this involves an excessive amount of renaming, so
						  D4 introduces a variant of the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Rename.html"
								type="link">rename</ulink></emphasis></phrase> operator that works for all the
						  columns in a table. Using this operator we can rewrite the query as: 
						  <programlisting><emphasis role="bold">select</emphasis> (Employee <emphasis role="bold">rename</emphasis> E1) times (Employee <emphasis role="bold">rename</emphasis> E2);</programlisting>and obtain an equivalent result.</para> 
					 <para>The next kind of join possible in the join clause is
						  called an 
						  <ulink url="D4LGTableExpressions-OuterJoin.html"
						  type="link">outer join</ulink>. There are three different flavors of outer join
						  in SQL: left, right, and full. Suppose we are asked 'Get IDs and Names of all
						  employees toghether with the PhoneNumbers of those employees, if they have
						  one.' In SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> *
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">left join</emphasis> EmloyeePhone <emphasis role="bold">on</emphasis> ID = Employee_ID</programlisting></para> 
					 <para>This query indicates that a join should be performed
						  between 
						  <phrase role="code">Employee</phrase> and 
						  <phrase role="code">EmployeePhone</phrase>, but that if a
						  given 
						  <phrase role="code">Employee</phrase> row has no match, it
						  should be included in the result with nulls for the columns of 
						  <phrase role="code">EmployeePhone</phrase>.</para> 
					 <para>In D4, the equivalent query is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">left join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID;</programlisting></para> 
					 <para>The right join simply specifies the right table as the
						  one that should have unmatched rows included, and a full join states that both
						  sides should have unmatched rows included. D4 supports the right join, with the
						  
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-OuterJoin.html" type="link">right
									 join</ulink></emphasis></phrase> operator, but does not support the full join
						  operator, as it is rarely used, and is only shorthand for the union of the left
						  and right joins.</para> 
					 <para>An important difference between the join operators of SQL
						  and D4 is that in D4, all joins are required to be 
						  <ulink url="D4LGTableExpressions-Join-NaturalJoins.html"
						  type="link">equi-joins</ulink>. To see why this is so, we must first show that
						  any join can be expressed using a combination of cross-product and restrict: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting> is logically equivalent to: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">cross join</emphasis> EmployeePhone <emphasis role="bold">where</emphasis> ID = Employee_ID</programlisting>This means that any non-equi join such as: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID &gt; Employee_ID</programlisting>can always be expressed using the equivalent cross-product and
						  restriction, so we do not lose any expressive power by restricting joins to be
						  equi-joins. However, we do gain the benefit that the cardinality of any join is
						  always well-defined, which has implications for the key inference mechanism of
						  D4. For this reason, all joins in D4 are required to be equi-joins.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-TheTableOperatorClause"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>The
									 Table Operator Clause</tertiary></indexterm>The Table Operator Clause</title> 
					 <para><indexterm><primary>Union
									 Compatible</primary></indexterm>Now that we have described the 
						  <phrase
						  role="code">&lt;select&nbsp;expression&gt;</phrase>, we discuss the 
						  <phrase
						  role="code">&lt;table&nbsp;operator&nbsp;clause&gt;</phrase>, which allows
						  complete select expressions to be used as arguments to the <emphasis><ulink url="D4LGQueryExpression.html"
						  type="link">union-compatible</ulink></emphasis> binary table operators: union,
						  intersection and difference. Two tables in SQL are union-compatible if they
						  have the same number of columns, and the columns have assignment-compatible
						  data types, from left to right (i.e. the first column in the left table is the
						  same type as the first column in the right table, and so on).</para> 
					 <para>First, we consider the union operator. Suppose we are
						  asked 'Get the IDs of all employees that have phones or that have managers.' In
						  SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> ID 
	<emphasis role="bold">from</emphasis> Employee 
		<emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID
<emphasis role="bold">union</emphasis>
<emphasis role="bold">select</emphasis> ID
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting></para> 
					 <para>This query uses the union operator to combine the 
						  <phrase role="code">ID</phrase> column from each portion of
						  the query into a single result. A row will appear in the result of a union if
						  it appears in the left table or the right table, or both.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis> 
	(Employee <emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID) 
	<emphasis role="bold">union</emphasis> 
	(Employee <emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID);</programlisting></para> 
					 <para>There is an important difference between the two
						  operators. In SQL, the union clause is allowed to include an optional 
						  <phrase role="code"><emphasis
								role="bold">all</emphasis></phrase> which indicates that duplicates should not
						  be eliminated from the result. If a given row appears in both the left and
						  right sides of the union, it will appear twice in the result. In D4, duplicates
						  are never allowed, so no such option is available for the 
						  <ulink url="D4LGTableExpressions-Union.html"
						  type="link">union</ulink> operator.</para> 
					 <para>Next, we consider the intersect operator. If we change
						  our query to 'Get the IDs of all employees that have phones and that have
						  managers' then the SQL becomes: 
						  <programlisting><emphasis role="bold">select</emphasis> ID
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID
<emphasis role="bold">intersect</emphasis>
<emphasis role="bold">select</emphasis> ID
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting></para> 
					 <para>This query uses the 
						  <phrase role="code"><emphasis
								role="bold">intersect</emphasis></phrase> operator to compute the desired
						  result. A row will appear in the result of an intersect if it appears in the
						  left table and the right table.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis>
	(Employee <emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID)
	<emphasis role="bold">intersect</emphasis>
	(Employee <emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID);</programlisting></para> 
					 <para>Again, note that the SQL version of the operator includes
						  an optional 
						  <phrase role="code"><emphasis
								role="bold">all</emphasis></phrase> which specifies that duplicates should not
						  be eliminated from the result. D4 has no such option for the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Intersect.html"
								type="link">intersect</ulink></emphasis></phrase> operator.</para> 
					 <para>Finally, the difference operator. If we change our query
						  to 'Get the IDs of all employees that have phones and do not have managers'
						  then the SQL becomes: 
						  <programlisting><emphasis role="bold">select</emphasis> ID
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID
<emphasis role="bold">except</emphasis>
<emphasis role="bold">select</emphasis> ID
	<emphasis role="bold">from</emphasis> Employee
		<emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID</programlisting></para> 
					 <para>This query uses the difference operator to remove the 
						  <phrase role="code">ID</phrase> for any employee that has a
						  manager from the result. A row will only appear in the result of a difference
						  if it appears in the left table and not the right table.</para> 
					 <para>The equivalent query in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis>
	(Employee <emphasis role="bold">join</emphasis> EmployeePhone <emphasis role="bold">by</emphasis> ID = Employee_ID)
	<emphasis role="bold">minus</emphasis>
	(Employee <emphasis role="bold">join</emphasis> Manager <emphasis role="bold">by</emphasis> ID = Employee_ID);</programlisting></para> 
					 <para>Once again, the SQL version of the operator includes the 
						  <phrase role="code"><emphasis
								role="bold">all</emphasis></phrase> keyword which specifies that duplicate
						  elimination should not occur. D4 has no counterpart for this version of the
						  difference operator, 
						  <ulink url="D4LGTableExpressions-Minus.html"
						  type="link">minus</ulink>.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-TheOrderByClause"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>The
									 Order By Clause</tertiary></indexterm>The Order By Clause</title> 
					 <para>The order by clause in D4 maps in a fairly
						  straightforward way into D4. For example, suppose we are asked 'Get the IDs and
						  Names of all Employees ordered by Name alphabetically. In SQL we write: 
						  <programlisting><emphasis role="bold">select</emphasis> ID, Name
	<emphasis role="bold">from</emphasis> Employee
	<emphasis role="bold">order by</emphasis> Name</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting><emphasis role="bold">select</emphasis> Employee <emphasis role="bold">order by</emphasis> { Name };</programlisting></para> 
					 <para>In both languages, the order by is not part of the
						  expression, rather it is part of the specification of how the result should be
						  returned. In other words, the 
						  <ulink url="D4LGOrders.html" type="link">order</ulink> by
						  clause in D4 is not an operator, it is part of the select statement.</para> 
				</sect2> 
				<sect2
				id="D4LGComparisonWithSQL-MappinganSQLQueryIntoD4-DataModificationStatements"> 
					 <title><indexterm><primary>Comparison With
									 SQL</primary><secondary>Mapping an SQL Query Into D4</secondary><tertiary>Data
									 Modification Statements</tertiary></indexterm>Data Modification
						  Statements</title> 
					 <para>The syntax for the 
						  <ulink
						  url="D4LGDataManipulation-InsertStatement.html" type="link">insert</ulink>, 
						  <ulink
						  url="D4LGDataManipulation-UpdateStatement.html" type="link">update</ulink>, and
						  
						  <ulink
						  url="D4LGDataManipulation-DeleteStatement.html" type="link">delete</ulink>
						  statements in SQL and D4 is very similar, even identical in some respects, so
						  the mapping is relatively straightforward. There are some important logical
						  differences between the semantics of the operators, particularly for the insert
						  and update.</para> 
					 <para>First, we discuss the 
						  <ulink
						  url="D4LGDataManipulation-InsertStatement.html" type="link">insert</ulink>
						  statement. Suppose we want to add a new employee into the list of Employees. In
						  SQL, we have: 
						  <programlisting><emphasis role="bold">insert into</emphasis> Employee(ID, Name) <emphasis role="bold">values</emphasis>(7, "Jake")</programlisting></para> 
					 <para>This example illustrates the use of the first variation
						  of the insert statement in SQL, that of inserting a single row. Suppose we want
						  to insert the results of some query. In SQL, we have: 
						  <programlisting><emphasis role="bold">insert into</emphasis> Employee(ID, Name) <emphasis role="bold">select</emphasis> ID + 6, Name <emphasis role="bold">from</emphasis> Employee</programlisting></para> 
					 <para>In D4, the equivalent statements are: 
						  <programlisting><emphasis role="bold">insert table</emphasis> { <emphasis role="bold">row</emphasis> { 7 ID, "Jake" Name } } <emphasis role="bold">into</emphasis> Employee;</programlisting>and 
						  <programlisting><emphasis role="bold">insert</emphasis> Employee <emphasis role="bold">redefine</emphasis> { ID := ID + 6 } <emphasis role="bold">into</emphasis> Employee;</programlisting>Note: the 
						  <phrase role="code"><emphasis role="bold"><ulink
								url="D4LGTableExpressions-Redefine.html"
								type="link">redefine</ulink></emphasis></phrase> operator is shorthand for an
						  equivalent 
						  <phrase role="code"><emphasis
								role="bold">add-rename-remove</emphasis></phrase> operation.</para> 
					 <para>Several important points should be made about the above
						  statements: 
						  <itemizedlist> 
								<listitem> 
									 <para>Left-to-right ordering</para> 
									 <para>In the SQL versions of the statements, the
										  left-to-right order of the 
										  <phrase
										  role="code">&lt;values&nbsp;clause&gt;</phrase> in the single row insert, and
										  the 
										  <phrase
										  role="code">&lt;query&nbsp;expression&gt;</phrase> in the multiple row insert
										  is important. By contrast, D4 attaches no significance to the order of the
										  columns in the statement. For example: 
										  <programlisting><emphasis role="bold">insert</emphasis> <emphasis role="bold">table</emphasis> { <emphasis role="bold">row</emphasis> { "Jake" Name, 7 ID } } <emphasis role="bold">into</emphasis> Employee</programlisting>has the same effect because the columns are matched by name,
										  not by position in the result.</para> 
								</listitem> 
								<listitem> 
									 <para>Order of specification</para> 
									 <para>In Common SQL, the insert target is specified
										  first. In english, the insert statement could be rendered 'insert into this
										  table, that data.' In D4, the data to be inserted is specified first, rendering
										  the english equivalent as 'insert this data into that table.'</para> 
								</listitem> 
								<listitem> 
									 <para>Restrictions on target</para> 
									 <para>In Common SQL, the insert target must be a
										  table variable name. In D4, the insert target is allowed to be an arbitrary
										  table-valued expression, i.e. the expression could consist of joins,
										  projections, restrictions, etc.,.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Next, we discuss the 
						  <ulink
						  url="D4LGDataManipulation-UpdateStatement.html" type="link">update</ulink>
						  statement. Suppose we discover that the employee with ID 6 is really named
						  'John'. In SQL, we would write: 
						  <programlisting><emphasis role="bold">update</emphasis> Employee <emphasis role="bold">set</emphasis> Name = 'John' <emphasis role="bold">where</emphasis> ID = 6</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting><emphasis role="bold">update</emphasis> Employee <emphasis role="bold">set</emphasis> { Name := 'John' } <emphasis role="bold">where</emphasis> ID = 6;</programlisting></para> 
					 <para>While the two statements are very similar in structure,
						  there are some important differences: 
						  <itemizedlist> 
								<listitem> 
									 <para>Assignment operator</para> 
									 <para>The D4 version of the statement uses the
										  assignment operator 
										  <phrase role="code"><ulink
												url="D4LGImperativeStatements-Variables-AssignmentStatement.html"
												type="link">:=</ulink></phrase> to indicate that this is indeed an assignment
										  statement. The current value of the variable is being replaced by a new
										  value.</para> 
								</listitem> 
								<listitem> 
									 <para>Restrictions on target</para> 
									 <para>As with the insert statement, the D4 update
										  statement allows the target to be an arbitrary table-valued expression, rather
										  than requiring it to be the name of a table variable as in SQL.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>Finally, the 
						  <ulink url="O-System.Delete.html"
						  type="olinka">delete</ulink> statement. Suppose we decide to remove the
						  employee with ID 7 from the list of employees. In SQL, we have: 
						  <programlisting><emphasis role="bold">delete</emphasis> Employee <emphasis role="bold">where</emphasis> ID = 7</programlisting></para> 
					 <para>The equivalent statement in D4 is: 
						  <programlisting><emphasis role="bold">delete</emphasis> Employee <emphasis role="bold">where</emphasis> ID = 7;</programlisting></para> 
					 <para>The important difference between the two statements lies
						  in the specification of the target. As with the other modification operators in
						  D4, the delete statement is allowed to target an arbitrary table-valued
						  expression. In fact, the where clause is not part of the syntax of the delete
						  statement in D4, rather it is part of the table expression to be
						  deleted.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
</part>
