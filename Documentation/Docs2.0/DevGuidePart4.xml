<?xml version="1.0" encoding="UTF-8"?>
<part id="DDGPhysicalRealization"> 
	 <partinfo> 
		  <date role="LastMod">Tuesday, November 21, 2006 10:17:55 AM</date> 
	 </partinfo> 
	 <title>Physical Realization</title> 
	 <partintro> 
		  <para>Physical realization is the process of mapping a logical
				application schema onto one or more devices to provide persistent storage. The
				physical layer of the DBMS architecture is concerned with actually storing the
				information exposed by the application, and providing efficient, transactional
				access to that information.</para> 
		  <para>The Dataphor Server utilizes existing DBMSs as its physical, or
				internal, layer. In other words, the Dataphor Server uses SQL-based DBMSs as
				its file system. The internal layer of the Dataphor Product is based on an
				architecture called the Storage Integration Architecture (SIA).</para> 
		  <para>This part is devoted to explaining how the SIA works, and how it
				enables the homogeneous data access achieved by the Dataphor Server. It also
				discusses concepts and techniques for mapping logical application schema into
				physical devices.</para> 
		  <para>Although the SIA is capable of describing any storage system, the
				majority of the discussions in this part will focus on SQL-based devices in
				particular, as these form the bulk of the devices shipped with the Dataphor
				Product, and are generally more complex in nature than text or file-based
				devices.</para> 
	 </partintro> 
	 <chapter id="DDGStorageIntegrationArchitecture"> 
		  <title><indexterm> 
					 <primary>Storage Integration Architecture</primary> 
				</indexterm>Storage Integration Architecture</title> 
		  <para>Information in todays enterprises is stored in an ever-increasing
				number of systems, from file-based data repositories, to SQL-based DBMSs, and
				everything in between. The Dataphor Server provides a single point-of-access
				for all these data sources through an abstraction called the Storage
				Integration Architecture (SIA).</para> 
		  <para>This architecture is based on the idea that fundamentally, all
				data may be represented within a single unified model, namely the relational
				model, and that access to any data source can be achieved by providing an
				open-ended architecture that can communicate with any given data source in
				whatever manner is appropriate.</para> 
		  <para>The central abstraction of this architecture is called a
				<emphasis>device</emphasis>, and represents a single instance of a data source.
				That data source may be as simple as a formatted text file, or as complex as a
				traditional SQL-based DBMS.</para> 
		  <para>The SIA uses the concept of a device to define all the interfaces
				that are required in order to enable not only access to the data, but to allow
				offloading of query processing tasks to target systems whenever possible. To
				enable this abstraction, the device architecture is layered in much the same
				way that the Call-Level Interface is, dividing the functionality into server,
				session, plan, and cursor layers.</para> 
		  <para>The server level of the architecture is concerned with describing
				the overall functionality of the device. This layer of the architecture
				supplies the level at which device-wide settings and behavior are implemented.
				Device sessions are obtained from this interface, with each process in the
				Dataphor Server obtaining a separate session for communicating with each device
				involved in a given transaction.</para> 
		  <para>The session level of the architecture models the connectivity and
				authentication capabilities of the target system, as well as the transaction
				management facilities. Each session participates in the same distributed
				transaction coordinated by the process running in the Dataphor Server. The
				session also provides the mechanism for executing commands and opening cursors
				against the target systems.</para> 
		  <para>The plan level of the architecture models statement execution
				against the target system. Each statement, or chunk of a statement, that can be
				supported by the target system is represented by a single plan within the
				Dataphor Server. The plan also provides facilities for opening a cursor against
				the result set of the statement, where appropriate.</para> 
		  <para>The cursor level of the architecture models retrieval of a result
				set from the target system. This level of the architecture implements the same
				interfaces required by cursors internally in the Dataphor Server. This allows
				devices to participate directly in the pipelined execution engine of the
				Dataphor Server. Moreover, device processing can be spawned at any point in the
				execution tree, allowing the Dataphor Server to offload as much processing as
				possible, while still guaranteeing that any expression will ultimately be
				evaluated correctly, regardless of where the data is physically located.</para>
		  
		  <sect1 id="DDGStorageIntegrationArchitecture-ObjectMaps"> 
				<title><indexterm> 
						  <primary>Object Maps</primary> 
					 </indexterm><indexterm> 
						  <primary>Storage Integration Architecture</primary> 
						  <secondary>Object Maps</secondary> 
					 </indexterm>Object Maps</title> 
				<para>To enable the complete mapping of constructs and expressions
					 in the logical model, the SIA provides four basic types of maps: 
					 <itemizedlist> 
						  <listitem> 
								<para>Scalar Type Maps</para> 
						  </listitem> 
						  <listitem> 
								<para>Operator Maps</para> 
						  </listitem> 
						  <listitem> 
								<para>Table Maps</para> 
						  </listitem> 
						  <listitem> 
								<para>User Maps</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Scalar type maps provide value translation services to and
					 from the target system. The scalar type map is responsible for translating
					 values from the native representation of a value within the Dataphor Server to
					 the device representation of the value within the target system, and vice
					 versa. Scalar type maps will be discussed in detail in 
					 <ulink type="link"
					  url="DDGScalarTypeMapping.html"><citetitle>Scalar Type
								Mapping</citetitle></ulink></para> 
				<para>Operator maps provide the translation services for operator
					 invocations from D4 to the corresponding invocation within the target system.
					 These mappings can be as simple as the mapping for basic arithmetic operators,
					 or as complex as the 
					 <phrase role="code"><emphasis
						  role="bold">join</emphasis></phrase> operator. In either case, the map is
					 responsible not only for the translation of the invocation, but for deciding
					 whether or not the invocation is supported by the target system. Operator maps
					 will be discussed in detail in 
					 <ulink type="link"
					  url="DDGOperatorMapping.html"><citetitle>Operator
								Mapping</citetitle></ulink></para> 
				<para>Table maps provide the persistence mechanism of the Dataphor
					 Server. Each base table variable in the Dataphor Server is mapped to some
					 structure in the target system. Note that the structure may be a file, a
					 registry key, or an SQL-based table or view definition.</para> 
				<para>Typically, table mapping is done automatically using the
					 default device for the current library. For example, in the Shipping
					 application, the default device name in the 
					 <phrase role="code">Sample.Shipping</phrase> library definition
					 is set to 
					 <phrase role="code">Shipping</phrase>. After the 
					 <phrase role="code">Shipping</phrase> device is created, any
					 global base table variable created in the 
					 <phrase role="code">Sample.Shipping</phrase> library will be
					 mapped into this device.</para> 
				<para>User maps allow users created in the Dataphor Server to use a
					 different set of credentials to connect to the target system. These maps can be
					 configured on a per-user basis, allowing multiple users to use the same set of
					 credentials to connect to a given system. If no user mapping is provided, the
					 information configured on the device will be used. If no configuration is
					 supplied on the device, the Dataphor Server user information will be
					 used.</para> 
				<para>When a new connection to a device must be established for the
					 current process, the following sequence of steps is taken to determine which
					 device user should be used: 
					 <orderedlist> 
						  <listitem> 
								<para>If a device user mapping is set up for the
									 current user explicitly, that device user is used.</para> 
						  </listitem> 
						  <listitem> 
								<para>If user configuration is provided on the device
									 itself, that information is used.</para> 
						  </listitem> 
						  <listitem> 
								<para>Otherwise, the credentials for the current user
									 are used.</para> 
						  </listitem> 
					 </orderedlist></para> 
				<para>If the above process selects a device user, and the selected
					 device user has explicitly specified connection parameters, these are used as
					 overrides for any connection parameters specified by the device and connection
					 string builder. For more information on how connection strings are built, refer
					 to the section on 
					 <ulink type="link" url="DDGP2BasicConnectivity.html">Basic
						  Connectivity</ulink>.</para> 
		  </sect1> 
		  <sect1 id="DDGP2ProcessorIntegration"> 
				<title><indexterm> 
						  <primary>Processor Integration</primary> 
					 </indexterm>Processor Integration</title> 
				<para>When an operator invocation in D4 is processed by some
					 device, it is the responsibility of that device to provide the results of the
					 operation in terms the Dataphor Server can understand. Conversely, when
					 modification to the data contained in a particular device is required, it is
					 the responsibility of the device to translate the request for modification from
					 the Dataphor Server into a form that can be consumed by the data store being
					 modeled. The Storage Integration Architecture provides the framework for the
					 solution to this problem.</para> 
				<para>Processor integration occurs whenever the Dataphor Server
					 requires data from some device, or whenever the data stored in some device
					 needs to be updated to reflect the changes made by some statement in the
					 Dataphor Server. The query chunking process determines where both of these
					 integration points occur.</para> 
				<para>This section first describes the retrieval integration, then
					 the modification integration, and concludes with a description of how these
					 integration points are determined by the compiler.</para> 
				<sect2 id="DDGP2DataRetrieval"> 
					 <title><indexterm> 
								<primary>Data Retrieval</primary> 
						  </indexterm>Data Retrieval</title> 
					 <para>The execution of a prepared device plan provides an
						  alternative execution path for the query processor to follow. The execution
						  path can be thought of as leaving the query processor at the device execute,
						  and re-entering when the device processing has completed. The results of the
						  processing are returned using native representations, just like any other
						  execution in the query processor. This allows device execution to completely
						  replace query processing at any point in the expression, meaning that devices
						  are not only capable of delivering data in the form of tables, but also scalar
						  values, row values, etc.,.</para> 
					 <para>When non-table values are returned, device processing has
						  generally completed, and the value returned is autonomous in the sense that the
						  device session could be closed, without affecting the availability of the
						  value. For table values, this is generally not the case. Just as in the
						  Dataphor Server, device supported table values are materialized on demand using
						  cursors. For this reason, a typical device will provide a cursor implementation
						  to fulfill the interface requirements of a cursor in the Dataphor
						  Server.</para> 
				</sect2> 
				<sect2 id="DDGP2DataModification"> 
					 <title><indexterm> 
								<primary>Data Modification</primary> 
						  </indexterm>Data Modification</title> 
					 <para>In general, data modification can be supported by a given
						  device at a different level than retrieval. This allows the query updatability
						  capabilities of the Dataphor Server to be mapped onto devices which may not
						  support the same functionality, without compromising the retrieval
						  characteristics of the device.</para> 
					 <para>There are three mechanisms by which a device may perform
						  data modifications: 
						  <itemizedlist mark="bullet"> 
								<listitem> 
									 <para>Modification Statements</para> 
									 <para>Devices may be capable of executing complete
										  insert, update, and delete statements.</para> 
								</listitem> 
								<listitem> 
									 <para>Cursor Updates</para> 
									 <para>Devices may provide updatability through
										  cursors.</para> 
								</listitem> 
								<listitem> 
									 <para>Row Level Updates</para> 
									 <para>Devices may provide updatability through row
										  level commands.</para> 
								</listitem> 
						  </itemizedlist></para> 
					 <para>The level at which data modifications are performed is
						  determined by the device implementation.</para> 
				</sect2> 
				<sect2 id="DDGP2QueryChunking3"> 
					 <title><indexterm> 
								<primary>Query Chunking</primary> 
						  </indexterm>Query Chunking</title> 
					 <para>Query chunking is the process of determining exactly
						  where a processor integration point will occur during the processing of a
						  specific query.</para> 
					 <para>Basically, the process involves ensuring that a given
						  branch of the executable tree can be entirely handled by a given device, and
						  then requesting that the device prepare this portion of the expression. At this
						  point, the device will either provide a prepared plan ready for execution in
						  the device, or indicate that the requested operation cannot be performed by the
						  device.</para> 
					 <para>The query chunking algorithm begins at the leaf nodes of
						  the execution tree. A leaf node is either a base table variable retrieval, or
						  some other node such as a literal value. For the base table variable retrieval,
						  the node is assigned to be processed on the device responsible for storage of
						  the base table variable. The device in question is required to support this
						  operation. For other types of leaf nodes, no device is assigned, indicating the
						  node is <emphasis>device associative</emphasis>.</para> 
					 <para>A device associative node is one for which the device can
						  only be determined in the context of some other operation. For example,
						  supporting an arbitrary scalar operation depends on which device, if any, is
						  requested to support the operation. At the level of the operation itself, no
						  device association is made, and only when the operation is requested within the
						  context of some other operation that is associated with a given device can the
						  device determination be made.</para> 
					 <para>For example, given the following D4 statement: 
						  <programlisting><emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">where</emphasis> ID = 5;</programlisting></para> 
					 <para>The 
						  <phrase role="code">ShowPlan</phrase> system operator can
						  be used to display the execution plan chosen by the Dataphor Server: 
						  <programlisting><emphasis role="bold">select</emphasis> ShowPlan('select Invoice where ID = 5');</programlisting> 
						  <programlisting>8438: RestrictNode
	Type: 
		table 
		{ 
			ID : InvoiceID, 
			Location_ID : LocationID, 
			User_ID : UserID, 
			Date : Date, 
			Status_ID : InvoiceStatusID 
		}
		key { }
	Device: Shipping
	8483: BaseTableVarNode
		Type: 
			table 
			{ 
				ID : InvoiceID, 
				Location_ID : LocationID, 
				User_ID : UserID, 
				Date : Date, 
				Status_ID : InvoiceStatusID 
			}
			key { ID }
		Device: Shipping
	8424: IntegerEqualNode
		Type: Boolean
		No device
		8423: ScalarReadAccessorNode
			Type: Integer
			No device
			8421: StackColumnReferenceNode
				Type: InvoiceID
				No device
				Column Name: ID Stack Index: 0
		8419: ValueNode
			Type: Integer
			No device</programlisting></para> 
					 <para>The 
						  <phrase role="code">ValueNode</phrase> representing the
						  literal integer value 
						  <phrase role="code">5</phrase> is a device associative
						  node, because no device determination can be made by looking at the node in
						  isolation. Only when the entire equality expression 
						  <phrase role="code">ID = 5</phrase> is considered in the
						  context of the 
						  <phrase role="code"><emphasis
								role="bold">where</emphasis></phrase> operator can the device determination be
						  made.</para> 
					 <para>As the chunking process progresses, the devices are asked
						  whether they support the operations involved at a higher and higher level until
						  either the devices no longer support the operations involved, or the operation
						  spans multiple devices. In either of these cases, processing is handled by the
						  Dataphor Server.</para> 
					 <para>In order to determine whether or not a given branch of
						  the execution tree is supported, the device is asked to prepare a device plan
						  corresponding to the root node of the branch. This prepare step invokes the
						  device compiler for translating the D4 instructions into equivalent
						  instructions in the device. If the device compilation step is successful, the
						  result is a prepared device plan ready for execution. Otherwise, the chunking
						  algorithm stops, and the query processor is assigned to take over
						  execution.</para> 
					 <para>This algorithm naturally produces an expression tree
						  which is optimized to offload as much processing as possible to the devices
						  involved. If only a single device is involved and all the operations are
						  supported by that device, the entire tree is processed externally. Only when
						  multiple devices are involved, or some operation is requested which a device
						  cannot perform, does the Dataphor Server perform processing.</para> 
					 <sect3 id="DDGDisplayingSQLTranslationOutput"> 
						  <title><indexterm> 
									 <primary>Displaying SQL Translation
										  Output</primary> 
								</indexterm><indexterm> 
									 <primary>Query Chunking</primary> 
									 <secondary>Displaying SQL Translation
										  Output</secondary> 
								</indexterm>Displaying SQL Translation Output</title> 
						  <para>The 
								<phrase role="code">D4ToSQL</phrase> operator
								registered by the 
								<phrase role="code">SQLDevice</phrase> library can be
								used to obtain the SQL for a statement that is completely supported by a given
								device: 
								<programlisting><emphasis role="bold">select</emphasis> D4ToSQL('select Invoice where ID = 5');</programlisting> 
								<programlisting>select 
		"T1"."ID" as "ID", 
		"T1"."Location_ID" as "Location_ID", 
		"T1"."User_ID" as "User_ID", 
		"T1"."Date" as "Date", 
		"T1"."Status_ID" as "Status_ID"
	from "Sample__Shipping__Invoice" as "T1" (fastfirstrow)
	where ("T1"."ID" = @P1);</programlisting></para> 
					 </sect3> 
					 <sect3 id="DDGSupportWarnings"> 
						  <title><indexterm> 
									 <primary>Support Warnings</primary> 
								</indexterm><indexterm> 
									 <primary>Query Chunking</primary> 
									 <secondary>Support Warnings</secondary> 
								</indexterm>Support Warnings</title> 
						  <para>In order to help ensure that queries are being
								offloaded whenever possible, the Dataphor Server will issue
								<emphasis>unsupported</emphasis> warnings whenever the chunking process results
								in an execution plan that only involves a single device, but is not entirely
								supported on that device.</para> 
						  <para>For example, consider the following operator
								definition and D4 query: 
								<programlisting><emphasis role="bold">create operator</emphasis> UnsupportedOperator(<emphasis role="bold">const</emphasis> AID : Integer) : Integer
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">result</emphasis> := AID;
<emphasis role="bold">end</emphasis>;

<emphasis role="bold">select</emphasis> Invoice <emphasis role="bold">add</emphasis> { UnsupportedOperator(ID) TempID };</programlisting></para> 
						  <para>The invocation of 
								<phrase role="code">UnsupportedOperator</phrase> within
								the 
								<phrase role="code"><emphasis
									 role="bold">add</emphasis></phrase> clause causes the compiler to issue a
								warning stating that the query was not supported because the device does not
								contain an operator map for 
								<phrase
								 role="code">UnsupportedOperator</phrase>.</para> 
						  <para>To disable this warning, use the 
								<phrase role="code">IgnoreUnsupported</phrase>
								modifier: 
								<programlisting><emphasis role="bold">select</emphasis> Invoice 
	<emphasis role="bold">add</emphasis> { UnsupportedOperator(ID) TempID } 
		<emphasis role="bold">with</emphasis> { IgnoreUnsupported = "true" };</programlisting></para> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGStorageIntegrationArchitecture-Reconciliation"> 
				<title><indexterm> 
						  <primary>Reconciliation</primary> 
					 </indexterm><indexterm> 
						  <primary>Using Devices</primary> 
						  <secondary>Reconciliation</secondary> 
					 </indexterm>Reconciliation</title> 
				<para>Each system represented by a device has its own schema to
					 describe the structures and data available within that system. The structure
					 and contents of this schema will vary considerably with each system. For
					 example, for a simple file-based device, the schema may consist of a file list
					 and structural descriptors within the files themselves.</para> 
				<para>Regardless of how the system structure is exposed, the device
					 is responsible for transforming that structural information into terms that the
					 Dataphor Server can understand. The device is also responsible for translating
					 structural changes in the schema of the Dataphor Server to the target
					 system.</para> 
				<para>This synchronization of catalog between the Dataphor Server
					 and the target systems involved is called <emphasis>schema
					 reconciliation</emphasis>. Through this process, catalog information can be
					 imported from, exported to, or reconciled with the catalog of each individual
					 device.</para> 
				<para>Reconciliation is the process of synchronization of structure
					 between the Dataphor catalog and the device catalogs. The process can be
					 automatic, or user-initiated. Each device has two settings which determine how
					 and when reconciliation occurs, <emphasis>reconciliation mode</emphasis> and
					 <emphasis>reconciliation master</emphasis>.</para> 
				<para>These settings can be specified as part of the device
					 definition in the 
					 <phrase role="code"><emphasis role="bold">create
						  device</emphasis></phrase> statement, or they can be set using the 
					 <phrase role="code"><emphasis role="bold">alter
						  device</emphasis></phrase> statement. In addition, the reconciliation settings
					 can be changed or viewed by right-clicking on a device in the Dataphor Explorer
					 in Dataphoria.</para> 
				<para>The reconciliation mode can be either 
					 <phrase role="code">none</phrase>, or any combination of 
					 <phrase role="code">startup</phrase>, 
					 <phrase role="code">command</phrase>, and 
					 <phrase role="code">automatic</phrase>.</para> 
				<para>The reconciliation modes have the following meaning.</para> 
				<para> 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para>Startup indicates that the device should be
									 reconciled when the Dataphor Server starts, or when the device is initially
									 created.</para> 
						  </listitem> 
						  <listitem> 
								<para>Command indicates that Data Definition Language
									 (DDL) commands (create, alter, and drop statements) executed against the
									 Dataphor Server should be passed through to the device as well</para> 
						  </listitem> 
						  <listitem> 
								<para>Automatic indicates that tables should be
									 verified and updated appropriately as they are encountered in Data Manipulation
									 Language (DML) statements (select, insert, update, and delete statements)
									 executed against the Dataphor Server.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>In addition to these reconciliation modes, the reconciliation
					 process can be user-initiated with a call to the 
					 <phrase role="code">Reconcile</phrase> operator. This operator
					 takes a single 
					 <phrase role="code">System.Name</phrase> argument that is the
					 name of the device to be reconciled. The following example illustrates the use
					 of this operator: 
					 <programlisting>Reconcile(Name("MyDevice"));</programlisting></para> 
				<para>The reconciliation master can be 
					 <phrase role="code">server</phrase>, 
					 <phrase role="code">device</phrase>, or 
					 <phrase role="code">both</phrase>. Server indicates that the
					 Dataphor Server is designated as the master copy of the catalog. Device
					 indicates that the device is considered the master catalog, and both indicates
					 that the catalogs should be reconciled from both directions.</para> 
				<para>Reconciliation for a device proceeds as follows: 
					 <orderedlist> 
						  <listitem> 
								<para>If the reconciliation master setting is 
									 <phrase role="code">server</phrase> or 
									 <phrase role="code">both</phrase>, each table in
									 the DAE catalog is reconciled against the device. If a table does not exist in
									 the device, it is created; otherwise, it is updated to match the table
									 definition in the Dataphor Server.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the reconciliation master setting is 
									 <phrase role="code">device</phrase> or 
									 <phrase role="code">both</phrase>, each table in
									 the device catalog is reconciled against the Dataphor Server. If the table does
									 not exist in the Dataphor Server, it is created; otherwise, it is updated to
									 match the table definition in the device.</para> 
						  </listitem> 
					 </orderedlist></para> 
				<para>Beyond this basic process, each device may provide specific
					 reconciliation functionality.</para> 
				<para>Catalog reconciliation for a table proceeds as follows: 
					 <orderedlist> 
						  <listitem> 
								<para>If the Dataphor Server table is master, every
									 column in the definition of the table within the Dataphor Server must appear in
									 the definition of the table on the target system.</para> 
						  </listitem> 
						  <listitem> 
								<para>If the device table is master, every column in
									 the definition of the table on the target system must appear in the definition
									 of the table in the Dataphor Server.</para> 
						  </listitem> 
					 </orderedlist></para> 
				<para>Tables imported into the Dataphor Server by this process will
					 be named using the name of the table in the target system, namespace qualified
					 with the name of the device. For example, if a device called 
					 <phrase role="code">Pubs</phrase> is reconciled against the 
					 <phrase role="code">pubs</phrase> sample database that ships
					 with Microsoft SQL Server, the Dataphor Server will include a table called 
					 <phrase role="code">Pubs.authors</phrase>.</para> 
				<para>Data types for the columns of imported tables will be matched
					 as closely as possible to the system-provided types of the Dataphor Server. If
					 a data type cannot be reconciled, an appropriate error will be given.</para> 
				<sect2
				 id="DDGStorageIntegrationArchitecture-Reconciliation-StorageTags"> 
					 <title><indexterm> 
								<primary>Storage Tags</primary> 
						  </indexterm><indexterm> 
								<primary>Reconciliation</primary> 
								<secondary>Storage Tags</secondary> 
						  </indexterm>Storage Tags</title> 
					 <para>The following table lists the metadata tags that can be
						  used to control reconciliation and value translation in the SQL devices: 
						  <informaltable> 
								<tgroup cols="2"> 
									 <thead> 
										  <row> 
												<entry>Tag Name</entry> 
												<entry>Meaning</entry> 
										  </row> 
									 </thead> 
									 <tbody> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Name</phrase></entry> 
												<entry>Indicates that the object on which
													 it appears should be identified by the value of the tag when referenced within
													 the device.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Schema</phrase></entry> 
												<entry>Indicates that the object on which
													 it appears should be qualified by the value of the tag when referenced within
													 the device.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Length</phrase></entry> 
												<entry>Indicates the storage length for
													 translated domains. This tag is only used for the string types (<phrase
													 role="code">System.String</phrase> and like types) to indicate the length of
													 the VARCHAR data type to be used.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Precision</phrase></entry> 
												<entry>Indicates the storage precision for
													 exact numeric data in translated domains. This tag is only used for the 
													 <phrase
													  role="code">System.Decimal</phrase> type to indicate the precision of the
													 DECIMAL data type to be used.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Scale</phrase></entry> 
												<entry>Indicates the storage scale for
													 exact numeric data in translated domains. This tag is only used for the 
													 <phrase
													  role="code">System.Decimal</phrase> type to indicate the scale of the DECIMAL
													 data type to be used.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Deferred</phrase></entry> 
												<entry>Indicates that the values for the
													 column or domain on which it appears should be read entirely as overflow. If
													 the value of this tag is 
													 <phrase role="code">true</phrase>, the
													 system will not retrieve values from this column when the table is selected,
													 rather, the device will defer reading of the value for this column until it is
													 actually read by the client application. At that point, a separate stream is
													 used to read data for the column.</entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.Enforced</phrase></entry> 
												<entry>Indicates that the constraint on
													 which it appears is enforced by some target system, and need not be enforced by
													 the Dataphor Server. Setting this tag to 
													 <phrase role="code">true</phrase> for a
													 given constraint effectively disables enforcement of the constraint within the
													 Dataphor Server. 
													 <para>Note: This tag has been replaced
														  by 
														  <phrase
															role="code">DAE.Enforce</phrase>, with opposite semantics (i.e. a 
														  <phrase
															role="code">Storage.Enforced</phrase> tag of 
														  <phrase role="code">true</phrase>
														  is equivalent to a 
														  <phrase
															role="code">DAE.Enforced</phrase> tag of 
														  <phrase
															role="code">false</phrase>.</para></entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.IsClustered</phrase></entry> 
												<entry>Indicates that the index used to
													 support the key or order on which it appears should be built as the clustered
													 index, or physical ordering, for the table variable. The actual implementation
													 of clustered indexes varies depending on the target system. 
													 <para>Note: This tag has been replaced
														  by 
														  <phrase
															role="code">DAE.IsClustered</phrase>.</para></entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.IsSparse</phrase></entry> 
												<entry>Indicates that the key on which it
													 appears is a sparse key. Sparse keys enforce uniqueness only among the rows
													 which have values specified for all columns of the key. Dense keys allow only
													 one row to have no values for the columns of the key. Note that sparse keys
													 cannot be used as an addressability mechanism. 
													 <para>Note: This tag has been replaced
														  by 
														  <phrase
															role="code">DAE.IsSparse</phrase></para></entry> 
										  </row> 
										  <row> 
												<entry><phrase
													 role="code">Storage.ShouldReconcile</phrase></entry> 
												<entry>Indicates whether or not the column,
													 table, key, or order on which it appears should be reconciled with the target
													 system.</entry> 
										  </row> 
									 </tbody> 
								</tgroup> 
						  </informaltable></para> 
				</sect2> 
				<sect2
				 id="DDGStorageIntegrationArchitecture-Reconciliation-ReconciliationintheSQLDevices">
					 
					 <title><indexterm> 
								<primary>Reconciliation in the SQL Devices</primary> 
						  </indexterm><indexterm> 
								<primary>Reconciliation</primary> 
								<secondary>Reconciliation in the SQL
									 Devices</secondary> 
						  </indexterm>Reconciliation in the SQL Devices</title> 
					 <para>Each SQL device is responsible for describing the
						  contents of its system catalog to the Dataphor Server so that the
						  reconciliation process can take place.</para> 
					 <para>The SQL devices use three different statements to
						  describe the system catalog: the tables expression, the indexes expression, and
						  the foreign keys expression. Each of these expressions returns a result set
						  that lists the structural content of the system catalog. For a complete
						  description of each of these expressions, refer to the 
						  <phrase role="code">SQLDevice</phrase> library
						  reference.</para> 
					 <para>The 
						  <phrase role="code">AvailableTables</phrase> and 
						  <phrase role="code">AvailableReferences</phrase> operators
						  can be used to retrieve the set of tables or references currently available
						  from a given SQL device. For example, the following program listing shows the
						  output from the 
						  <phrase role="code">Shipping</phrase> device: 
						  <programlisting>Name                                                   StorageName                            
------------------------------------------------------ -------------------------------------- 
Sample.Shipping.Sample__Shipping__BidItem              Sample__Shipping__BidItem              
Sample.Shipping.Sample__Shipping__Contact              Sample__Shipping__Contact              
Sample.Shipping.Sample__Shipping__ContactAddress       Sample__Shipping__ContactAddress       
Sample.Shipping.Sample__Shipping__ContactAddressDuring Sample__Shipping__ContactAddressDuring 
Sample.Shipping.Sample__Shipping__ContactNameDuring    Sample__Shipping__ContactNameDuring    
Sample.Shipping.Sample__Shipping__ContactNotes         Sample__Shipping__ContactNotes         
Sample.Shipping.Sample__Shipping__ContactPhone         Sample__Shipping__ContactPhone         
Sample.Shipping.Sample__Shipping__ContactPhoneDuring   Sample__Shipping__ContactPhoneDuring   
Sample.Shipping.Sample__Shipping__Customer             Sample__Shipping__Customer             
Sample.Shipping.Sample__Shipping__CustomerPicture      Sample__Shipping__CustomerPicture      
Sample.Shipping.Sample__Shipping__Generators           Sample__Shipping__Generators           
Sample.Shipping.Sample__Shipping__Invoice              Sample__Shipping__Invoice              
Sample.Shipping.Sample__Shipping__InvoiceItem          Sample__Shipping__InvoiceItem          
Sample.Shipping.Sample__Shipping__InvoiceItemNumbers   Sample__Shipping__InvoiceItemNumbers   
Sample.Shipping.Sample__Shipping__InvoiceStatus        Sample__Shipping__InvoiceStatus        
Sample.Shipping.Sample__Shipping__ItemType             Sample__Shipping__ItemType             
Sample.Shipping.Sample__Shipping__Location             Sample__Shipping__Location             
Sample.Shipping.Sample__Shipping__LocationItem         Sample__Shipping__LocationItem         
Sample.Shipping.Sample__Shipping__PhoneType            Sample__Shipping__PhoneType            
Sample.Shipping.Sample__Shipping__PurchaseOrder        Sample__Shipping__PurchaseOrder        
Sample.Shipping.Sample__Shipping__SaleOrder            Sample__Shipping__SaleOrder            
Sample.Shipping.Sample__Shipping__State                Sample__Shipping__State                
Sample.Shipping.Sample__Shipping__Vendor               Sample__Shipping__Vendor               
Sample.Shipping.Sample__Shipping__VendorItemType       Sample__Shipping__VendorItemType       
Sample.Shipping.Sample__Shipping__ZipCode              Sample__Shipping__ZipCode              </programlisting></para> 
					 <para>In addition to these result sets, the 
						  <phrase role="code">Reconcile</phrase> operator itself, if
						  used in a select statement, will return a list of the errors that occurred
						  during the reconciliation process, if any.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGDevices"> 
		  <title><indexterm> 
					 <primary>Devices</primary> 
					 <secondary>Physical Realization And</secondary> 
				</indexterm>Devices</title> 
		  <para>The first step to be taken in mapping a logical application
				schema onto a target system is to construct the device in the Dataphor Server
				that will model the target system.</para> 
		  <para>This chapter discusses the various devices available for the
				Dataphor platform, and how they can be used to provide persistence for Dataphor
				applications.</para> 
		  <sect1 id="DDGDevices-AvailableDevices"> 
				<title><indexterm> 
						  <primary>Available Devices</primary> 
					 </indexterm><indexterm> 
						  <primary>Devices</primary> 
						  <secondary>Available Devices</secondary> 
					 </indexterm>Available Devices</title> 
				<para>The Dataphor Server provides several devices as shown in the
					 following list:</para> 
				<para> 
					 <itemizedlist mark="bullet"> 
						  <listitem> 
								<para>Memory Device</para> 
								<para>The memory device provides in-memory storage.
									 Data stored in this device is not persisted to disk.</para> 
						  </listitem> 
						  <listitem> 
								<para>Simple Device</para> 
								<para>The simple device provides basic persistence for
									 tables in the Dataphor Server. Although the device is transactional,
									 concurrency is enforced with exclusive table access. As a result, this device
									 is intended for single-user applications with low data volume.</para> 
						  </listitem> 
						  <listitem> 
								<para>Microsoft SQL Server</para> 
								<para>This device provides full integration with
									 Microsoft SQL Server.</para> 
						  </listitem> 
						  <listitem> 
								<para>Oracle</para> 
								<para>This device provides full integration with the
									 Oracle database system.</para> 
						  </listitem> 
						  <listitem> 
								<para>DB2</para> 
								<para>This device provides full integration with the
									 IBM DB2 Universal DBMS. It is also capable of providing full integration with
									 the IBM DB2/400 DBMS, by setting the 
									 <phrase role="code">Product</phrase> attribute of
									 the device.</para> 
						  </listitem> 
						  <listitem> 
								<para>Generic SQL</para> 
								<para>This device provides a starting point for
									 building Device interfaces to other SQL based database systems.</para> 
						  </listitem> 
					 </itemizedlist></para> 
				<para>Additionally, developers can provide custom devices to enable
					 access to any data store. Each device must provide at least forward only cursor
					 access to the data. If the device is updatable, it must also be capable of
					 executing update statements, or of accepting row-level update commands.</para> 
				<para>As more devices are built, they will be included with the
					 product. Check the Alphora website at www.alphora.com for the latest
					 information on available devices.</para> 
				<para>For more information on building custom devices, refer to the
					 Dataphor Device Development Kit, available from the Alphora website.</para> 
				<sect2 id="DDGDevices-AvailableDevices-MemoryDevice"> 
					 <title><indexterm> 
								<primary>Memory Device</primary> 
						  </indexterm><indexterm> 
								<primary>Available Devices</primary> 
								<secondary>Memory Device</secondary> 
						  </indexterm>Memory Device</title> 
					 <para>The memory device provides a mechanism for storing data
						  in-memory. Storage is not persistent (meaning that it will not survive a
						  restart of the Dataphor Server), but the device does provide full transactional
						  support, and minimal concurrency protection.</para> 
					 <para>The 
						  <phrase role="code">Temp</phrase> system device is a memory
						  device used by the internal query processor to materialize intermediate
						  results, and store process- and session-scoped table variables. The 
						  <phrase role="code">Storage.Scope</phrase> tag can be used
						  to specify the scope for the storage of a table variable.</para> 
					 <para>Regardless of the scope of the table variable, the
						  definition of the type and structure of the table variable is the same for the
						  all scopes. However, the contents of the table variable will vary based on the
						  scope. For database-scoped table variables (the default), the same storage is
						  provided for all sessions and processes. For session-scoped table variables, a
						  different storage space is provided for each session, and similarly for
						  process-scoped table variables, a different storage space is provided for each
						  process.</para>
					 <para>Session- and process-scoped table variables are useful
						  for providing data storage that may be unique to a particular user-session or
						  form. For example, session-scoped table variables can be used to store session
						  context such as shopping cart information, while process-scoped table variables
						  can be used to store form-specific information such as the current contents of
						  a filter.</para>
					 <para>In addition to these tasks, the memory device is ideally
						  suited for prototyping and initial development. The memory device requires no
						  scalar type mappings, and will support any table variable that can be described
						  in D4, even when user-defined types are involved.</para> 
					 <para>The memory device does not support any operation other
						  than base table retrieval and ordering, so no operator mappings are required.
						  Note that this does not mean that queries involving operators other than
						  retrieval and ordering cannot be evaluated, it simply means that the query
						  processor will perform the operations, not the device.</para> 
					 <para>For more information on using the memory device, refer to
						  the 
						  <ulink type="olinka" url="DRSystemLibrary.html">System
								Library Reference</ulink>.</para> 
				</sect2> 
				<sect2 id="DDGDevices-AvailableDevices-SimpleDevice"> 
					 <title><indexterm> 
								<primary>Simple Device</primary> 
						  </indexterm><indexterm> 
								<primary>Available Devices</primary> 
								<secondary>Simple Device</secondary> 
						  </indexterm>Simple Device</title> 
					 <para>The simple device is a memory device that has been
						  extended to provide basic persistence using a file for each table stored in the
						  device. The directory used can be specified as part of the device definition,
						  but defaults to the 
						  <phrase role="code">Data</phrase> subdirectory of the
						  Dataphor Server runtime directory.</para> 
					 <para>As with the memory device, the simple device does support
						  transactions, but concurrency is implemented via exclusive table-level locks,
						  so the device is not intended to support multi-user applications.</para> 
					 <para>The simple device requires no scalar type mappings, and
						  will support any table variable that can be described in D4, even when
						  user-defined types are involved.</para> 
					 <para>The simple device does not support any operation other
						  than base table retrieval and ordering, so no operator mappings are required.
						  Note that this does not mean that queries involving operators other than
						  retrieval and ordering cannot be evaluated, it simply means that the query
						  processor will perform the operations, not the device.</para> 
					 <para>For more information on using the simple device, refer to
						  the 
						  <ulink type="olinka"
							url="DRSimpleDeviceLibrary.html">Simple Device Library
								Reference</ulink>.</para> 
				</sect2> 
				<sect2 id="DDGDevices-AvailableDevices-SQLDevices"> 
					 <title><indexterm> 
								<primary>SQL Devices</primary> 
						  </indexterm>SQL Devices</title> 
					 <para>The Dataphor toolset includes several devices designed to
						  support various commercial SQL-based DBMSs. The common aspects of supporting
						  these systems are handled by the base SQL device, introduced in the 
						  <phrase role="code">SQLDevice</phrase> library. The base
						  SQL device does not contain any actual devices, but provides services and
						  host-implementations that other devices utilize.</para> 
					 <para>Note that while this device could be said to support the
						  ANSI standard version of SQL, this is not entirely correct. No system
						  implements the standard completely, and each system deviates from the standard
						  enough to prevent the construction of a single device capable of supporting all
						  SQL systems. As a result, the SQL that is common among the different systems is
						  only the portion that they all implement the same way. For this reason, we
						  choose to call the SQL support implemented by the base device <emphasis>Common
						  SQL</emphasis>.</para> 
					 <para>Common SQL support is provided by extending the
						  infrastructure of the Dataphor Server to support the different aspects of an
						  SQL-based DBMS. This involves extending language support, providing data type
						  and language translation services, and providing a connectivity layer which the
						  Dataphor Server can use to communicate with these systems. The actual base SQL
						  device then coordinates the use of these layers to provide the framework for
						  supporting specific SQL-based systems.</para> 
					 <sect3 id="DDGSQLLanguage"> 
						  <title><indexterm> 
									 <primary>SQL Language</primary> 
								</indexterm>SQL Language</title> 
						  <para>In order to understand how the SQL devices provide
								translation for the D4 statements, it is important to understand how the
								Dataphor Server transforms commands written in D4 into query plans ready for
								execution within the D4 processor.</para> 
						  <para>This process is generally called compilation, and
								within the Dataphor Server, it is comprised of four basic steps: 
								<orderedlist> 
									 <listitem> 
										  <para>Lexical Analysis (also called
												<emphasis>lexing</emphasis>)</para> 
									 </listitem> 
									 <listitem> 
										  <para>Syntactic Analysis (also called
												<emphasis>parsing</emphasis>)</para> 
									 </listitem> 
									 <listitem> 
										  <para>Semantic Analysis (also called
												<emphasis>compiling</emphasis>)</para> 
									 </listitem> 
									 <listitem> 
										  <para>Access Path Determination (also called
												<emphasis>binding</emphasis>)</para> 
									 </listitem> 
								</orderedlist></para> 
						  <para>The first step, lexical analysis, is concerned with
								transforming the statements given by the user into a sequence of
								<emphasis>tokens</emphasis> that can be easily consumed by the next phase. This
								process is concerned with recognizing keywords and symbols of the
								language.</para> 
						  <para>The second step, syntactic analysis, is concerned
								with verifying that the syntax, or structure, of the statement is a valid
								construct of the language. The product of this step is called
								<emphasis>abstract syntax tree</emphasis>, and is a conceptual representation
								of the statement that can be easily consumed by the next phase.</para> 
						  <para>The third step, semantic analysis, is concerned with
								verifying that all the identifiers and operator invocations called for in the
								statement are valid. This phase ensures that identifiers within the statement
								refer to known objects in the catalog, and that the arguments to each operator
								invocation are of the appropriate type. The product of this step is an
								<emphasis>execution plan</emphasis>, which must then be
								<emphasis>bound</emphasis> to actual data access paths in order to be
								executed.</para> 
						  <para>The fourth step, access path determination, is when
								the device binding actually occurs. The chunking algorithm described above is
								used to determine which devices are involved in a particular query, and where
								the processing boundaries will be placed. It is important to note that each
								device is actually a compiler in and of itself, producing an execution plan for
								use in generating the statement to be given to the target system.</para> 
						  <para>The process of preparing a given statement or
								expression branch for execution on a target system is actually the reverse of
								the first three steps outlined above. The device analyzes the execution plan
								prepared by the Dataphor Server, and produces an abstract syntax tree
								representing an SQL statement to perform the required operation. This
								representation is then given to an <emphasis>emitter</emphasis> which produces
								a string ready to be passed to the target system.</para> 
						  <para>The elements of an abstract syntax tree are described
								using a <emphasis>document object model</emphasis>. This model provides a
								hierarchical representation of the statement to be executed. Each language has
								a unique document object model containing the appropriate elements for the
								representation of that language. The SQL device introduces the common elements
								of the document object model required for representing Common SQL, and each
								specific SQL device introduces the variants necessary to represent the
								dialectic differences for each target system.</para> 
						  <para>Each device also introduces an emitter for use in
								transforming abstract syntax trees into actual strings of the appropriate
								dialect. In this way, each device is capable of precisely describing the
								specific dialect of SQL that is used by a given system, both in terms of the
								semantic and syntactic differences from Common SQL.</para> 
					 </sect3> 
					 <sect3 id="DDGSQLConnectivity"> 
						  <title><indexterm> 
									 <primary>SQL Connectivity</primary> 
								</indexterm>SQL Connectivity</title> 
						  <para>Common SQL support introduces a connectivity layer
								for handling communication with different SQL-based DBMSs. This layer
								abstractly describes the behaviors required by the Common SQL device, and its
								descendants. Specific implementations of connectivity layers are then provided
								to communicate with the different data access methodologies available for
								existing systems.</para> 
						  <para>The Dataphor toolset provides several implementations
								of this connectivity layer. These wrap common data access technologies, and
								expose them to the SQL devices. In addition, new data access technologies can
								easily be exposed by providing an SQL Connectivity implementation. The
								following table lists the available implementations as of the preparation of
								this document. More may be made available in the future as necessary. 
								<informaltable> 
									 <tgroup cols="2"> 
										  <thead> 
												<row> 
													 <entry>Data Access Technology</entry> 
													 <entry>SQL Connectivity Connection
														  Class</entry> 
												</row> 
										  </thead> 
										  <tbody> 
												<row> 
													 <entry>ADO</entry> 
													 <entry><phrase
														  role="code">ADOConnection.ADOConnection</phrase></entry> 
												</row> 
												<row> 
													 <entry>ADO.NET Provider for Microsoft
														  SQL Server</entry> 
													 <entry><phrase
														  role="code">SQLDevice.MSSQLConnection</phrase></entry> 
												</row> 
												<row> 
													 <entry>ADO.NET Provider for OLE
														  DB</entry> 
													 <entry><phrase
														  role="code">SQLDevice.OLEDBConnection</phrase></entry> 
												</row> 
												<row> 
													 <entry>ADO.NET Provider for
														  ODBC</entry> 
													 <entry><phrase
														  role="code">ODBCConnection.ODBCConnection</phrase></entry> 
												</row> 
												<row> 
													 <entry>Microsoft ADO.NET Provider for
														  Oracle</entry> 
													 <entry><phrase
														  role="code">MSOracleConnection.OracleConnection</phrase></entry> 
												</row> 
												<row> 
													 <entry>IBM ADO.NET Data Provider for
														  DB2</entry> 
													 <entry><phrase
														  role="code">DB2Connection.DB2Connection</phrase></entry> 
												</row> 
										  </tbody> 
									 </tgroup> 
								</informaltable></para> 
						  <para>The connectivity layer for the base SQL device
								handles most of the tasks involved in connecting to the target systems. These
								tasks include basic connectivity, transaction coordination, and connection
								management.</para> 
						  <para>For more information on a specific connectivity
								implementation, refer to the reference documentation for the library containing
								the implementation.</para> 
						  <sect4 id="DDGP2BasicConnectivity"> 
								<title><indexterm> 
										  <primary>Basic Connectivity</primary> 
									 </indexterm>Basic Connectivity</title> 
								<para>Basic communications with the target system are
									 handled by an SQL connectivity implementation. The connectivity implementation
									 to be used is specified by the value of the 
									 <phrase role="code">ConnectionClass</phrase>
									 attribute, which specifies the registered class to be used. Once a connectivity
									 implementation has been selected, the device must connect to the target system
									 using an appropriate set of connection parameters.</para> 
								<para>All SQL-based connectivity implementations use
									 the concept of a <emphasis>connection string</emphasis> to specify connection
									 information. A connection string is a set of name-value pairs called
									 <emphasis>connection parameters</emphasis>. Each connection parameter specifies
									 some aspect of connecting to the target system such as 
									 <phrase role="code">ServerName</phrase> or 
									 <phrase role="code">UserID</phrase>. Each device
									 registers a set of <emphasis>connection string builder</emphasis> classes that
									 can be used to build connection strings for the device based on the set of
									 connection parameters available.</para> 
								<para>Each connectivity implementation and device
									 combination uses some connection string builder to build the appropriate
									 connection string. By default, each device specifies the correct connectivity
									 implementation and connection string builder. If a custom connectivity
									 implementation or connection string builder is desired, they can be specified
									 using the 
									 <phrase role="code">ConnectionClass</phrase> and 
									 <phrase
									  role="code">ConnectionStringBuilderClass</phrase> attributes of the device
									 class definition, respectively.</para> 
								<para>Each SQL device also provides an attribute called
									 
									 <phrase role="code">ConnectionParameters</phrase>
									 which can be used to specify additional configuration parameters for the
									 device. Device users may also specify configuration parameters for the device.
									 All these parameters are used by the connection string builder to generate the
									 appropriate connection string for the target system.</para> 
								<para>The following procedure is used to gather all the
									 name-value pairs to be used to construct the connection string:</para> 
								<procedure> 
									 <step> 
										  <para>The device adds any device-specific
												parameters such as 
												<phrase role="code">ServerName</phrase> or 
												<phrase
												 role="code">DatabaseName</phrase>.</para> 
									 </step> 
									 <step> 
										  <para>The connection string builder maps any
												connection parameters to new names, for example, the parameter 
												<phrase role="code">ServerName</phrase> may
												be mapped to the 
												<phrase role="code">Data Source</phrase>
												parameter for an 
												<phrase
												 role="code">ODBCConnection</phrase>.</para> 
									 </step> 
									 <step> 
										  <para>Any connection parameters specified in
												the 
												<phrase
												 role="code">ConnectionParameters</phrase> attribute are added.</para> 
									 </step> 
									 <step> 
										  <para>Any connection parameters specified on
												the device user mapping are added.</para> 
									 </step> 
								</procedure> 
								<para>The resulting set of connection parameters is
									 used to construct a semi-colon delimited list of 
									 <phrase role="code">name=value</phrase> pairs, and
									 this becomes the connection string for the any connections to the target
									 system.</para> 
						  </sect4> 
						  <sect4 id="DDGP2ConnectionMultiplexing"> 
								<title><indexterm> 
										  <primary>Connection Multiplexing</primary> 
									 </indexterm>Connection Multiplexing</title> 
								<para>Transactions in the Dataphor Server are
									 associated with a running process. Because of this, device sessions are also
									 associated with a given process. If a transaction is in progress in the
									 Dataphor Server, a transaction must be in progress with the target system as
									 well. This is known as <emphasis>transaction coordination</emphasis> and is
									 managed by the process from the Dataphor Server.</para> 
								<para>In order for this transaction coordination to
									 work, the Dataphor Server requires that a device session be capable of
									 responding to transactional requests, even if cursors are open against the
									 device. In addition, the Dataphor Server requires that the device session be
									 able to open multiple cursors within the same transaction. For SQL-based
									 systems, these requirements pose a non-trivial implementation problem, as
									 transactions are usually restricted to the communications session, and
									 transactions cannot be started and stopped independent of cursor lifetimes. The
									 base SQL device solves these problems with a mechanism called
									 <emphasis>connection multiplexing</emphasis>.</para> 
								<para>Connection multiplexing is the process by which a
									 pool (possibly one) of connections to a given target system is shared among
									 multiple task requests against the device session. The device session manages
									 connection multiplexing using two pools of connections: a
									 <emphasis>browse</emphasis> pool, and an <emphasis>execute</emphasis>
									 pool.</para> 
								<para>The browse pool is used for connections which are
									 known to be readonly and have an isolation level of browse. All actions
									 performed on connections in the browse pool are done within a browse
									 transaction which allows the read of uncommitted data. Because the connections
									 in the browse pool do not have to participate in the same transaction, new
									 browse connections can be added as needed.</para> 
								<para>The execute pool is used for connections which
									 may update data, or have an isolation level higher than browse. All connections
									 in the execute pool participate in the same transaction against the target
									 system. If the target system supports multiple connections in a single
									 transaction, the execute pool can contain multiple connections, otherwise the
									 execute pool will only contain a single connection.</para> 
								<para>As requests are made against the device session,
									 they are either readonly browse requests, in which case the browse pool is used
									 to process the request, or they are possibly write requests which must be
									 processed by the execute pool. If all connections in the execute pool are
									 currently busy, the first connection in the pool is released, and then moved to
									 the back of the pool. The released connection can then be used to service the
									 request.</para> 
								<para>When connections are released, the cursor is
									 still managed by the Dataphor Server, which is responsible for collecting
									 enough state to resume the operation from the point where the connection was
									 released. The device cursor maintains a working buffer of the data being read
									 from any given connection. When the connection is released, the device cursor
									 will read from the working buffer until more data must be fetched. At this
									 point, the device cursor requests a connection from the device session, and
									 begins fetching data from the first row after the last row in its working
									 buffer.</para> 
								<para>In this way, a single transactional connection to
									 the target system can be utilized by multiple requests coming in from the
									 Dataphor Server. The value of the 
									 <phrase role="code">ConnectionBufferSize</phrase>
									 attribute of the device definition determines the number of rows to keep in the
									 working buffer of each device cursor.</para> 
						  </sect4> 
					 </sect3> 
				</sect2> 
		  </sect1> 
		  <sect1 id="DDGDevices-CreatingtheDevice"> 
				<title><indexterm> 
						  <primary>Creating the Device</primary> 
					 </indexterm><indexterm> 
						  <primary>Devices</primary> 
						  <secondary>Creating the Device</secondary> 
					 </indexterm>Creating the Device</title> 
				<para>The 
					 <phrase role="code">Shipping</phrase> application is built to
					 use the 
					 <phrase role="code">MSSQLDevice</phrase>. The following
					 statement illustrates the creation of this device and the user mappings
					 associated with it: 
					 <programlisting><emphasis role="bold">create device</emphasis> Shipping
	<emphasis role="bold">reconciliation</emphasis> { <emphasis role="bold">mode</emphasis> = { command }, <emphasis role="bold">master</emphasis> = <emphasis role="bold">device</emphasis> }
	<emphasis role="bold">class</emphasis> "MSSQLDevice.MSSQLDevice"
		<emphasis role="bold">attributes</emphasis>
		{
			"ServerName" = ".",
			"DatabaseName" = "Shipping",
			"UseQualifiedNames" = "true"
		};

CreateDeviceUser("Admin", Name("Shipping"), "sa", "");
CreateDeviceUser("System", Name("Shipping"), "sa", "");</programlisting></para> 
				<para>This script creates the 
					 <phrase role="code">Shipping</phrase> device, and the device
					 user mappings for the 
					 <phrase role="code">System</phrase> and 
					 <phrase role="code">Admin</phrase> users. The 
					 <phrase role="code">System</phrase> user mapping is required to
					 enable the Dataphor Server system process to log into the device during startup
					 and shutdown processing. The 
					 <phrase role="code">Admin</phrase> user mapping is required to
					 allow the 
					 <phrase role="code">Admin</phrase> user to access the data in
					 the device. In addition to credentials, device user mappings can be used to
					 specify additional connection parameters that should only be used by a
					 particular user.</para> 
				<para>Note that the authentication information for the device can
					 also be specified using the 
					 <phrase role="code">UserID</phrase> and 
					 <phrase role="code">Password</phrase> attributes of the device
					 class definition.</para> 
				<sect2 id="DDGDevices-CreatingtheDevice-DefaultDevice"> 
					 <title><indexterm> 
								<primary>Default Device</primary> 
						  </indexterm><indexterm> 
								<primary>Creating the Device</primary> 
								<secondary>Default Device</secondary> 
						  </indexterm>Default Device</title> 
					 <para>In addition to creating the 
						  <phrase role="code">Shipping</phrase> device, the 
						  <phrase role="code">Shipping</phrase> library specifies
						  that the device is to be used as the default device for the library. This is
						  specified on the library edit form, or by invoking the 
						  <phrase role="code">SetDefaultDeviceName</phrase>
						  operator.</para> 
					 <para>For a given session, the default device is the first
						  unambiguously specified default device name encountered in a breadth first
						  traversal of the library dependency graph above the current library for the
						  session.</para> 
					 <para>Whenever a base table variable is created without
						  specifying a device, the default device name is used to determine where the
						  table should be stored. The default device name for the 
						  <phrase role="code">System</phrase> library is 
						  <phrase role="code">Temp</phrase>, meaning that if no
						  default device name is specified anywhere in the dependency graph for the
						  current library, the 
						  <phrase role="code">Temp</phrase> device will be the
						  ultimate default.</para> 
					 <para>The default device is also used to determine which device
						  should be checked when an automatic reconciliation is triggered. If a given
						  variable reference is not found within the catalog, and there is a default
						  device specified for the current session, and that device has automatic
						  reconciliation turned on, then a reconciliation with the unknown identifier
						  will be attempted. If a table is found in that device matching the identifier,
						  it is reconciled into the Dataphor Server catalog.</para> 
					 <para>By using default devices for libraries, table definitions
						  can be built independently of the device definitions in which they are stored.
						  This allows libraries to be re-created in different devices simply by changing
						  the default device name of the library 
						  <footnote> 
								<para>Obviously changing the default device name of a
									 library will have no effect on existing table definitions. The new setting will
									 only be used for subsequent create table statements.</para> 
						  </footnote></para> 
				</sect2> 
				<sect2 id="DDGDevices-CreatingtheDevice-ReconciliationMode"> 
					 <title><indexterm> 
								<primary>Reconciliation Mode</primary> 
						  </indexterm><indexterm> 
								<primary>Creating the Device</primary> 
								<secondary>Reconciliation Mode</secondary> 
						  </indexterm>Reconciliation Mode</title> 
					 <para>In the 
						  <phrase role="code">Shipping</phrase> application create
						  device statement, the reconciliation mode for the device is set to 
						  <phrase role="code">command</phrase>. This means that any
						  Data Definition Language (DDL) statements (<phrase role="code"><emphasis
								role="bold">create</emphasis></phrase>, 
						  <phrase role="code"><emphasis
								role="bold">alter</emphasis></phrase>, or 
						  <phrase role="code"><emphasis
								role="bold">drop</emphasis></phrase> statements) involving the device will be
						  translated and executed against the target system.</para> 
					 <para>The reconciliation mode can be altered at any time. By
						  setting the reconciliation mode to 
						  <phrase role="code">none</phrase>, all subsequent DDL
						  statements involving the device will have no effect on the target
						  system.</para> 
					 <para>Once the library has been registered and all tables have
						  been created on the target system, the reconciliation mode can be turned off,
						  and the library can be unregistered and re-registered without affecting the
						  tables, or data, in the target system. This can be useful in the later stages
						  of development when no base table variable changes are being made. Rather than
						  attempting to reconcile a given change using 
						  <phrase role="code"><emphasis
								role="bold">alter</emphasis></phrase> statements against the schema, the entire
						  library can be re-created without affecting the target system.</para> 
					 <para>Note also that while loading and unloading (during
						  Startup or Shutdown, or in response to a 
						  <phrase role="code">LoadLibrary</phrase> or 
						  <phrase role="code">UnloadLibrary</phrase> call), all
						  devices will ignore DDL commands, regardless of their respective reconciliation
						  settings.</para> 
				</sect2> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGScalarTypeMapping"> 
		  <title><indexterm> 
					 <primary>Scalar Type Mapping</primary> 
				</indexterm><indexterm> 
					 <primary>Physical Realization</primary> 
					 <secondary>Scalar Type Mapping</secondary> 
				</indexterm><indexterm> 
					 <primary>Acceptable Range</primary> 
				</indexterm>Scalar Type Mapping</title> 
		  <para>In order to allow values of types defined in the logical model,
				the SIA incorporates the concept of a <emphasis>scalar type map</emphasis> that
				provides value translation to and from the native representation of a scalar
				value within the Dataphor Server, and the device representation of that value
				in a given target system.</para> 
		  <para>Each device has a set of type maps that indicate which D4 types
				are supported by the device. For the SQL-based devices that ship with the
				Dataphor product, the system-defined types such as 
				<phrase role="code">System.Integer</phrase> and 
				<phrase role="code">System.String</phrase> are already mapped as
				part of the creation of the device.</para> 
		  <para>In addition, the type mapping for user-defined types with a
				system-provided native representation based on a mapped type is automatically
				provided as necessary. As such, for most applications, type mapping can be
				largely ignored. However, in some cases, user-defined types will have
				host-implemented native representations, requiring a host-implemented type map
				as well. This chapter discusses how scalar type maps work, and what is involved
				in their creation and usage.</para> 
		  <para>It should be noted that there are some gray areas with respect to
				type mapping due to the extremely diverse nature of representation of values
				within different systems. A scalar type map is really a mathematical function
				that relates the values in one domain to the values in another. In a perfect
				world, the domains on both sides would have the same number of values, and
				there would be a unique one-to-one correlation between the domains.</para> 
		  <para>In reality, the domains often have differing sets of values, and
				the task of the scalar type map designer is to find the <emphasis>best
				fit</emphasis>. For some types, such as a four-byte integer, the type map is
				uniquely one-to-one. For other types, such as 
				<phrase role="code">DateTime</phrase>, the range of possible values
				is so dramatically different from one system to the next that a perfect fit
				becomes impossible. In these scenarios, the notion of <emphasis>acceptable
				range</emphasis> is used to attempt to guarantee functionality under a given
				set of values. In the case of 
				<phrase role="code">DateTime</phrase>, this range is from January
				1, 1900 00:00:00.0, to December 31, 2100 23:23:59.0, accurate to the
				second.</para> 
		  <para>Of course this range is well below the actual range of a 
				<phrase role="code">DateTime</phrase> value within the Dataphor
				Server, but it represents a kind of least common denominator among all target
				systems, and is based on the assumption that all conceivable systems will at
				least be able to provide support for this range of values. What acceptable
				range really defines is the minimum level of support required for a given
				target system. Of course, some systems provide much larger ranges for date time
				values, and the notion of acceptable range does <emphasis>not</emphasis> limit
				the set of values that can be represented on a given target system. It merely
				specifies a target level of support in order to guarantee functionality across
				devices.</para> 
		  <para>Where appropriate, the acceptable ranges for various types are
				documented with the type in the various library references.</para> 
		  <sect1 id="DDGScalarTypeMapping-DeviceRepresentations"> 
				<title><indexterm> 
						  <primary>Device Representations</primary> 
					 </indexterm><indexterm> 
						  <primary>Scalar Type Mapping</primary> 
						  <secondary>Device Representations</secondary> 
					 </indexterm>Device Representations</title> 
				<para>The device representation for a scalar type is the
					 representation of values of that type within the target system. Scalar type
					 maps provide translation services to and from the native representation in the
					 Dataphor Server and this device representation.</para> 
				<para>Like the native representation, the device representation is
					 expressed in terms of a .NET CLR type. This representation is used when
					 communicating through the CLI of the target system.</para> 
				<para>For the SQL-based devices, type maps for the system-defined
					 types have already been provided. The following table lists the base SQL type
					 maps provided as registered classes in the 
					 <phrase role="code">SQLDevice</phrase> library: 
					 <informaltable> 
						  <tgroup cols="3"> 
								<thead> 
									 <row> 
										  <entry>D4 Data Type</entry> 
										  <entry>Common SQL Data Type</entry> 
										  <entry>Translation Class</entry> 
									 </row> 
								</thead> 
								<tbody> 
									 <row> 
										  <entry><phrase
												role="code">System.Boolean</phrase></entry> 
										  <entry>INTEGER (0 or 1)</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLBoolean</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Byte</phrase></entry> 
										  <entry>SMALLINT</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLByte</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Short</phrase></entry> 
										  <entry>SMALLINT</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLShort</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Integer</phrase></entry> 
										  <entry>INTEGER</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLInteger</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Long</phrase></entry> 
										  <entry>BIGINT</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLLong</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Decimal</phrase></entry> 
										  <entry>DECIMAL(<phrase role="code">P</phrase>, 
												<phrase role="code">S</phrase>)</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLDecimal</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.DateTime</phrase></entry> 
										  <entry>DATETIME</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLDateTime</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Date</phrase></entry> 
										  <entry>DATE</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLDate</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Time</phrase></entry> 
										  <entry>TIME</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLTime</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.TimeSpan</phrase></entry> 
										  <entry>BIGINT</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLTimeSpan</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Money</phrase></entry> 
										  <entry>DECIMAL(28, 8)</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLMoney</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Guid</phrase></entry> 
										  <entry>CHAR(24)</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLGuid</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.String</phrase></entry> 
										  <entry>VARCHAR(<phrase
												role="code">L</phrase>)</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLString</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLDevice.SQLText</phrase></entry> 
										  <entry>CLOB</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLText</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Binary</phrase></entry> 
										  <entry>BLOB</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLBinary</phrase></entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">System.Graphic</phrase></entry> 
										  <entry>BLOB</entry> 
										  <entry><phrase
												role="code">SQLDevice.SQLGraphic</phrase></entry> 
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
		  </sect1> 
		  <sect1 id="DDGScalarTypeMapping-SimpleTypeMaps"> 
				<title><indexterm> 
						  <primary>Simple Type Maps</primary> 
					 </indexterm><indexterm> 
						  <primary>Scalar Type Mapping</primary> 
						  <secondary>Simple Type Maps</secondary> 
					 </indexterm>Simple Type Maps</title> 
				<para>For simple scalar types, the Dataphor Server can usually
					 provide an appropriate type mapping automatically. When a table variable
					 containing a column of an unmapped scalar type, the Dataphor Server will search
					 for the type map of the native representation of the type. If one is found, the
					 translation handler for that type is used to construct the type mapping for the
					 new type.</para> 
				<para>For example, consider the following create table statement: 
					 <programlisting><emphasis role="bold">create table</emphasis> Invoice
{
	ID : InvoiceID { <emphasis role="bold">default</emphasis> InvoiceID(GetNextGenerator("Shipping.Invoice.ID")) } 
		<emphasis role="bold">tags</emphasis> { Frontend.ReadOnly = "true" },
	Location_ID : LocationID,
	User_ID : UserID { <emphasis role="bold">default</emphasis> System.UserID() },
	Date : Date { <emphasis role="bold">default</emphasis> Date() },
	Status_ID : InvoiceStatusID { <emphasis role="bold">default</emphasis> InvoiceStatusID("NEW") },
	<emphasis role="bold">key</emphasis> { ID }
};</programlisting></para> 
				<para>When the Dataphor Server attempts to map the table into the 
					 <phrase role="code">Shipping</phrase> device, if the 
					 <phrase role="code">InvoiceID</phrase> type map did not exist,
					 the Dataphor Server would provide a map based on the 
					 <phrase role="code">System.Integer</phrase> type mapping
					 already present, because 
					 <phrase role="code">InvoiceID</phrase> is defined 
					 <phrase role="code"><emphasis
						  role="bold">like</emphasis></phrase> 
					 <phrase role="code">System.Integer</phrase>.</para> 
				<para>Similarly, in the following type map statement, the Dataphor
					 Server determines the translation handler to be used based on the definition of
					 the scalar type: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping { <emphasis role="bold">create type</emphasis> InvoiceID };</programlisting></para> 
				<para>For the 
					 <phrase role="code">InvoiceID</phrase> type, the type map is
					 fairly straightforward because the type specifier on the target system has no
					 parameters. In contrast, string-like types use the 
					 <phrase role="code">VARCHAR</phrase> type on the target
					 systems, and have the potential to specify a length parameter as part of the
					 type specifier. This length parameter is taken from the value of the 
					 <phrase role="code">Storage.Length</phrase> tag.</para> 
				<para>The 
					 <phrase role="code">Storage.Length</phrase> tag is taken from
					 the metadata associated with the scalar type map. If the tag is not found on
					 the type map, it is taken from the metadata associated with the scalar type
					 itself. Note that when the Dataphor Server constructs a type map automatically,
					 it does not infer metadata from the source type map. For example, consider the
					 following type definition: 
					 <programlisting><emphasis role="bold">create type</emphasis> Phone <emphasis role="bold">like</emphasis> String
{
	<emphasis role="bold">constraint</emphasis> LengthValid (Length(<emphasis role="bold">value</emphasis>) &lt;= 20)
}
	<emphasis role="bold">tags</emphasis> { Frontend.Title = "Phone #", Frontend.Width = "15" }
	<emphasis role="bold">static tags</emphasis> { Storage.Length = "20" };</programlisting></para> 
				<para>Even though the 
					 <phrase role="code">System.String</phrase> type specifies a 
					 <phrase role="code">Storage.Length</phrase> tag, the value of
					 that tag is overridden by the 
					 <phrase role="code">Phone</phrase> type itself. When the
					 Dataphor Server constructs a scalar type map for the 
					 <phrase role="code">Phone</phrase> type, it will be based on
					 the translation handler used for the 
					 <phrase role="code">System.String</phrase> type, but that
					 translation handler will use the 
					 <phrase role="code">Storage.Length</phrase> tag from the 
					 <phrase role="code">Phone</phrase> type definition.</para> 
				<para>In addition, the 
					 <phrase role="code">Storage.Length</phrase> tag can be
					 specified on the type map directly. For example: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping { <emphasis role="bold">create type</emphasis> Phone <emphasis role="bold">tags</emphasis> { Storage.Length = "20" } };</programlisting></para> 
				<para>The 
					 <phrase role="code">Storage.Length</phrase> tag specified here
					 will effectively override the 
					 <phrase role="code">Storage.Length</phrase> tag specified on
					 the type definition.</para> 
				<para>To explicitly specify the translation handler, the registered
					 class to be used can be specified as part of the type map definition. For
					 example, consider the following statement: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping { <emphasis role="bold">create type</emphasis> Degree <emphasis role="bold">class</emphasis> "SQLDevice.SQLDecimal" };</programlisting></para> 
		  </sect1> 
		  <sect1 id="DDGScalarTypeMapping-Host-ImplementedTypeMaps"> 
				<title><indexterm> 
						  <primary>Host-Implemented Type Maps</primary> 
					 </indexterm><indexterm> 
						  <primary>Scalar Type Mapping</primary> 
						  <secondary>Host-Implemented Type Maps</secondary> 
					 </indexterm>Host-Implemented Type Maps</title> 
				<para>In addition to the type maps provided by the SQL devices,
					 developers can build custom scalar type maps for use in mapping more complex
					 types into target system. The 
					 <phrase role="code">Coordinate</phrase> type in the 
					 <phrase role="code">Shipping</phrase> application utilizes a
					 custom scalar type map. The map is provided as a registered class in the 
					 <phrase role="code">Shipping</phrase> library. 
					 <footnote> 
						  <para>The source code for this map can be found in the 
								<phrase role="code">Source</phrase> subdirectory of the
								
								<phrase role="code">Shipping</phrase> library directory
								in the file 
								<phrase role="code">Domains.cs</phrase>.</para> 
					 </footnote>.</para> 
				<para>The following D4 statement uses the 
					 <phrase role="code">SQLCoordinate</phrase> registered class to
					 create the scalar type map for the 
					 <phrase role="code">Coordinate</phrase> type: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping { <emphasis role="bold">create type</emphasis> Coordinate <emphasis role="bold">class</emphasis> "Shipping.SQLCoordinate" };</programlisting></para> 
				<para>For more information on building host-implemented scalar type
					 maps, refer to the Dataphor Extender's Development Kit.</para> 
				<para>For more information on the library registration process,
					 refer to the 
					 <ulink type="olinka"
					 url="DDGWorkingWithLibraries.html"><citetitle>Working With
								Libraries</citetitle></ulink> chapter of the Logical Application Design part of
					 this guide.</para> 
		  </sect1> 
	 </chapter> 
	 <chapter id="DDGOperatorMapping"> 
		  <title><indexterm> 
					 <primary>Operator Mapping</primary> 
				</indexterm><indexterm> 
					 <primary>Physical Realization</primary> 
					 <secondary>Operator Mapping</secondary> 
				</indexterm>Operator Mapping</title> 
		  <para>Beyond basic data retrieval, many of the devices in the Dataphor
				product allow the target systems to be enlisted for use as query processors.
				The majority of the optimization tasks performed by the Dataphor query
				processor involve deciding where the various parts of a given expression will
				be evaluated.</para> 
		  <para>This flexibility allows the behavior of target systems to be
				modeled not only for the purpose of providing persistence, but in order to take
				advantage of the transactional and performance characteristics of those
				systems. The primary mechanism for describing the behavior of a target system
				is the <emphasis>operator map</emphasis>.</para> 
		  <para>Each device has a set of operator maps that indicate which D4
				operators are supported by the device. Note that only operators which return a
				value are mapped. Each operator map is responsible for determining whether a
				given expression containing an invocation of that operator is supported by the
				device, and how that invocation should be translated in order to be understood
				by the target system.</para> 
		  <para>Operator maps can be as simple as the mapping for integer
				addition, or as complex as the 
				<phrase role="code"><emphasis role="bold">join</emphasis></phrase>
				operator. For the SQL-based devices that ship with the Dataphor product, the
				system-defined operators that can be supported are already mapped. Support for
				additional operators can be provided relatively easily. This chapter discusses
				how operator maps work, and what is involved in their creation and
				usage.</para> 
		  <para>There are essentially four different methods for mapping
				operators into devices: 
				<itemizedlist> 
					 <listitem> 
						  <para>Map the operator using an existing translation
								handler.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Map the operator to a function call on the target
								system.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Map the operator as an in-lined expression in the
								target system dialect.</para> 
					 </listitem> 
					 <listitem> 
						  <para>Map the operator using a custom host-implemented
								translation handler.</para> 
					 </listitem> 
				</itemizedlist></para> 
		  <para>The first three methods of mapping will be discussed in the
				following sections but one. The final method of operator mapping is beyond the
				scope of this documentation. For more information on this method of operator,
				consult the Dataphor Extender's Development Kit.</para> 
		  <sect1 id="DDGOperatorMapping-GenericOperatorMaps"> 
				<title><indexterm> 
						  <primary>Generic Operator Maps</primary> 
					 </indexterm><indexterm> 
						  <primary>Operator Mapping</primary> 
						  <secondary>Generic Operator Maps</secondary> 
					 </indexterm>Generic Operator Maps</title> 
				<para>Common SQL support provides operator mapping classes for many
					 of the D4 system operators. In addition to support for specific operators, the
					 SQL device introduces several general purpose translators that can be used
					 without modification to handle most operator mappings.</para> 
				<para>The following table describes these handlers: 
					 <informaltable> 
						  <tgroup cols="2"> 
								<thead> 
									 <row> 
										  <entry>Translation Handler</entry> 
										  <entry>Functionality Provided</entry> 
									 </row> 
								</thead> 
								<tbody> 
									 <row> 
										  <entry><phrase
												role="code">SQLScalarSelector</phrase></entry> 
										  <entry>Provides a basic passthrough
												implementation, in other words, the operator mapped to this handler is skipped
												in the translation output. This is useful when the device representation for a
												particular data type is known to be the same as the device representation for
												the data type of the single scalar component of the representation for a given
												selector. For example, the type 
												<phrase role="code">ID {
													 <emphasis role="bold">representation</emphasis> ID { Value : String }
													 }</phrase> would have the same device representation as 
												<phrase role="code">String</phrase>, and so
												a selector invocation 
												<phrase role="code">ID("001")</phrase>
												would effectively be translated to just the string literal 
												<phrase role="code">"001"</phrase>.</entry>
										  
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLScalarReadAccessor</phrase></entry> 
										  <entry>Provides a basic passthrough
												implementation for read accessors. To continue with the above example, the
												invocation in D4 
												<phrase role="code">ID.Value</phrase> could
												be translated by simply ignoring the read accessor.</entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLScalarWriteAccessor</phrase></entry> 
										  <entry>Provides a basic passthrough
												implementation for write accessors. The D4 assignment to 
												<phrase role="code">ID.Value</phrase> can
												be translated to SQL by a replacement of the value if the representation has a
												single scalar component with the same device representation as the type
												itself.</entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLScalarIsSpecialOperator</phrase></entry> 
										  <entry>Provides a basic implementation for the 
												<phrase role="code">IsSpecial</phrase>
												operators created for each domain. If a domain has no specials, this handler is
												appropriate, as it always emits 
												<phrase role="code">0 = 1</phrase> or
												false, in SQL.</entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLCallOperator</phrase></entry> 
										  <entry>Provides a generic handler that is
												capable of invoking an operator in SQL. This handler has an attribute called 
												<phrase role="code">OperatorName</phrase>,
												set through the attributes in the class definition, which is used to construct
												the output. For example, if the operator name of the handler is 
												<phrase role="code">Rand</phrase>, and the
												handler is mapped to the D4 operator 
												<phrase role="code">Random</phrase>, the
												result of translating the D4 expression 
												<phrase role="code">Random(5)</phrase> is 
												<phrase role="code">Rand(5)</phrase>. The
												call operator works with any number of operands for the operator being mapped.
												This is useful when the implementation for a specific operator in D4 is
												provided by a user-defined function in the target system.</entry> 
									 </row> 
									 <row> 
										  <entry><phrase
												role="code">SQLUserOperator</phrase></entry> 
										  <entry>Provides a generic handler that allows
												the translated expression to be written directly. This handler has an attribute
												called 
												<phrase
												 role="code">TranslationString</phrase>, set through the attributes in the class
												definition, or directly with the 
												<phrase
												 role="code">Storage.TranslationString</phrase> tag of the operator map. The
												provided translation string may contain format markers to indicate where the
												translated expression for each argument is to be embedded. For example, given
												the translation string 
												<phrase role="code">{0} + {1}</phrase>, the
												D4 expression 
												<phrase role="code">1 + 2</phrase> would be
												translated directly as 
												<phrase role="code">1 + 2</phrase>.</entry>
										  
									 </row> 
								</tbody> 
						  </tgroup> 
					 </informaltable></para> 
		  </sect1> 
		  <sect1 id="DDGOperatorMapping-MappingOperatorswithExistingHandlers"> 
				<title><indexterm> 
						  <primary>Mapping Operators with Existing Handlers</primary>
						  
					 </indexterm><indexterm> 
						  <primary>Operator Mapping</primary> 
						  <secondary>Mapping Operators with Existing
								Handlers</secondary> 
					 </indexterm>Mapping Operators with Existing Handlers</title> 
				<para>The SQL devices provide a large number of existing
					 translation handlers to map the system-provided operators. In many cases, these
					 mappings can be used as-is to map certain common operators. For example, in the
					 
					 <phrase role="code">Shipping</phrase> application, the mapping
					 for 
					 <phrase
					  role="code">iMultiplication(ShippingRate,&nbsp;Distance)</phrase> is provided
					 by the following mapping: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping 
{ 
	<emphasis role="bold">create operator</emphasis> iMultiplication(Distance, ShippingRate) 
		<emphasis role="bold">class</emphasis> "SQLDevice.SQLMultiplication" 
};</programlisting></para> 
				<para>The advantage of using a dedicated translation handler such
					 as this one is that the mapping is device-independent, at least among the SQL
					 devices. Each device would be able to make use of this mapping, with any
					 syntactic differences in the actual invocation of the operator being handled by
					 the emitter of the specific device.</para> 
		  </sect1> 
		  <sect1 id="DDGOperatorMapping-MappingOperatorsasFunctions"> 
				<title><indexterm> 
						  <primary>Mapping Operators as Functions</primary> 
					 </indexterm><indexterm> 
						  <primary>Operator Mapping</primary> 
						  <secondary>Mapping Operators as Functions</secondary> 
					 </indexterm>Mapping Operators as Functions</title> 
				<para>To avoid having to create a host-implemented translation
					 handler for each operator to be mapped, the SQL devices allow for a generic
					 "call"-style mapping, which simply invokes the operator as a function call on
					 the target system. The name of the function to be invoked is specified as part
					 of the definition of the operator mapping. For example, the 
					 <phrase role="code">Distance</phrase> operator is mapped using
					 the following statement: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping
{
	<emphasis role="bold">create operator</emphasis> Distance(Coordinate, Coordinate) 
		<emphasis role="bold">class</emphasis> "SQLDevice.SQLCallOperator" 
			<emphasis role="bold">attributes</emphasis> { "OperatorName" = "dbo.Shipping_Distance" }
}</programlisting></para> 
		  </sect1> 
		  <sect1 id="DDGOperatorMapping-MappingOperatorsasExpressions"> 
				<title><indexterm> 
						  <primary>Mapping Operators as Expressions</primary> 
					 </indexterm><indexterm> 
						  <primary>Operator Mapping</primary> 
						  <secondary>Mapping Operators as Expressions</secondary> 
					 </indexterm>Mapping Operators as Expressions</title> 
				<para>If creating functions in the target system is not an option,
					 either for security reasons, or because the target system does not support
					 functions, the operator mapping may be specified using an in-line expression.
					 This method is accomplished specifying the 
					 <phrase role="code">Storage.TranslationString</phrase> tag on
					 the operator mapping: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping
{
	<emphasis role="bold">create operator</emphasis> iMultiplication(Distance, ShippingRate)
		<emphasis role="bold">tags</emphasis> { Storage.TranslationString = "{0} * {1}" }
};</programlisting></para> 
				<para>This mapping specifies that the operator is mapped by
					 inlining the given translation string, and replacing the parameter markers
					 (<phrase role="code">{0}</phrase>) with the translated expression representing
					 the argument specified by the index of the parameter marker.</para> 
				<para>This method of mapping will work for most operators, but it
					 will not work if the operator cannot be expressed in terms of a single
					 expression. For example, the definition of the 
					 <phrase role="code">Factorial</phrase> function requires the
					 use of a 
					 <phrase role="code"><emphasis
						  role="bold">while</emphasis></phrase> loop, and so cannot be expressed within a
					 single expression. In these cases, a function mapping must be used.</para> 
		  </sect1> 
		  <sect1 id="DDGOperatorMapping-MappingSelectorsandAccessors"> 
				<title><indexterm> 
						  <primary>Mapping Selectors and Accessors</primary> 
					 </indexterm><indexterm> 
						  <primary>Operator Mapping</primary> 
						  <secondary>Mapping Selectors and Accessors</secondary> 
					 </indexterm>Mapping Selectors and Accessors</title> 
				<para>Selectors and accessors form a large part of the mappings
					 required to support any given scalar type. Not only must the type map be
					 provided in order to translate values to and from the device, but the accessors
					 and selectors that appear within expressions referencing values of the type in
					 D4 must be translated so that the expressions can be mapped into the target
					 system.</para> 
				<para>For most 
					 <phrase role="code"><emphasis
						  role="bold">like</emphasis></phrase> types, this process is relatively
					 straightforward, and the Dataphor Server will usually provide the mappings
					 automatically. For relatively more complex types like the 
					 <phrase role="code">Degree</phrase> or 
					 <phrase role="code">Coordinate</phrase> types in the 
					 <phrase role="code">Shipping</phrase> application, these
					 mappings must be provided explicitly.</para> 
				<para>To illustrate the process, we will consider the mapping of
					 the 
					 <phrase role="code">Degree</phrase> type, and all of its
					 selectors and accessors. For reference, the following listing provides the
					 complete definition of the degree type: 
					 <programlisting><emphasis role="bold">create type</emphasis> Degree
{
	<emphasis role="bold">representation</emphasis> Degrees { Degrees : Decimal },
	<emphasis role="bold">representation</emphasis> Degree
	{
		DegreesPart : Integer
			<emphasis role="bold">read</emphasis> GetDegreesPart(<emphasis role="bold">value</emphasis>.Degrees)
			<emphasis role="bold">write</emphasis> Degrees(SetDegreesPart(<emphasis role="bold">value</emphasis>.Degrees, DegreesPart)),
		MinutesPart : Integer
			<emphasis role="bold">read</emphasis> GetMinutesPart(<emphasis role="bold">value</emphasis>.Degrees)
			<emphasis role="bold">write</emphasis> Degrees(SetMinutesPart(<emphasis role="bold">value</emphasis>.Degrees, MinutesPart)),
		SecondsPart : Decimal
			<emphasis role="bold">read</emphasis> GetSecondsPart(<emphasis role="bold">value</emphasis>.Degrees)
			<emphasis role="bold">write</emphasis> Degrees(SetSecondsPart(<emphasis role="bold">value</emphasis>.Degrees, SecondsPart))
	} <emphasis role="bold">selector</emphasis> Degrees(GetDegrees(DegreesPart, MinutesPart, SecondsPart)),
	<emphasis role="bold">representation</emphasis> AsString 
	{ 
		AsString : String 
			<emphasis role="bold">read</emphasis> DegreesToString(<emphasis role="bold">value</emphasis>.Degrees)
			<emphasis role="bold">write</emphasis> Degrees(StringToDegrees(AsString))
	} <emphasis role="bold">selector</emphasis> Degrees(StringToDegrees(AsString))
};</programlisting></para> 
				<para>Note that the definitions of the various operators used by
					 the selectors and accessors have been omitted here, but in order to support
					 queries that involve these operators, operator maps will have to be provided
					 for each one.</para> 
				<para>Because the native representation of the type is 
					 <phrase role="code">Decimal</phrase>, the type mapping itself
					 is relatively straightforward, and is automatically provided by the Dataphor
					 Server. For illustration, we list the generated mappings here: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping
{
	<emphasis role="bold">create type</emphasis> Degree <emphasis role="bold">class</emphasis> "SQLDevice.SQLDecimal",
	<emphasis role="bold">create operator</emphasis> Degrees(Decimal) <emphasis role="bold">class</emphasis> "SQLDevice.SQLScalarSelector",
	<emphasis role="bold">create operator</emphasis> Degrees.ReadDegrees(Degree) <emphasis role="bold">class</emphasis> "SQLDevice.SQLScalarReadAccessor",
	<emphasis role="bold">create operator</emphasis> Degrees.WriteDegrees(Degree, Decimal) <emphasis role="bold">class</emphasis> "SQLDevice.SQLScalarWriteAccessor",
	<emphasis role="bold">create operator</emphasis> iCompare(Degree, Degree) <emphasis role="bold">class</emphasis> "SQLDevice.SQLCompare",
	<emphasis role="bold">create operator</emphasis> IsSpecial(Degree) <emphasis role="bold">class</emphasis> "SQLDevice.SQLScalarIsSpecialOperator"
};</programlisting></para> 
				<para>By default, each of these mappings will be provided by the
					 Dataphor Server based on the native representation of 
					 <phrase role="code">Decimal</phrase>, and the existing 
					 <phrase role="code">Decimal</phrase> mappings for the
					 device.</para> 
				<para>However, the 
					 <phrase role="code">Degree</phrase> representation is
					 significantly more complex, and the mappings for this representation cannot be
					 provided automatically. Briefly, the following listing shows the operators that
					 must be mapped for this representation: 
					 <programlisting><emphasis role="bold">operator</emphasis> Degree(Integer, Integer, Decimal);
<emphasis role="bold">operator</emphasis> ReadDegreesPart(Degree);
<emphasis role="bold">operator</emphasis> WriteDegreesPart(Degree, Integer);
<emphasis role="bold">operator</emphasis> ReadMinutesPart(Degree);
<emphasis role="bold">operator</emphasis> WriteMinutesPart(Degree, Integer);
<emphasis role="bold">operator</emphasis> ReadSecondsPart(Degree);
<emphasis role="bold">operator</emphasis> WriteSecondsPart(Degree, Decimal);</programlisting></para> 
				<para>In the 
					 <phrase role="code">Shipping</phrase> application, each of
					 these operator is mapped into the target system by creating a function on the
					 target system, and using the 
					 <phrase role="code">SQLCallOperator</phrase> translation
					 handler to specify the mapping. For example, the following program listing
					 shows the definition of the function used to handle the 
					 <phrase role="code">Degree</phrase> selector: 
					 <programlisting><emphasis role="bold">create function</emphasis> Shipping_Degree
(
	@Degrees <emphasis role="bold">int</emphasis>, 
	@Minutes <emphasis role="bold">int</emphasis>, 
	@Seconds <emphasis role="bold">decimal</emphasis>(28, 8)
) <emphasis role="bold">returns</emphasis> decimal(28, 8)
<emphasis role="bold">begin</emphasis>
	<emphasis role="bold">return</emphasis> @Degrees + (@Minutes / 60.0) + (@Seconds / 3600.0)
<emphasis role="bold">end</emphasis></programlisting></para> 
				<para>This statement creates a function called 
					 <phrase role="code">Shipping_Degree</phrase> in the target
					 system. The following operator mapping then instructs the device that the 
					 <phrase role="code">Degree</phrase> selector is mapped by
					 invoking this function: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping
{
	<emphasis role="bold">create operator</emphasis> Degree(Integer, Integer, Decimal) 
		<emphasis role="bold">class</emphasis> "SQLDevice.SQLCallOperator" 
			<emphasis role="bold">attributes</emphasis> { "OperatorName" = "dbo.Shipping_Degree" }
};</programlisting></para> 
				<para>Alternatively, if functions cannot be created on the target
					 system, the following mapping may be used for the 
					 <phrase role="code">Degree</phrase> selector: 
					 <programlisting><emphasis role="bold">alter device</emphasis> Shipping
{
	<emphasis role="bold">create operator</emphasis> Degree(Integer, Integer, Decimal)
		<emphasis role="bold">tags</emphasis> { Storage.TranslationString = "{0} + ({1} / 60.0) + ({2} / 3600.0)" }
};</programlisting></para> 
				<para>This mapping instructs the device that the 
					 <phrase role="code">Degree</phrase> selector is mapped by
					 directly inlining the expression given in the translation string, replacing the
					 parameter markers (<phrase role="code">{0}</phrase>) with the translation for
					 the expression specified by the index of the parameter marker. Note that the
					 translation string is written directly in the dialect of the target system, so
					 this method of operator mapping is not immune to dialectic differences among
					 target systems.</para> 
		  </sect1> 
	 </chapter>

  <!--<chapter>
		  <title>Deployment and Maintenance</title>
		  <para>Restructuring in the presence of dependencies</para>
		  <para>Constructing Upgrade Scripts</para>
		  <para>Deployment scenarios</para>
		  <para>Installation requirements</para>
		  <para>Reverse Engineering existing schemas</para>
		  <para>Build data copying (integration)</para>
	 </chapter> 
-->
</part>
